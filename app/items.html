<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Veridian Atelier • Inventory Explorer</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Amiri&family=Inter:wght@400;500;600&family=Playfair+Display:wght@500;600;700&display=swap" rel="stylesheet">
  <link rel="icon" type="image/jpeg" href="../assets/logo-website-test.jpg">
  <link rel="apple-touch-icon" href="../assets/logo-website-test.jpg">
  <link rel="manifest" href="../manifest.webmanifest">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#2596be">
  <meta
    http-equiv="Content-Security-Policy"
    content="default-src 'self'; script-src 'self' 'unsafe-inline' https://unpkg.com; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; img-src 'self' https: data:; connect-src 'self' https://api.gold-api.com; child-src 'self' https://drive.google.com https://*.googleusercontent.com; frame-src 'self' https://drive.google.com https://*.googleusercontent.com; object-src 'none'; base-uri 'self'; frame-ancestors 'self'"
  >
  <script>
    window.__redirectToLogin = function redirectToLogin() {
      window.location.replace('../index.html');
    };

    window.handleUnauthorized = async function handleUnauthorized() {
      try {
        await fetch('../api/logout', { method: 'POST', credentials: 'include' });
      } catch (error) {
        console.warn('Failed to notify logout.', error);
      }
      window.__redirectToLogin();
    };

    (async () => {
      try {
        const response = await fetch('../api/session', { credentials: 'include' });
        if (!response.ok) {
          throw new Error('Session invalid');
        }
        const data = await response.json();
        if (!data?.authenticated) {
          throw new Error('Unauthenticated');
        }
      } catch (error) {
        window.__redirectToLogin();
      }
    })();
  </script>
  <style>
    :root {
      --pad: 18px;
      --gold-primary: #2596be;
      --gold-secondary: #2596be;
      --gold-dark: #1f7fa0;
      --gold-light: #e6f6fb;
      --ivory: #fafdff;
      --charcoal: #1f2a30;
      --warm-gray: #4f6b78;
      --accent-gold: #2596be;
      --bg: radial-gradient(circle at 10% 0%, rgba(37, 150, 190, 0.18) 0%, rgba(37, 150, 190, 0.08) 55%, #ffffff 100%);
      --glass: rgba(255, 255, 255, 0.94);
      --card-border: rgba(37, 150, 190, 0.26);
      --accent: var(--gold-primary);
      --accent-dark: var(--gold-dark);
      --text: var(--charcoal);
      --muted: var(--warm-gray);
      --shadow: 0 18px 40px -24px rgba(37, 150, 190, 0.35);
      --drawer-radius: clamp(22px, 6vw, 34px);
      --drawer-space: clamp(18px, 5vw, 32px);
      --drawer-gap: clamp(16px, 4vw, 26px);
      --drawer-title-size: clamp(1.2rem, 1.4vw + 1rem, 1.65rem);
      --drawer-body-size: clamp(0.95rem, 0.6vw + 0.92rem, 1.08rem);
    }

    html {
      scroll-behavior: smooth;
    }

    * {
      box-sizing: border-box;
    }

    body {
      min-height: 100vh;
      margin: 0;
      font-family: 'Inter', system-ui, -apple-system, Segoe UI, sans-serif;
      color: var(--text);
      background: var(--bg);
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: calc(var(--pad) * 1.2) var(--pad) calc(var(--pad) * 1.6);
    }


    .page {
      width: min(1100px, 100%);
      display: flex;
      flex-direction: column;
      gap: clamp(18px, 3vw, 28px);
    }

    header {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .header-top {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }
    .nav-actions {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }
    .language-toggle {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .language-toggle__panel {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      border-radius: 14px;
      background: rgba(255, 255, 255, 0.88);
      border: 1px solid rgba(37, 150, 190, 0.2);
      box-shadow: inset 0 0 0 1px rgba(37, 150, 190, 0.12), 0 16px 30px -20px rgba(37, 150, 190, 0.55);
      backdrop-filter: blur(6px);
    }
    .language-toggle select {
      border: none;
      background: transparent;
      font-family: inherit;
      font-size: 0.95rem;
      font-weight: 600;
      color: var(--accent-dark);
      cursor: pointer;
      outline: none;
      appearance: none;
      padding: 0;
    }
    .language-toggle select option {
      color: var(--text);
    }
    .refresh-button--compact {
      padding: 10px 18px;
      border-radius: 999px;
      min-width: 0;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      font-size: 0.95rem;
      font-weight: 600;
      letter-spacing: 0.01em;
      background: linear-gradient(135deg, var(--ocean-primary), var(--ocean-dark));
      box-shadow: 0 16px 36px -20px rgba(37, 150, 190, 0.6);
    }
    .refresh-button--compact .refresh-button__icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.16);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.38);
    }
    .refresh-button--compact svg {
      width: 18px;
      height: 18px;
    }
    .refresh-button__label {
      display: inline-flex;
      align-items: center;
      color: #fff;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }
    body.rtl .language-toggle__panel {
      flex-direction: row-reverse;
    }
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .brand-logo {
      height: 56px;
      width: auto;
      object-fit: contain;
      filter: drop-shadow(0 6px 16px rgba(37, 150, 190, 0.25));
    }

    .page-nav {
      position: relative;
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 999px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.92), rgba(229, 246, 251, 0.78));
      border: 1px solid rgba(37, 150, 190, 0.25);
      box-shadow: 0 18px 32px -22px rgba(37, 150, 190, 0.45);
      max-width: 100%;
      overflow-x: auto;
      overflow-y: hidden;
      scroll-snap-type: x proximity;
      -webkit-overflow-scrolling: touch;
      scrollbar-width: none;
      backdrop-filter: blur(12px);
    }

    .page-nav::-webkit-scrollbar { display: none; }

    .nav-link {
      flex: 0 0 auto;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 10px 18px;
      border-radius: 999px;
      font-weight: 600;
      font-size: 0.95rem;
      color: var(--accent-dark);
      text-decoration: none;
      transition: transform 0.2s ease, background 0.2s ease, box-shadow 0.2s ease, color 0.2s ease;
      background: rgba(255, 255, 255, 0.82);
      scroll-snap-align: center;
      min-width: max-content;
      box-shadow: inset 0 0 0 1px rgba(37, 150, 190, 0.12);
    }

    .nav-link:hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 24px -18px rgba(37, 150, 190, 0.45);
    }

    .nav-link:focus-visible {
      outline: 2px solid rgba(37, 150, 190, 0.55);
      outline-offset: 2px;
    }

    .nav-link:active {
      transform: scale(0.98);
    }

    .nav-link.active {
      background: linear-gradient(135deg, var(--gold-primary), var(--gold-dark));
      color: #fff;
      box-shadow: 0 14px 30px -18px rgba(37, 150, 190, 0.6);
    }

    .refresh-button {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 10px 16px;
      border: none;
      border-radius: 999px;
      font-size: 0.92rem;
      font-weight: 600;
      white-space: nowrap;
      background: linear-gradient(135deg, var(--gold-primary), var(--gold-dark));
      color: #fff;
      cursor: pointer;
      box-shadow: 0 14px 32px -18px rgba(37, 150, 190, 0.55);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .refresh-button svg {
      width: 18px;
      height: 18px;
    }

    .refresh-button:hover {
      transform: translateY(-1px);
      box-shadow: 0 18px 40px -18px rgba(37, 150, 190, 0.55);
    }

    .refresh-button.refresh-button--compact {
      padding: 10px 18px;
      border-radius: 999px;
      gap: 10px;
      background: linear-gradient(135deg, var(--ocean-primary), var(--ocean-dark));
      box-shadow: 0 16px 36px -20px rgba(37, 150, 190, 0.6);
    }

    .refresh-button.refresh-button--compact:hover {
      transform: translateY(-1px);
      box-shadow: 0 22px 42px -18px rgba(37, 150, 190, 0.6);
    }

    .hero-title {
      margin: 0;
      font-family: 'Playfair Display', 'Times New Roman', serif;
      font-size: clamp(1.6rem, 3.8vw, 2.4rem);
      letter-spacing: 0.02em;
      color: var(--text);
    }

    .hero-subtitle {
      margin: 0;
      font-size: clamp(0.95rem, 2vw, 1.05rem);
      color: var(--muted);
      max-width: 620px;
    }

    .glass-card {
      background: var(--glass);
      border: 1px solid var(--card-border);
      border-radius: 28px;
      padding: clamp(20px, 4vw, 32px);
      box-shadow: var(--shadow);
      backdrop-filter: blur(14px);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }

    .glass-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 25px 50px -12px rgba(37, 150, 190, 0.4);
    }

    .filter-card {
      display: grid;
      gap: 18px;
    }

    .filter-grid {
      display: grid;
      gap: 16px;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }

    .filter-group {
      display: grid;
      gap: 8px;
    }

    .sort-options {
      display: grid;
      gap: 12px;
      margin: 0;
      padding: 0;
      border: none;
    }

    .sort-options legend {
      font-size: 0.95rem;
      font-weight: 600;
      font-family: 'Playfair Display', serif;
      color: var(--accent-dark);
    }

    .sort-chips {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    }

    .sort-chip {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 4px;
      padding: 14px 16px;
      border-radius: 20px;
      border: 1px solid rgba(37, 150, 190, 0.22);
      background: linear-gradient(140deg, rgba(255, 255, 255, 0.92) 0%, rgba(230, 246, 251, 0.9) 100%);
      color: var(--muted);
      font-weight: 500;
      letter-spacing: 0.01em;
      transition: transform 0.25s ease, box-shadow 0.25s ease, border-color 0.25s ease, background 0.25s ease;
      cursor: pointer;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.45);
    }

    .sort-chip::after {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: radial-gradient(circle at 0% 0%, rgba(37, 150, 190, 0.18), transparent 60%);
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }

    .sort-chip:hover {
      transform: translateY(-2px);
      border-color: rgba(37, 150, 190, 0.38);
      box-shadow: 0 18px 32px -24px rgba(37, 150, 190, 0.55);
    }

    .sort-chip:hover::after {
      opacity: 1;
    }

    .sort-chip:focus-visible {
      outline: 3px solid rgba(37, 150, 190, 0.38);
      outline-offset: 3px;
    }

    .sort-chip__title {
      font-size: 0.95rem;
      font-weight: 600;
      color: var(--text);
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .sort-chip__badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: rgba(37, 150, 190, 0.18);
      color: var(--accent-dark);
      font-size: 0.75rem;
      font-weight: 600;
    }

    .sort-chip__subtitle {
      font-size: 0.75rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .sort-chip.is-active {
      background: linear-gradient(135deg, var(--accent), var(--accent-dark));
      border-color: rgba(37, 150, 190, 0.6);
      box-shadow: 0 22px 40px -20px rgba(37, 150, 190, 0.75);
      color: #fff;
    }

    .sort-chip.is-active::after {
      opacity: 0.5;
      background: radial-gradient(circle at 100% 0%, rgba(255, 255, 255, 0.35), transparent 65%);
    }

    .sort-chip.is-active .sort-chip__title,
    .sort-chip.is-active .sort-chip__subtitle {
      color: #fff;
    }

    .sort-chip.is-active .sort-chip__badge {
      background: rgba(255, 255, 255, 0.2);
      color: #fff;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.35);
    }

    .sort-options__current {
      margin: 0;
      font-size: 0.88rem;
      color: var(--muted);
    }

    label {
      font-weight: 600;
      font-size: 0.95rem;
      font-family: 'Playfair Display', serif;
    }

    select,
    button,
    input {
      font-family: inherit;
      border-radius: 14px;
      border: 1px solid rgba(37, 150, 190, 0.25);
      padding: 12px 14px;
      font-size: 0.98rem;
      background: rgba(255, 255, 255, 0.92);
      box-shadow: inset 0 1px 1px rgba(255, 255, 255, 0.4);
      transition: transform 120ms ease, box-shadow 200ms ease, border-color 160ms ease;
    }

    select:focus,
    button:focus,
    input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(37, 150, 190, 0.25);
    }

    button:focus-visible,
    input:focus-visible,
    select:focus-visible {
      outline: 2px solid var(--gold-primary);
      outline-offset: 2px;
    }

    button {
      background: linear-gradient(135deg, var(--gold-primary), var(--gold-dark));
      color: #fff;
      border: none;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 14px 32px -18px rgba(37, 150, 190, 0.45);
    }

    button:disabled {
      cursor: not-allowed;
      opacity: 0.65;
      background: rgba(37, 150, 190, 0.35);
      box-shadow: none;
    }

    button:not(:disabled):hover {
      transform: translateY(-1px);
    }

    .range-inputs {
      display: grid;
      grid-template-columns: minmax(0, 1fr) auto minmax(0, 1fr);
      align-items: center;
      gap: 8px;
    }

    .range-inputs input {
      width: 100%;
      min-width: 0;
    }

    .range-inputs span {
      font-weight: 600;
      color: var(--muted);
      font-size: 0.9rem;
      text-align: center;
    }

    .view-toggle {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      padding: 6px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.72);
      border: 1px solid rgba(37, 150, 190, 0.25);
      box-shadow: 0 12px 24px -18px rgba(37, 150, 190, 0.35);
      width: fit-content;
    }

    .toggle-pill {
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 999px;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 600;
    }

    .toggle-pill input {
      position: absolute;
      inset: 0;
      opacity: 0;
      cursor: pointer;
    }

    .toggle-pill__surface {
      position: absolute;
      inset: 0;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.82);
      transition: all 0.2s ease;
      box-shadow: inset 0 1px 1px rgba(255, 255, 255, 0.4);
    }

    .toggle-pill__label {
      position: relative;
      z-index: 1;
      padding: 8px 18px;
      color: var(--accent-dark);
      white-space: nowrap;
    }

    .toggle-pill input:checked ~ .toggle-pill__surface {
      background: linear-gradient(135deg, var(--gold-primary), var(--gold-dark));
      box-shadow: 0 14px 30px -20px rgba(37, 150, 190, 0.55);
    }

    .toggle-pill input:checked ~ .toggle-pill__label {
      color: #fff;
    }

    .status-row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .status-row strong {
      color: var(--accent-dark);
    }

    .gold-price-form {
      margin-top: 12px;
      display: grid;
      gap: 12px;
    }

    .gold-price-entry {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }

    .gold-price-entry label {
      font-weight: 600;
      font-size: 0.95rem;
      font-family: 'Playfair Display', serif;
    }

    .gold-price-entry input {
      width: 160px;
    }

    #goldPriceClear {
      background: rgba(255, 255, 255, 0.92);
      border: 1px solid rgba(37, 150, 190, 0.25);
      color: var(--accent-dark);
      box-shadow: none;
      font-weight: 500;
    }

    .gold-price-suggestions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      font-size: 0.9rem;
      color: var(--muted);
    }

    .gold-price-suggestions span {
      font-weight: 500;
    }

    .gold-price-suggestions button {
      background: rgba(229, 246, 251, 0.9);
      border: 1px solid rgba(37, 150, 190, 0.25);
      color: var(--accent-dark);
      box-shadow: none;
      padding: 8px 12px;
      font-size: 0.88rem;
    }

    .gold-price-suggestions button:disabled {
      opacity: 0.6;
    }

    .results-card {
      display: grid;
      gap: 18px;
    }

    .results-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .results-count {
      font-weight: 600;
      color: var(--accent-dark);
      font-family: 'Playfair Display', serif;
    }

    .items-grid {
      display: grid;
      gap: clamp(16px, 2.5vw, 22px);
    }

    .items-grid[data-view="detailed"] {
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
    }

    .items-grid[data-view="compact"] {
      grid-template-columns: repeat(3, minmax(0, 1fr));
    }

    .item-card {
      display: grid;
      gap: 16px;
      padding: 18px;
      border-radius: 22px;
      border: 1px solid rgba(37, 150, 190, 0.25);
      background: rgba(255, 255, 255, 0.9);
      box-shadow: 0 18px 40px -24px rgba(37, 150, 190, 0.35);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .item-card--highlight {
      box-shadow: 0 0 0 3px rgba(37, 150, 190, 0.35), 0 25px 48px -20px rgba(37, 150, 190, 0.45);
      transform: translateY(-1px);
    }

    .item-card--compact {
      grid-template-rows: auto 1fr;
      padding: 14px;
    }

    .item-card--detailed {
      grid-template-columns: minmax(0, 240px) 1fr;
      align-items: stretch;
    }

    .item-card:hover {
      transform: translateY(-1px);
      box-shadow: 0 25px 48px -20px rgba(37, 150, 190, 0.45);
    }

    .item-card[data-interactive="true"] {
      cursor: pointer;
    }

    .item-card:focus-visible {
      outline: 3px solid rgba(37, 150, 190, 0.45);
      outline-offset: 4px;
    }

    .item-card__media {
      position: relative;
      border-radius: 18px;
      overflow: hidden;
      background: rgba(37, 150, 190, 0.08);
      box-shadow: inset 0 0 0 1px rgba(37, 150, 190, 0.12);
    }

    .item-card--compact .item-card__media {
      aspect-ratio: 1;
    }

    .item-card--detailed .item-card__media {
      min-height: 240px;
      aspect-ratio: 3 / 4;
    }

    .item-card__photo {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    @media (max-width: 480px) {
      .item-card__photo {
        object-fit: contain;
      }
    }

    .item-card__photo--placeholder {
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--muted);
      font-weight: 600;
      background: rgba(255, 255, 255, 0.6);
      padding: 16px;
      text-align: center;
    }

    .item-card__body {
      display: grid;
      gap: 16px;
    }

    .item-card--compact .item-card__body {
      gap: 12px;
      justify-items: center;
      text-align: center;
    }

    .item-card__actions {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 4px;
    }

    .item-card--compact .item-card__actions {
      justify-content: center;
    }

    .share-button {
      appearance: none;
      border: none;
      border-radius: 999px;
      padding: 10px 18px;
      background: linear-gradient(135deg, rgba(37, 150, 190, 0.95), rgba(31, 127, 160, 0.95));
      color: #fff;
      font-weight: 600;
      font-size: 0.9rem;
      letter-spacing: 0.01em;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      box-shadow: 0 14px 28px -18px rgba(37, 150, 190, 0.55);
      transition: transform 0.2s ease, box-shadow 0.2s ease, filter 0.2s ease;
    }

    .share-button:hover:not(:disabled),
    .share-button:focus-visible:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 18px 40px -18px rgba(31, 127, 160, 0.65);
    }

    .share-button:disabled {
      cursor: progress;
      filter: grayscale(0.2);
      opacity: 0.8;
    }

    .item-card__header {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
    }

    .item-card--compact .item-card__header {
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100%;
      gap: 6px;
    }

    .item-card--compact .item-card__title {
      text-align: center;
    }

    .item-card__title {
      display: grid;
      gap: 4px;
    }

    .item-card__name {
      margin: 0;
      font-family: 'Playfair Display', serif;
      font-size: 1.1rem;
    }

    .item-card--compact .item-card__name {
      font-size: 1rem;
    }

    .item-card__sku {
      display: inline-flex;
      align-items: center;
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(37, 150, 190, 0.12);
      color: var(--accent-dark);
      font-weight: 600;
      font-size: 0.85rem;
    }

    .item-card--compact .item-card__sku {
      justify-content: center;
      width: 100%;
    }

    .item-card__price {
      display: grid;
      gap: 4px;
      text-align: right;
    }

    .item-card--compact .item-card__price {
      text-align: center;
      width: 100%;
    }

    .item-card__price span {
      color: var(--muted);
      font-size: 0.85rem;
    }

    .item-card--compact .item-card__price span {
      font-size: 0.8rem;
    }

    .item-card__price strong {
      font-family: 'Playfair Display', serif;
      font-size: 1.2rem;
      color: var(--accent-dark);
    }

    .item-card--compact .item-card__price strong {
      font-size: 1.35rem;
    }

    .item-card__meta {
      display: grid;
      gap: clamp(12px, 3vw, 18px);
      font-size: clamp(0.92rem, 0.45vw + 0.88rem, 1rem);
      width: 100%;
    }

    .item-card__meta-row {
      display: grid;
      gap: clamp(10px, 2.6vw, 14px);
    }

    .item-card__meta-entry {
      display: grid;
      grid-template-columns: max-content minmax(0, 1fr);
      gap: clamp(8px, 2vw, 12px);
      align-items: baseline;
      width: 100%;
    }

    .item-card__meta-label {
      color: var(--muted);
      font-weight: 600;
      font-size: clamp(0.88rem, 0.35vw + 0.85rem, 0.98rem);
    }

    .item-card__meta-label::after {
      content: ':';
      margin-inline-start: 4px;
      color: rgba(139, 125, 107, 0.7);
    }

    .item-card__meta-value {
      justify-self: start;
      color: var(--accent-dark);
      font-weight: 600;
      font-size: var(--drawer-body-size);
      text-align: start;
      word-break: break-word;
    }

    .item-card--compact .item-card__meta {
      justify-items: center;
      text-align: start;
    }

    .item-card--compact .item-card__meta-entry {
      margin: 0 auto;
      max-width: 260px;
    }

    .item-card--compact .item-card__meta-value {
      justify-self: start;
    }

    .item-card__description {
      margin: 0;
      color: var(--muted);
      line-height: 1.5;
    }

    .item-card--compact .item-card__description {
      display: none;
    }

    .item-card--compact .item-card__meta-row:not(:first-child) {
      display: none;
    }

    .item-card__badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      font-size: 0.85rem;
    }

    .item-card--compact .item-card__badge-row {
      justify-content: center;
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      border-radius: 999px;
      background: rgba(229, 246, 251, 0.85);
      border: 1px solid rgba(37, 150, 190, 0.25);
      color: var(--accent-dark);
      font-weight: 600;
    }

    .search-container {
      display: grid;
      gap: 10px;
      width: 100%;
    }

    .search-container input {
      width: 100%;
      border-radius: 16px;
      padding: 14px 18px;
      font-size: 1rem;
      background: rgba(255, 255, 255, 0.9);
      border: 1.5px solid rgba(31, 127, 160, 0.16);
      transition: all 0.3s ease;
    }

    .search-container input:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(37, 150, 190, 0.18);
      background: rgba(255, 255, 255, 0.95);
    }

    .search-container label {
      font-weight: 600;
      font-size: 0.9rem;
      color: var(--muted);
    }

    .search-results {
      border: 1px solid var(--card-border);
      border-radius: 18px;
      background: rgba(255, 255, 255, 0.86);
      box-shadow: var(--shadow);
      padding: 12px;
      display: grid;
      gap: 10px;
    }

    .search-results[hidden] {
      display: none;
    }

    .search-results button.search-result {
      display: flex;
      flex-direction: column;
      text-align: start;
      gap: 6px;
      padding: 12px;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid rgba(37, 150, 190, 0.24);
      border-radius: 16px;
      color: var(--text);
      font-weight: 500;
      transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
    }

    .search-results button.search-result:hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 28px -16px rgba(37, 150, 190, 0.35);
      border-color: rgba(37, 150, 190, 0.45);
    }

    .search-results button.search-result:focus-visible {
      outline: 3px solid rgba(37, 150, 190, 0.45);
      outline-offset: 2px;
    }

    .search-result-title {
      font-size: 0.95rem;
      font-weight: 600;
      color: var(--text);
      line-height: 1.3;
    }

    .search-result-meta {
      font-size: 0.8rem;
      color: var(--muted);
      line-height: 1.4;
    }

    .search-empty {
      margin: 0;
      text-align: center;
      padding: 26px 18px;
      color: var(--warm-gray);
      font-style: italic;
      background: rgba(37, 150, 190, 0.08);
      border-radius: 16px;
      border: 2px dashed rgba(37, 150, 190, 0.2);
    }

    .search-results__summary {
      margin: 0;
      font-size: 0.85rem;
      color: var(--muted);
    }

    .empty-state {
      margin: 0;
      padding: 16px;
      border-radius: 16px;
      background: rgba(255, 255, 255, 0.86);
      border: 1px dashed rgba(37, 150, 190, 0.35);
      color: var(--muted);
      text-align: center;
      font-size: 0.98rem;
    }

    .item-details-dialog {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: clamp(20px, 6vw, 40px);
      background: rgba(15, 42, 52, 0.45);
      backdrop-filter: blur(6px);
      z-index: 1000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s ease;
    }

    .item-details-dialog.is-visible {
      opacity: 1;
      pointer-events: auto;
    }

    .item-details-dialog__surface {
      position: relative;
      width: min(100%, 720px);
      max-height: 90vh;
      overflow-y: auto;
      overflow-x: hidden;
      border-radius: var(--drawer-radius);
      border: 1px solid rgba(37, 150, 190, 0.3);
      border-inline-end: 2px solid rgba(37, 150, 190, 0.48);
      background:
        radial-gradient(circle at 100% 18%, rgba(37, 150, 190, 0.16), transparent 55%),
        linear-gradient(140deg, rgba(255, 255, 255, 0.97) 0%, rgba(229, 246, 251, 0.93) 100%);
      box-shadow:
        0 40px 70px -35px rgba(37, 150, 190, 0.6),
        20px 0 36px -28px rgba(37, 150, 190, 0.5),
        inset 0 0 0 1px rgba(255, 255, 255, 0.45);
      padding: var(--drawer-space);
      display: flex;
      scrollbar-gutter: stable both-edges;
    }

    .item-details-dialog__surface::after {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: inherit;
      pointer-events: none;
      border-inline-end: 1px solid rgba(19, 94, 120, 0.55);
      box-shadow: inset -12px 0 22px -20px rgba(37, 150, 190, 0.45);
      mix-blend-mode: multiply;
      opacity: 0.8;
    }

    .item-details-dialog__layout {
      position: relative;
      display: flex;
      flex-direction: column;
      gap: var(--drawer-gap);
      width: 100%;
      font-size: var(--drawer-body-size);
    }

    .item-details-dialog__header {
      display: flex;
      align-items: flex-start;
      gap: clamp(12px, 3vw, 22px);
    }

    .item-details-dialog__title {
      margin: 0;
      font-size: var(--drawer-title-size);
      font-family: 'Playfair Display', serif;
      color: var(--accent-dark);
      line-height: 1.25;
      text-align: start;
    }

    .item-details-dialog__close {
      border: none;
      background: rgba(255, 255, 255, 0.92);
      border-radius: 999px;
      padding: clamp(8px, 2vw, 12px) clamp(16px, 4vw, 22px);
      font-size: clamp(0.9rem, 0.5vw + 0.86rem, 1.02rem);
      font-weight: 600;
      color: var(--accent-dark);
      cursor: pointer;
      box-shadow: 0 14px 32px -20px rgba(37, 150, 190, 0.45);
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
      margin-inline-start: auto;
      flex-shrink: 0;
    }

    .item-details-dialog__close:hover {
      transform: translateY(-1px);
      box-shadow: 0 20px 36px -24px rgba(37, 150, 190, 0.5);
    }

    .item-details-dialog__close:focus-visible {
      outline: 2px solid rgba(37, 150, 190, 0.6);
      outline-offset: 3px;
    }

    .item-details-dialog__body {
      display: grid;
      gap: var(--drawer-gap);
    }

    .item-details-dialog__body .item-card {
      box-shadow: none;
      border: 1px solid rgba(37, 150, 190, 0.28);
      background: rgba(255, 255, 255, 0.98);
      border-radius: clamp(18px, 4vw, 26px);
      padding: clamp(18px, 4vw, 28px);
      gap: clamp(16px, 4vw, 24px);
    }

    .item-details-dialog__body .item-card__media {
      display: flex;
      align-items: center;
      justify-content: center;
      aspect-ratio: auto;
      max-height: min(65vh, 460px);
      padding: clamp(12px, 4vw, 20px);
      background: rgba(37, 150, 190, 0.04);
      border-radius: clamp(18px, 4vw, 24px);
      overflow: hidden;
    }

    .item-details-dialog__body .item-card__photo {
      display: block;
      width: 100%;
      max-width: 100%;
      height: auto;
      max-height: 100%;
      object-fit: contain;
      border-radius: clamp(16px, 4vw, 22px);
    }

    .item-details-dialog__body .item-card__actions {
      flex-direction: column;
      align-items: stretch;
      gap: clamp(10px, 3vw, 16px);
      width: 100%;
    }

    .item-details-dialog__body .item-card:hover {
      transform: none;
      box-shadow: none;
    }

    @media (max-width: 480px) {
      .item-details-dialog__surface {
        margin-inline: clamp(12px, 4vw, 18px);
        padding: clamp(16px, 5vw, 24px);
      }

      .item-details-dialog__header {
        flex-direction: column;
        align-items: stretch;
        gap: clamp(10px, 3vw, 16px);
      }

      .item-details-dialog__close {
        width: 100%;
      }

      .item-details-dialog__body .item-card__media {
        padding: clamp(10px, 5vw, 18px);
      }
    }

    @media (min-width: 480px) {
      .item-details-dialog__surface {
        padding: calc(var(--drawer-space) + 6px);
      }

      .item-details-dialog__body .item-card {
        padding: calc(var(--drawer-space) + 4px);
      }
    }

    @media (min-width: 768px) {
      .item-details-dialog__body .item-card__actions {
        flex-direction: row;
        align-items: center;
        justify-content: flex-end;
      }

      .item-details-dialog__body .item-card__meta-row {
        grid-template-columns: repeat(2, minmax(0, 1fr));
        column-gap: clamp(18px, 4vw, 26px);
      }
    }

    body.dialog-open {
      overflow: hidden;
    }
    body.rtl {
      direction: rtl;
      font-family: 'Amiri', 'Inter', system-ui, -apple-system, Segoe UI, sans-serif;
    }
    body.rtl header {
      text-align: right;
      align-items: flex-end;
    }
    body.rtl .header-top {
      justify-content: flex-start;
    }
    body.rtl .page-nav {
      direction: rtl;
      justify-content: flex-end;
    }
    body.rtl .filter-grid,
    body.rtl .sort-options,
    body.rtl .view-toggle,
    body.rtl .status-row,
    body.rtl .items-grid,
    body.rtl .item-card__meta-row {
      direction: rtl;
    }
    body.rtl .filter-group,
    body.rtl .sort-options,
    body.rtl .view-toggle,
    body.rtl .status-row,
    body.rtl .results-header {
      text-align: right;
    }
    body.rtl .sort-chip__title,
    body.rtl .toggle-pill__label,
    body.rtl .item-card__price,
    body.rtl .item-card__badge-row,
    body.rtl .item-card__description {
      text-align: right;
    }
    body.rtl .item-card__header {
      flex-direction: row-reverse;
    }
    body.rtl .item-card__price {
      align-items: flex-start;
    }
    body.rtl .item-card__meta-entry {
      justify-content: space-between;
    }
    body.rtl .item-card__sku {
      justify-content: center;
    }

    body.rtl .item-details-dialog__header {
      flex-direction: row-reverse;
      align-items: center;
    }

    body.rtl .item-details-dialog__close {
      margin-inline-end: auto;
      margin-inline-start: 0;
    }

    @media (max-width: 1100px) {
      .items-grid[data-view="compact"] {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    @media (max-width: 900px) {
      .item-card--detailed {
        grid-template-columns: 1fr;
      }

      .item-card--detailed .item-card__media {
        aspect-ratio: 4 / 3;
      }
    }

    @media (max-width: 720px) {
      body {
        padding: calc(var(--pad) * 1.1) var(--pad) calc(var(--pad) * 1.5);
      }
      header {
        text-align: left;
        align-items: stretch;
        gap: 14px;
      }
      .header-top {
        width: 100%;
        display: flex;
        flex-direction: column;
        align-items: stretch;
        gap: 12px;
      }
      .nav-actions {
        width: 100%;
        justify-content: flex-start;
      }
      .page-nav {
        width: 100%;
        justify-content: flex-start;
      }
      .language-toggle__panel {
        width: 100%;
        justify-content: space-between;
      }
      .language-toggle__panel select {
        flex: 1 1 auto;
      }
      .brand-logo {
        height: 44px;
        align-self: center;
      }
      body.rtl header {
        text-align: right;
      }
      body.rtl .header-top {
        align-items: stretch;
      }
      .status-row { justify-content: center; }
      .items-grid[data-view="compact"] { grid-template-columns: repeat(2, minmax(0, 1fr)); }
      .item-card--compact .item-card__header { align-items: center; }
      .item-card--compact .item-card__price { text-align: center; }
    }

    @media (max-width: 360px) {
      .items-grid[data-view="compact"] {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="page" id="inventoryPage">
    <header>
      <div class="header-top">
        <img src="../assets/logo-website-test.jpg" alt="Veridian Atelier logo" class="brand-logo" />
        <div class="nav-actions">
          <nav class="page-nav" aria-label="Workspace navigation" data-i18n-aria-label="navAria">
            <a class="nav-link" href="./index.html" data-i18n="navScanner">Scanner</a>
            <a class="nav-link active" href="./items.html" aria-current="page" data-i18n="navInventory">Inventory</a>
            <a class="nav-link" href="./sales.html" data-i18n="navSales">Sales log</a>
            <a class="nav-link" href="./purchases.html" data-i18n="navPurchases">Purchase log</a>
            <a class="nav-link" href="./statement.html" data-i18n="navStatement">Gold statement</a>
          </nav>
        </div>
        <div class="language-toggle">
          <label for="languageToggle" class="sr-only" data-i18n="languageLabel">Language</label>
          <div class="language-toggle__panel">
            <select id="languageToggle" aria-label="Select language">
              <option value="en">English</option>
              <option value="ar">العربية</option>
            </select>
            <button
              type="button"
              id="refreshButton"
              class="refresh-button refresh-button--compact"
              aria-label="Refresh inventory page"
              data-i18n-aria-label="navRefreshAria"
            >
              <span class="refresh-button__icon" aria-hidden="true">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <polyline points="23 4 23 10 17 10"></polyline>
                  <polyline points="1 20 1 14 7 14"></polyline>
                  <path d="M3.51 9a9 9 0 0 1 14.36-3.36L23 10"></path>
                  <path d="M20.49 15a9 9 0 0 1-14.36 3.36L1 14"></path>
                </svg>
              </span>
              <span class="refresh-button__label" data-i18n="navRefresh">Refresh</span>
            </button>
          </div>
        </div>
      </div>
      <h1 class="hero-title" data-i18n="heroTitle">Inventory explorer</h1>
      <p class="hero-subtitle" data-i18n="heroSubtitle">Browse the current collection, refine by category and target price, and pick the layout that suits the conversation.</p>
      <div class="search-container">
        <label class="sr-only" for="inventorySearch" data-i18n="searchLabel">Search inventory</label>
        <input
          type="search"
          id="inventorySearch"
          name="inventory-search"
          placeholder="Search items by SKU, category, or description…"
          autocomplete="off"
          spellcheck="false"
        />
        <div id="inventorySearchResults" class="search-results" hidden aria-live="polite"></div>
      </div>
    </header>

    <section class="glass-card filter-card" id="filtersSection" aria-label="Inventory filters">
      <div class="filter-grid">
        <div class="filter-group">
          <label for="categoryFilter" data-i18n="filterCategoryLabel">Category</label>
          <select id="categoryFilter" name="category">
            <option value="" data-i18n="filterCategoryAll">All categories</option>
          </select>
        </div>
        <div class="filter-group">
          <label for="availabilityFilter" data-i18n="filterAvailabilityLabel">Availability</label>
          <select id="availabilityFilter" name="availability">
            <option value="" data-i18n="filterAvailabilityAll">All items</option>
            <option value="available" data-i18n="filterAvailabilityAvailable">Available</option>
            <option value="not-available" data-i18n="filterAvailabilityNotAvailable">Not available</option>
          </select>
        </div>
        <div class="filter-group">
          <label for="priceMin" data-i18n="filterPriceLabel">Price range</label>
          <div class="range-inputs">
            <input type="number" id="priceMin" placeholder="Min" min="0" step="0.01" inputmode="decimal">
            <span data-i18n="filterPriceTo">to</span>
            <input type="number" id="priceMax" placeholder="Max" min="0" step="0.01" inputmode="decimal">
          </div>
        </div>
      </div>
      <fieldset class="sort-options">
        <legend data-i18n="sortLegend">Sort by</legend>
        <div
          class="sort-chips"
          data-sort-group
          role="radiogroup"
          aria-label="Sort inventory by"
          aria-describedby="sortSelection"
        >
          <button
            type="button"
            class="sort-chip"
            data-sort-button
            data-sort-index="0"
            id="sortOptionSku"
            role="radio"
            aria-checked="false"
            tabindex="-1"
          >
            <span class="sort-chip__title">
              <span class="sort-chip__badge" aria-hidden="true">#</span>
              <span class="sort-chip__label" data-sort-label></span>
            </span>
            <span class="sort-chip__subtitle" data-sort-subtitle></span>
          </button>
          <button
            type="button"
            class="sort-chip is-active"
            data-sort-button
            data-sort-index="1"
            id="sortOptionPriceAsc"
            role="radio"
            aria-checked="true"
            tabindex="0"
          >
            <span class="sort-chip__title">
              <span class="sort-chip__badge" aria-hidden="true">↑</span>
              <span class="sort-chip__label" data-sort-label></span>
            </span>
            <span class="sort-chip__subtitle" data-sort-subtitle></span>
          </button>
          <button
            type="button"
            class="sort-chip"
            data-sort-button
            data-sort-index="2"
            id="sortOptionPriceDesc"
            role="radio"
            aria-checked="false"
            tabindex="-1"
          >
            <span class="sort-chip__title">
              <span class="sort-chip__badge" aria-hidden="true">↓</span>
              <span class="sort-chip__label" data-sort-label></span>
            </span>
            <span class="sort-chip__subtitle" data-sort-subtitle></span>
          </button>
          <button
            type="button"
            class="sort-chip"
            data-sort-button
            data-sort-index="3"
            id="sortOptionWeightAsc"
            role="radio"
            aria-checked="false"
            tabindex="-1"
          >
            <span class="sort-chip__title">
              <span class="sort-chip__badge" aria-hidden="true">⇧</span>
              <span class="sort-chip__label" data-sort-label></span>
            </span>
            <span class="sort-chip__subtitle" data-sort-subtitle></span>
          </button>
          <button
            type="button"
            class="sort-chip"
            data-sort-button
            data-sort-index="4"
            id="sortOptionWeightDesc"
            role="radio"
            aria-checked="false"
            tabindex="-1"
          >
            <span class="sort-chip__title">
              <span class="sort-chip__badge" aria-hidden="true">⇩</span>
              <span class="sort-chip__label" data-sort-label></span>
            </span>
            <span class="sort-chip__subtitle" data-sort-subtitle></span>
          </button>
        </div>
        <p class="sort-options__current" id="sortSelection" aria-live="polite" data-i18n-dynamic>Sorting by Price (Low to High)</p>
      </fieldset>
      <div class="status-row">
        <div id="itemsStatus" aria-live="polite" data-i18n="statusLoading" data-i18n-dynamic>Loading inventory…</div>
        <div
          id="goldStatus"
          class="gold-status"
          aria-live="polite"
          data-i18n="goldStatusLiveDefault"
          data-i18n-dynamic
        >Using live price…</div>
      </div>
      <form id="goldPriceForm" class="gold-price-form" aria-label="Gold price override">
        <div class="gold-price-entry">
          <label for="goldPriceInput" data-i18n="goldLabel">Gold price override:</label>
          <input
            type="number"
            id="goldPriceInput"
            name="goldPriceInput"
            min="0"
            step="0.01"
            inputmode="decimal"
            placeholder="2300"
          />
          <button type="submit" data-i18n="goldApply">Apply</button>
          <button type="button" id="goldPriceClear" data-i18n="goldUseLive">Use live price</button>
        </div>
        <div
          class="gold-price-suggestions"
          role="group"
          aria-label="Quick gold price suggestions"
          data-i18n-aria-label="goldSuggestionsAria"
        >
          <span data-i18n="goldQuickAdd">Quick add:</span>
          <button type="button" data-gold-suggestion="30" data-i18n="goldSuggestion30">Live + 30</button>
          <button type="button" data-gold-suggestion="50" data-i18n="goldSuggestion50">Live + 50</button>
          <button type="button" data-gold-suggestion="70" data-i18n="goldSuggestion70">Live + 70</button>
          <button type="button" data-gold-suggestion="100" data-i18n="goldSuggestion100">Live + 100</button>
        </div>
      </form>
      <div>
        <button type="button" id="resetFilters" data-i18n="resetFilters">Reset filters</button>
      </div>
    </section>

    <section class="glass-card results-card" id="resultsSection" aria-label="Inventory results">
      <div class="results-header">
        <h2 data-i18n="resultsHeading">Items</h2>
        <span class="results-count" id="resultsCount" data-i18n-dynamic>0 items</span>
      </div>
      <div class="items-grid" id="itemsGrid" role="list" data-view="compact"></div>
    </section>
  </div>

  <div
    class="item-details-dialog"
    id="itemDetailsDialog"
    role="dialog"
    aria-modal="true"
    aria-hidden="true"
    aria-labelledby="itemDetailsHeading"
  >
    <div class="item-details-dialog__surface" role="document">
      <div class="item-details-dialog__layout">
        <div class="item-details-dialog__header">
          <h2 class="item-details-dialog__title" id="itemDetailsHeading" data-i18n="detailsHeading">Item details</h2>
          <button type="button" class="item-details-dialog__close" id="itemDetailsClose" data-i18n="detailsClose">
            Close details
          </button>
        </div>
        <div class="item-details-dialog__body" id="itemDetailsContainer"></div>
      </div>
    </div>
  </div>

  <script>
    (function () {
      'use strict';

      const DEFAULT_CONFIG = {
        inventoryEndpoint: '/api/inventory',
        authEndpoint: '/api/auth',
        salesEndpoint: '/api/sales',
        goldPriceUrl: 'https://api.gold-api.com/price/XAU'
      };

      const APP_CONFIG = Object.freeze({
        ...DEFAULT_CONFIG,
        ...(window.APP_CONFIG && typeof window.APP_CONFIG === 'object' ? window.APP_CONFIG : {})
      });

      const refreshButton = document.getElementById('refreshButton');
      if (refreshButton) {
        refreshButton.addEventListener('click', () => {
          window.location.reload();
        });
      }

      const INVENTORY_ENDPOINT = APP_CONFIG.inventoryEndpoint;
      const GOLD_API = APP_CONFIG.goldPriceUrl;
      const PREMIUM = 30;
      const OUNCE_GRAMS = 32;
      const SHARE_LOGO_URL = '../assets/logo-website-test.jpg';

      const categorySelect = document.getElementById('categoryFilter');
      const availabilitySelect = document.getElementById('availabilityFilter');
      const priceMinInput = document.getElementById('priceMin');
      const priceMaxInput = document.getElementById('priceMax');
      const resetFiltersBtn = document.getElementById('resetFilters');
      const sortGroup = document.querySelector('[data-sort-group]');
      const sortButtons = Array.from(document.querySelectorAll('[data-sort-button]'));
      const sortSelection = document.getElementById('sortSelection');
      const itemsGrid = document.getElementById('itemsGrid');
      const resultsCount = document.getElementById('resultsCount');
      const itemsStatus = document.getElementById('itemsStatus');
      const goldPriceStatus = document.getElementById('goldStatus');
      const goldPriceForm = document.getElementById('goldPriceForm');
      const goldPriceInput = document.getElementById('goldPriceInput');
      const goldPriceClear = document.getElementById('goldPriceClear');
      const goldSuggestionButtons = Array.from(document.querySelectorAll('[data-gold-suggestion]'));
      const goldSuggestionsGroup = document.querySelector('.gold-price-suggestions');
      const searchInput = document.getElementById('inventorySearch');
      const searchResultsEl = document.getElementById('inventorySearchResults');
      const searchLabel = document.querySelector('[data-i18n="searchLabel"]');
      const languageToggle = document.getElementById('languageToggle');
      const filtersSection = document.getElementById('filtersSection');
      const resultsSection = document.getElementById('resultsSection');
      const itemDetailsDialog = document.getElementById('itemDetailsDialog');
      const itemDetailsContainer = document.getElementById('itemDetailsContainer');
      const itemDetailsClose = document.getElementById('itemDetailsClose');
      const i18nElements = document.querySelectorAll('[data-i18n]');

      const translations = {
        en: {
          pageTitle: 'Veridian Atelier • Inventory Explorer',
          languageLabel: 'Language',
          languageSelectAria: 'Select language',
          navScanner: 'Scanner',
          navInventory: 'Inventory',
          navSales: 'Sales log',
          navPurchases: 'Purchase log',
          navStatement: 'Gold statement',
          navRefresh: 'Refresh',
          navRefreshAria: 'Refresh inventory page',
          heroTitle: 'Inventory explorer',
          heroSubtitle:
            'Browse the current collection, refine by category and target price, and pick the layout that suits the conversation.',
          searchLabel: 'Search inventory',
          searchPlaceholder: 'Search items by SKU, category, or description…',
          searchHint: 'Type at least two characters to search the inventory.',
          searchLoading: 'Inventory still loading…',
          searchNoMatches: 'No items match this search. Adjust the filters or try another term.',
          searchHiddenMatches: 'All matching items are hidden by the current filters.',
          searchSummary: '{count} matches shown below.',
          searchSummarySingular: '1 match shown below.',
          searchSummaryFiltered: '{visible} of {total} matches shown with current filters.',
          searchMoreMatches: '+{count} more matches available in the grid.',
          searchMoreMatchesSingular: '+1 more match available in the grid.',
          filtersSectionAria: 'Inventory filters',
          filterCategoryLabel: 'Category',
          filterCategoryAll: 'All categories',
          filterAvailabilityLabel: 'Availability',
          filterAvailabilityAll: 'All items',
          filterAvailabilityAvailable: 'Available',
          filterAvailabilityNotAvailable: 'Not available',
          filterPriceLabel: 'Price range',
          filterPriceTo: 'to',
          filterPriceMinPlaceholder: 'Min',
          filterPriceMaxPlaceholder: 'Max',
          sortLegend: 'Sort by',
          sortAriaLabel: 'Sort inventory by',
          sortOptionSku: 'SKU',
          sortOptionSkuSubtitle: 'Catalog order',
          sortOptionSkuShort: 'SKU',
          sortAnnouncementSku: 'Sorted by SKU (ascending)',
          sortOptionPrice: 'Price',
          sortOptionPriceAscSubtitle: 'Low → High',
          sortOptionPriceAscShort: 'Price ↑',
          sortAnnouncementPriceAsc: 'Sorted by price low to high',
          sortOptionPriceDescSubtitle: 'High → Low',
          sortOptionPriceDescShort: 'Price ↓',
          sortAnnouncementPriceDesc: 'Sorted by price high to low',
          sortOptionWeight: 'Weight',
          sortOptionWeightAscSubtitle: 'Light → Heavy',
          sortOptionWeightAscShort: 'Weight ↑',
          sortAnnouncementWeightAsc: 'Sorted by weight light to heavy',
          sortOptionWeightDescSubtitle: 'Heavy → Light',
          sortOptionWeightDescShort: 'Weight ↓',
          sortAnnouncementWeightDesc: 'Sorted by weight heavy to light',
          sortCurrent: 'Sorting by {label}',
          statusLoading: 'Loading inventory…',
          statusNoData: 'No inventory data available yet.',
          statusSummary: 'Showing <strong>{visible}</strong> of <strong>{total}</strong> items',
          resultsHeading: 'Items',
          resultsCountSingular: '{count} item',
          resultsCountPlural: '{count} items',
          resetFilters: 'Reset filters',
          detailsHeading: 'Item details',
          detailsClose: 'Close details',
          viewModeCompact: 'Compact',
          goldFormAria: 'Gold price override',
          goldLabel: 'Gold price override:',
          goldPlaceholder: '2300',
          goldApply: 'Apply',
          goldUseLive: 'Use live price',
          goldStatusLiveDefault: 'Using live price…',
          goldStatusManual: 'Using manual price {price}',
          goldStatusManualUpdated: 'set {time}',
          goldStatusLive: 'Using live price {price}',
          goldStatusLiveUpdated: 'updated {time}',
          goldStatusWaiting: 'Waiting for live price…',
          statusSeparator: ' • ',
          goldSuggestionsAria: 'Quick gold price suggestions',
          goldQuickAdd: 'Quick add:',
          goldSuggestion30: 'Live + 30',
          goldSuggestion50: 'Live + 50',
          goldSuggestion70: 'Live + 70',
          goldSuggestion100: 'Live + 100',
          goldInvalid: 'Enter a valid gold price.',
          goldStatusWithPrice: 'Gold price {price}',
          goldStatusUpdated: 'updated {time}',
          goldStatusUnavailable: 'Gold price unavailable — prices shown use sheet data only.',
          goldStatusSeparator: ' • ',
          photoUnavailable: 'Photo unavailable',
          photoAltNamed: '{name} photo',
          photoAltItem: 'Item photo',
          skuLabel: 'SKU {value}',
          itemDefaultName: 'Item',
          priceSheet: 'Sheet price',
          priceEstimated: 'Estimated price',
          priceNotAvailable: 'Not available',
          metaWeight: 'Weight',
          metaKarat: 'Karat',
          metaCategory: 'Category',
          metaFees: 'Fees',
          metaStatus: 'Status',
          metaPerGram: 'Per gram',
          badgeUpdated: 'Updated {value}',
          unitGram: 'g',
          weightDisplay: '{value} g',
          perGramDisplay: '{value} / g',
          emptyFilters:
            'No items match your filters yet. Adjust the filters or reset them to see the full collection.',
          emptyNoRows: 'No inventory rows are available yet.',
          errorStatus: 'Unable to load inventory. Please refresh after checking your connection.',
          errorEmpty: 'We could not reach the inventory service. Please try again in a moment.'
        },
        ar: {
          pageTitle: 'Veridian Atelier • مستكشف المخزون',
          languageLabel: 'اللغة',
          languageSelectAria: 'اختيار اللغة',
          navScanner: 'الماسح',
          navInventory: 'المخزون',
          navSales: 'سجل المبيعات',
          navPurchases: 'سجل المشتريات',
          navStatement: 'بيان الذهب',
          navRefresh: 'تحديث',
          navRefreshAria: 'تحديث صفحة الجرد',
          heroTitle: 'مستكشف المخزون',
          heroSubtitle:
            'تصفح التشكيلة الحالية، وقم بتصفية النتائج حسب الفئة والسعر المستهدف، واختر العرض الأنسب للحوار.',
          searchLabel: 'ابحث في المخزون',
          searchPlaceholder: 'ابحث عن القطع برمز الصنف أو الفئة أو الوصف…',
          searchHint: 'اكتب حرفين على الأقل لبدء البحث في المخزون.',
          searchLoading: 'لا يزال المخزون قيد التحميل…',
          searchNoMatches: 'لا توجد قطع مطابقة لهذا البحث. عدّل المرشحات أو جرّب عبارة أخرى.',
          searchHiddenMatches: 'جميع القطع المطابقة مخفية بسبب المرشحات الحالية.',
          searchSummary: '{count} نتيجة معروضة أدناه.',
          searchSummarySingular: 'نتيجة واحدة معروضة أدناه.',
          searchSummaryFiltered: '{visible} من {total} نتيجة معروضة وفقًا للمرشحات الحالية.',
          searchMoreMatches: '+{count} نتيجة إضافية متاحة ضمن الشبكة.',
          searchMoreMatchesSingular: '+نتيجة إضافية واحدة متاحة ضمن الشبكة.',
          filtersSectionAria: 'مرشحات المخزون',
          filterCategoryLabel: 'الفئة',
          filterCategoryAll: 'جميع الفئات',
          filterAvailabilityLabel: 'التوفر',
          filterAvailabilityAll: 'جميع القطع',
          filterAvailabilityAvailable: 'متوفر',
          filterAvailabilityNotAvailable: 'غير متوفر',
          filterPriceLabel: 'نطاق السعر',
          filterPriceTo: 'إلى',
          filterPriceMinPlaceholder: 'الحد الأدنى',
          filterPriceMaxPlaceholder: 'الحد الأقصى',
          sortLegend: 'ترتيب حسب',
          sortAriaLabel: 'ترتيب المخزون حسب',
          sortOptionSku: 'رمز الصنف',
          sortOptionSkuSubtitle: 'ترتيب الكتالوج',
          sortOptionSkuShort: 'رمز',
          sortAnnouncementSku: 'تم الترتيب حسب رمز الصنف تصاعديًا',
          sortOptionPrice: 'السعر',
          sortOptionPriceAscSubtitle: 'منخفض → مرتفع',
          sortOptionPriceAscShort: 'السعر ↑',
          sortAnnouncementPriceAsc: 'تم الترتيب حسب السعر من الأقل إلى الأعلى',
          sortOptionPriceDescSubtitle: 'مرتفع → منخفض',
          sortOptionPriceDescShort: 'السعر ↓',
          sortAnnouncementPriceDesc: 'تم الترتيب حسب السعر من الأعلى إلى الأقل',
          sortOptionWeight: 'الوزن',
          sortOptionWeightAscSubtitle: 'خفيف → ثقيل',
          sortOptionWeightAscShort: 'الوزن ↑',
          sortAnnouncementWeightAsc: 'تم الترتيب حسب الوزن من الأخف إلى الأثقل',
          sortOptionWeightDescSubtitle: 'ثقيل → خفيف',
          sortOptionWeightDescShort: 'الوزن ↓',
          sortAnnouncementWeightDesc: 'تم الترتيب حسب الوزن من الأثقل إلى الأخف',
          sortCurrent: 'يتم الترتيب حسب {label}',
          statusLoading: 'جاري تحميل المخزون…',
          statusNoData: 'لا تتوفر بيانات مخزون بعد.',
          statusSummary: 'عرض <strong>{visible}</strong> من أصل <strong>{total}</strong> قطعة',
          resultsHeading: 'القطع',
          resultsCountSingular: '{count} قطعة',
          resultsCountPlural: '{count} قطع',
          resetFilters: 'إعادة تعيين المرشحات',
          detailsHeading: 'تفاصيل القطعة',
          detailsClose: 'إغلاق التفاصيل',
          viewModeCompact: 'عرض مضغوط',
          goldFormAria: 'تعديل سعر الذهب',
          goldLabel: 'سعر الذهب (مخصص):',
          goldPlaceholder: '2300',
          goldApply: 'تطبيق',
          goldUseLive: 'استخدام السعر المباشر',
          goldStatusLiveDefault: 'يتم استخدام السعر المباشر…',
          goldStatusManual: 'يتم استخدام السعر المخصص {price}',
          goldStatusManualUpdated: 'تم تعيينه في {time}',
          goldStatusLive: 'يتم استخدام السعر المباشر {price}',
          goldStatusLiveUpdated: 'تم التحديث في {time}',
          goldStatusWaiting: 'في انتظار السعر المباشر…',
          statusSeparator: ' • ',
          goldSuggestionsAria: 'اقتراحات سريعة لسعر الذهب',
          goldQuickAdd: 'إضافة سريعة:',
          goldSuggestion30: 'المباشر + 30',
          goldSuggestion50: 'المباشر + 50',
          goldSuggestion70: 'المباشر + 70',
          goldSuggestion100: 'المباشر + 100',
          goldInvalid: 'أدخل سعر ذهب صالحًا.',
          goldStatusWithPrice: 'سعر الذهب {price}',
          goldStatusUpdated: 'تم التحديث في {time}',
          goldStatusUnavailable: 'تعذر الحصول على سعر الذهب — يتم استخدام بيانات الجدول فقط.',
          goldStatusSeparator: ' • ',
          photoUnavailable: 'الصورة غير متاحة',
          photoAltNamed: 'صورة {name}',
          photoAltItem: 'صورة القطعة',
          skuLabel: 'رمز الصنف {value}',
          itemDefaultName: 'قطعة',
          priceSheet: 'سعر الجدول',
          priceEstimated: 'سعر تقديري',
          priceNotAvailable: 'غير متاح',
          metaWeight: 'الوزن',
          metaKarat: 'العيار',
          metaCategory: 'الفئة',
          metaFees: 'الأجور',
          metaStatus: 'الحالة',
          metaPerGram: 'لكل غرام',
          badgeUpdated: 'تم التحديث {value}',
          unitGram: 'غ',
          weightDisplay: '{value} غ',
          perGramDisplay: '{value} / غ',
          emptyFilters:
            'لا توجد قطع مطابقة للمرشحات الحالية. عدّل المرشحات أو أعد تعيينها لمشاهدة المجموعة كاملة.',
          emptyNoRows: 'لا توجد صفوف مخزون متاحة بعد.',
          errorStatus: 'تعذر تحميل المخزون. يرجى التحديث بعد التحقق من الاتصال.',
          errorEmpty: 'تعذر الوصول إلى خدمة المخزون. حاول مرة أخرى بعد قليل.'
        }
      };

      let currentLanguage = localStorage.getItem('statementLanguage') === 'ar' ? 'ar' : 'en';

      function t(key, replacements) {
        const langTable = translations[currentLanguage] || translations.en;
        const template = key in langTable ? langTable[key] : translations.en[key] || key;
        if (!replacements) return template;
        return template.replace(/\{(\w+)\}/g, (match, token) => {
          if (Object.prototype.hasOwnProperty.call(replacements, token)) {
            return replacements[token];
          }
          return match;
        });
      }

      function getLocale() {
        return currentLanguage === 'ar' ? 'ar-EG' : undefined;
      }

      function formatNumber(value) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) return String(value ?? '');
        const locale = getLocale();
        return numeric.toLocaleString(locale);
      }

      function formatCurrency(value) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) return t('priceNotAvailable');
        const locale = getLocale();
        return numeric.toLocaleString(locale, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
      }

      function formatWeightDisplay(value) {
        if (!Number.isFinite(value)) return '';
        const locale = getLocale();
        const formatted = value.toLocaleString(locale, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        return t('weightDisplay', { value: formatted });
      }

      function formatPerGram(value) {
        if (!Number.isFinite(value)) return '';
        const locale = getLocale();
        const formatted = value.toLocaleString(locale, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        return t('perGramDisplay', { value: formatted });
      }

      function isManualGoldActive() {
        return Number.isFinite(state.goldPriceManual) && state.goldPriceManual > 0;
      }

      function getActiveGoldPrice() {
        if (isManualGoldActive()) {
          return state.goldPriceManual;
        }
        return state.goldPrice;
      }

      function getSuggestionBasePrice() {
        if (Number.isFinite(state.goldPrice) && state.goldPrice > 0) {
          return state.goldPrice;
        }
        if (Number.isFinite(state.goldPriceManual) && state.goldPriceManual > 0) {
          return state.goldPriceManual;
        }
        return NaN;
      }

      function updateLanguageAttributes() {
        document.documentElement.lang = currentLanguage === 'ar' ? 'ar' : 'en';
        document.documentElement.dir = currentLanguage === 'ar' ? 'rtl' : 'ltr';
        document.body.classList.toggle('rtl', currentLanguage === 'ar');
      }

      function renderStaticText() {
        document.title = t('pageTitle');
        i18nElements.forEach((element) => {
          if (!(element instanceof HTMLElement)) return;
          if (element.hasAttribute('data-i18n-dynamic')) return;
          const key = element.getAttribute('data-i18n');
          if (!key) return;
          element.textContent = t(key);
        });

        if (languageToggle) {
          languageToggle.value = currentLanguage;
          languageToggle.setAttribute('aria-label', t('languageSelectAria'));
        }

        if (filtersSection) {
          filtersSection.setAttribute('aria-label', t('filtersSectionAria'));
        }

        if (resultsSection) {
          resultsSection.setAttribute('aria-label', t('resultsHeading'));
        }

        if (sortGroup) {
          sortGroup.setAttribute('aria-label', t('sortAriaLabel'));
        }

        if (priceMinInput) {
          priceMinInput.placeholder = t('filterPriceMinPlaceholder');
        }
        if (priceMaxInput) {
          priceMaxInput.placeholder = t('filterPriceMaxPlaceholder');
        }
        if (searchInput) {
          searchInput.placeholder = t('searchPlaceholder');
        }
        if (searchLabel) {
          searchLabel.textContent = t('searchLabel');
        }
        if (goldPriceForm) {
          goldPriceForm.setAttribute('aria-label', t('goldFormAria'));
        }
        if (goldPriceInput) {
          goldPriceInput.placeholder = t('goldPlaceholder');
        }
        if (goldPriceClear) {
          goldPriceClear.setAttribute('aria-label', t('goldUseLive'));
        }
        if (goldSuggestionsGroup) {
          goldSuggestionsGroup.setAttribute('aria-label', t('goldSuggestionsAria'));
        }
        updateSearchResultsList();
      }

      function updateFilterOptionLabels() {
        if (categorySelect) {
          const defaultOption = categorySelect.querySelector('option[value=""]');
          if (defaultOption) {
            defaultOption.textContent = t('filterCategoryAll');
          }
        }
        if (availabilitySelect) {
          const defaultOption = availabilitySelect.querySelector('option[value=""]');
          const availableOption = availabilitySelect.querySelector('option[value="available"]');
          const notAvailableOption = availabilitySelect.querySelector('option[value="not-available"]');
          if (defaultOption) defaultOption.textContent = t('filterAvailabilityAll');
          if (availableOption) availableOption.textContent = t('filterAvailabilityAvailable');
          if (notAvailableOption) notAvailableOption.textContent = t('filterAvailabilityNotAvailable');
        }
      }

      function updateSortLabels() {
        sortButtons.forEach((button) => {
          const index = clampSortIndex(button.getAttribute('data-sort-index'));
          const option = SORT_OPTIONS[index] ?? SORT_OPTIONS[0];
          const labelEl = button.querySelector('.sort-chip__label');
          const subtitleEl = button.querySelector('.sort-chip__subtitle');
          if (labelEl) labelEl.textContent = t(option.labelKey);
          if (subtitleEl) subtitleEl.textContent = t(option.subtitleKey);
          if (option.announcementKey) {
            button.setAttribute('aria-label', t(option.announcementKey));
          }
        });
        if (sortGroup) {
          sortGroup.setAttribute('aria-label', t('sortAriaLabel'));
        }
      }

      const uiState = {
        statusMode: 'loading',
        total: 0,
        visible: 0,
        emptyType: 'none'
      };

      function refreshStatusText() {
        if (!itemsStatus) return;
        if (uiState.statusMode === 'loading') {
          itemsStatus.textContent = t('statusLoading');
          return;
        }
        if (uiState.statusMode === 'error') {
          itemsStatus.textContent = t('errorStatus');
          return;
        }
        if (uiState.statusMode === 'no-data') {
          itemsStatus.textContent = t('statusNoData');
          return;
        }
        const visibleText = formatNumber(uiState.visible);
        const totalText = formatNumber(uiState.total);
        itemsStatus.innerHTML = t('statusSummary', { visible: visibleText, total: totalText });
      }

      function refreshResultsCount() {
        if (!resultsCount) return;
        const count = Number(uiState.visible);
        const formatted = formatNumber(count);
        if (count === 1) {
          resultsCount.textContent = t('resultsCountSingular', { count: formatted });
        } else {
          resultsCount.textContent = t('resultsCountPlural', { count: formatted });
        }
      }

      function refreshGoldStatus() {
        if (!goldPriceStatus) return;
        if (isManualGoldActive()) {
          const priceText = formatCurrency(state.goldPriceManual);
          const parts = [t('goldStatusManual', { price: priceText })];
          if (state.goldManualUpdatedAt) {
            parts.push(t('goldStatusManualUpdated', { time: sanitize(state.goldManualUpdatedAt) }));
          }
          goldPriceStatus.textContent = parts.join(t('statusSeparator'));
        } else if (Number.isFinite(state.goldPrice) && state.goldPrice > 0) {
          const priceText = formatCurrency(state.goldPrice);
          const parts = [t('goldStatusLive', { price: priceText })];
          if (state.goldUpdatedAt) {
            parts.push(t('goldStatusLiveUpdated', { time: sanitize(state.goldUpdatedAt) }));
          }
          goldPriceStatus.textContent = parts.join(t('statusSeparator'));
        } else {
          goldPriceStatus.textContent = t('goldStatusWaiting');
        }
        updateGoldSuggestionButtons();
      }

      function updateGoldSuggestionButtons() {
        const base = getSuggestionBasePrice();
        const enabled = Number.isFinite(base) && base > 0;
        goldSuggestionButtons.forEach((button) => {
          if (!(button instanceof HTMLButtonElement)) return;
          button.disabled = !enabled;
        });
      }

      function refreshGoldDerivedFields() {
        if (!state.dataLoaded) return;
        if (Array.isArray(state.rawRows) && state.rawRows.length) {
          enrichRows(state.rawRows.slice());
        } else {
          applyFilters();
        }
      }

      function setManualGoldPrice(value) {
        if (!Number.isFinite(value) || value <= 0) {
          return false;
        }
        state.goldPriceManual = value;
        try {
          state.goldManualUpdatedAt = new Date().toLocaleString(getLocale());
        } catch (error) {
          state.goldManualUpdatedAt = new Date().toLocaleString();
        }
        refreshGoldStatus();
        refreshGoldDerivedFields();
        return true;
      }

      function clearManualGoldPrice() {
        const wasManual = isManualGoldActive();
        state.goldPriceManual = null;
        state.goldManualUpdatedAt = '';
        refreshGoldStatus();
        if (wasManual) {
          refreshGoldDerivedFields();
        }
      }

      function refreshEmptyMessage() {
        if (!itemsGrid) return;
        const emptyEl = itemsGrid.querySelector('.empty-state');
        if (!emptyEl) return;
        const type = emptyEl.dataset.emptyType || uiState.emptyType;
        if (type === 'filters') {
          emptyEl.textContent = t('emptyFilters');
        } else if (type === 'no-data') {
          emptyEl.textContent = t('emptyNoRows');
        } else if (type === 'error') {
          emptyEl.textContent = t('errorEmpty');
        }
      }

      function refreshLanguageDependentText() {
        updateLanguageAttributes();
        renderStaticText();
        updateFilterOptionLabels();
        updateSortLabels();
        const activeIndex = Number.isInteger(state.sortIndex)
          ? state.sortIndex
          : RESOLVED_DEFAULT_SORT_INDEX;
        setSortByIndex(activeIndex, { trigger: false });
        refreshGoldStatus();
        refreshStatusText();
        refreshResultsCount();
        refreshEmptyMessage();
        if (isItemDetailsOpen() && lastOpenedDetailsRow && itemDetailsContainer) {
          itemDetailsContainer.innerHTML = '';
          const detailCard = createItemCard(lastOpenedDetailsRow, 'detailed', { interactive: false, role: 'article' });
          itemDetailsContainer.appendChild(detailCard);
        }
        if (state.dataLoaded) {
          applyFilters();
        }
      }

      function applyLanguage(language) {
        const nextLanguage = translations[language] ? language : 'en';
        if (currentLanguage !== nextLanguage) {
          currentLanguage = nextLanguage;
          localStorage.setItem('statementLanguage', currentLanguage);
        }
        refreshLanguageDependentText();
      }

      const SORT_OPTIONS = Object.freeze([
        {
          value: 'sku',
          labelKey: 'sortOptionSku',
          subtitleKey: 'sortOptionSkuSubtitle',
          shortKey: 'sortOptionSkuShort',
          announcementKey: 'sortAnnouncementSku'
        },
        {
          value: 'price-asc',
          labelKey: 'sortOptionPrice',
          subtitleKey: 'sortOptionPriceAscSubtitle',
          shortKey: 'sortOptionPriceAscShort',
          announcementKey: 'sortAnnouncementPriceAsc'
        },
        {
          value: 'price-desc',
          labelKey: 'sortOptionPrice',
          subtitleKey: 'sortOptionPriceDescSubtitle',
          shortKey: 'sortOptionPriceDescShort',
          announcementKey: 'sortAnnouncementPriceDesc'
        },
        {
          value: 'weight-asc',
          labelKey: 'sortOptionWeight',
          subtitleKey: 'sortOptionWeightAscSubtitle',
          shortKey: 'sortOptionWeightAscShort',
          announcementKey: 'sortAnnouncementWeightAsc'
        },
        {
          value: 'weight-desc',
          labelKey: 'sortOptionWeight',
          subtitleKey: 'sortOptionWeightDescSubtitle',
          shortKey: 'sortOptionWeightDescShort',
          announcementKey: 'sortAnnouncementWeightDesc'
        }
      ]);
      const DEFAULT_SORT_INDEX = SORT_OPTIONS.findIndex((option) => option.value === 'price-asc');
      const RESOLVED_DEFAULT_SORT_INDEX = DEFAULT_SORT_INDEX >= 0 ? DEFAULT_SORT_INDEX : 0;

      const state = {
        rows: [],
        rawRows: [],
        filtered: [],
        viewMode: 'compact',
        sortBy: SORT_OPTIONS[RESOLVED_DEFAULT_SORT_INDEX]?.value ?? SORT_OPTIONS[0].value,
        sortIndex: RESOLVED_DEFAULT_SORT_INDEX,
        goldPrice: null,
        goldUpdatedAt: '',
        goldPriceManual: null,
        goldManualUpdatedAt: '',
        categoryKey: null,
        searchQuery: '',
        searchQueryNormalized: '',
        searchActive: false,
        searchMatchCount: null,
        dataLoaded: false
      };

      function drawRoundedRect(ctx, x, y, width, height, radius = 0) {
        const effectiveRadius = Math.min(Math.max(Number(radius) || 0, 0), Math.min(width, height) / 2);
        ctx.beginPath();
        ctx.moveTo(x + effectiveRadius, y);
        ctx.lineTo(x + width - effectiveRadius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + effectiveRadius);
        ctx.lineTo(x + width, y + height - effectiveRadius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - effectiveRadius, y + height);
        ctx.lineTo(x + effectiveRadius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - effectiveRadius);
        ctx.lineTo(x, y + effectiveRadius);
        ctx.quadraticCurveTo(x, y, x + effectiveRadius, y);
        ctx.closePath();
      }

      function wrapText(ctx, text, maxWidth) {
        const content = String(text ?? '').trim();
        if (!content) {
          return [];
        }

        const words = content.split(/\s+/);
        const lines = [];
        let currentLine = words.shift() || '';

        for (const word of words) {
          const testLine = `${currentLine} ${word}`.trim();
          if (ctx.measureText(testLine).width <= maxWidth || !currentLine) {
            currentLine = testLine;
          } else {
            lines.push(currentLine);
            currentLine = word;
          }
        }

        if (currentLine) {
          lines.push(currentLine);
        }

        return lines;
      }

      function createShareFilename(row) {
        const parts = [];
        if (row.__name) parts.push(row.__name);
        if (row.__sku) parts.push(`SKU ${row.__sku}`);
        const base = normalizeDigits(parts.join(' ') || 'item').toLowerCase();
        const slug = base.replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '') || 'item';
        return `${slug}.png`;
      }

      function createShareDetails(row) {
        const details = [];
        const addDetail = (label, value) => {
          const normalized = String(value ?? '').trim();
          if (!normalized) return;
          if (/^not available$/i.test(normalized)) return;
          details.push({ label, value: normalized });
        };

        const numberFormatter = new Intl.NumberFormat('en-US', {
          minimumFractionDigits: 2,
          maximumFractionDigits: 2
        });

        const priceLabel = row.__priceSource === 'sheet' ? 'Sheet price' : 'Estimated price';
        let priceValue = '';
        if (Number.isFinite(row.__price)) {
          priceValue = `${numberFormatter.format(row.__price)} USD`;
        } else if (row.__priceFallback) {
          priceValue = row.__priceFallback;
        }
        addDetail(priceLabel, priceValue || 'Not available');

        let weightValue = '';
        if (Number.isFinite(row.__weight)) {
          weightValue = `${numberFormatter.format(row.__weight)} g`;
        } else if (row.__weightRaw) {
          weightValue = row.__weightRaw;
        }
        addDetail('Weight', weightValue);

        addDetail('Karat', row.__karat);

        let availability = '';
        if (row.__availabilityState === 'available') {
          availability = 'Available';
        } else if (row.__availabilityState === 'not-available') {
          availability = 'Not available';
        } else if (row.__availabilityRaw) {
          availability = row.__availabilityRaw;
        }
        addDetail('Status', availability);

        const activeGold = getActiveGoldPrice();
        if (Number.isFinite(activeGold)) {
          const label = isManualGoldActive() ? 'Manual gold base' : 'Gold base';
          addDetail(label, `${activeGold.toFixed(2)} USD`);
        }
        const updatedStamp = isManualGoldActive() ? state.goldManualUpdatedAt : state.goldUpdatedAt;
        addDetail('Updated', updatedStamp);
        return details;
      }

      function createShareSummaryText(row) {
        const lines = [];
        const title = row.__name || (row.__sku ? `SKU ${row.__sku}` : 'Inventory item');
        lines.push(title);
        for (const detail of createShareDetails(row)) {
          lines.push(`${detail.label}: ${detail.value}`);
        }
        if (row.__description) {
          lines.push('');
          lines.push(row.__description);
        }
        return lines.join('\n');
      }

      function triggerDownload(blob, filename) {
        const url = URL.createObjectURL(blob);
        const anchor = document.createElement('a');
        anchor.href = url;
        anchor.download = filename;
        document.body.appendChild(anchor);
        anchor.click();
        anchor.remove();
        setTimeout(() => URL.revokeObjectURL(url), 5000);
      }

      function loadImageForShare(url, { timeout = 7000 } = {}) {
        return new Promise((resolve) => {
          const trimmed = String(url ?? '').trim();
          const candidates = buildPhotoCandidateUrls(trimmed);
          if (!candidates.length && trimmed) {
            candidates.push(trimmed);
          }
          if (!candidates.length) {
            resolve(null);
            return;
          }

          const tryNext = () => {
            const candidate = candidates.shift();
            if (!candidate) {
              resolve(null);
              return;
            }

            const image = new Image();
            let settled = false;
            const finalize = (result) => {
              if (settled) return;
              settled = true;
              clearTimeout(timer);
              image.onload = null;
              image.onerror = null;
              if (result) {
                resolve(result);
              } else {
                tryNext();
              }
            };

            const timer = setTimeout(() => finalize(null), timeout);
            image.crossOrigin = 'anonymous';
            image.onload = () => finalize(image);
            image.onerror = () => finalize(null);
            image.src = candidate;
          };

          tryNext();
        });
      }

      async function createShareCanvas(row, { omitPhoto = false } = {}) {
        const width = 1080;
        const height = 1350;
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        if (!ctx) {
          return null;
        }

        if (document.fonts && document.fonts.ready) {
          try {
            await document.fonts.ready;
          } catch (error) {
            console.warn('Share card fonts failed to load', error);
          }
        }

        ctx.textBaseline = 'top';

        const gradient = ctx.createLinearGradient(0, 0, width, height);
        gradient.addColorStop(0, '#e9f7fb');
        gradient.addColorStop(1, '#cbe7f5');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, width, height);

        ctx.save();
        ctx.shadowColor = 'rgba(37, 150, 190, 0.28)';
        ctx.shadowBlur = 60;
        ctx.shadowOffsetY = 40;
        drawRoundedRect(ctx, 60, 60, width - 120, height - 120, 48);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.94)';
        ctx.fill();
        ctx.restore();

        const innerX = 110;
        const innerY = 110;
        const innerWidth = width - innerX * 2;
        let cursorY = innerY;
        const centerX = width / 2;

        const logoImage = await loadImageForShare(SHARE_LOGO_URL, { timeout: 4000 });
        const brandNameFont = '600 54px "Playfair Display", serif';
        const taglineFont = '500 26px "Inter", sans-serif';
        const brandNameLineHeight = 62;
        const taglineLineHeight = 34;
        const brandTextHeight = brandNameLineHeight + taglineLineHeight;
        const brandBlockTop = cursorY;
        let brandBlockHeight = brandTextHeight;
        let logoDrawWidth = 0;
        let logoDrawHeight = 0;

        if (logoImage) {
          const ratio = logoImage.width && logoImage.height ? logoImage.width / logoImage.height : 1;
          const maxLogoWidth = Math.min(innerWidth * 0.3, 240);
          const maxLogoHeight = 140;
          logoDrawWidth = Math.max(1, maxLogoWidth);
          logoDrawHeight = logoDrawWidth / (ratio || 1);
          if (logoDrawHeight > maxLogoHeight) {
            logoDrawHeight = maxLogoHeight;
            logoDrawWidth = logoDrawHeight * (ratio || 1);
          }
          brandBlockHeight = Math.max(brandBlockHeight, logoDrawHeight);
        }

        const brandGap = logoDrawWidth > 0 ? 36 : 0;
        const brandTextX = logoDrawWidth > 0 ? innerX + logoDrawWidth + brandGap : centerX;
        const brandTextY = brandBlockTop + Math.max(0, (brandBlockHeight - brandTextHeight) / 2);

        if (logoDrawWidth > 0 && logoImage) {
          const logoY = brandBlockTop + (brandBlockHeight - logoDrawHeight) / 2;
          ctx.drawImage(logoImage, innerX, logoY, logoDrawWidth, logoDrawHeight);
          ctx.textAlign = 'left';
        } else {
          ctx.textAlign = 'center';
        }

        ctx.fillStyle = '#2C2C2C';
        ctx.font = brandNameFont;
        ctx.fillText('Veridian Atelier', brandTextX, brandTextY);

        ctx.font = taglineFont;
        ctx.fillStyle = '#4f6b78';
        ctx.fillText('Fine jewellery & bespoke designs', brandTextX, brandTextY + brandNameLineHeight);

        cursorY = brandBlockTop + brandBlockHeight + 48;
        ctx.textAlign = 'left';
        ctx.fillStyle = '#2C2C2C';
        cursorY += 12;

        const title = row.__name || (row.__sku ? `SKU ${row.__sku}` : 'Inventory item');
        ctx.font = '600 48px "Playfair Display", serif';
        const titleLines = wrapText(ctx, title, innerWidth);
        for (const line of titleLines) {
          ctx.fillText(line, innerX, cursorY);
          cursorY += 54;
        }

        if (row.__sku) {
          ctx.font = '500 24px "Inter", sans-serif';
          ctx.fillStyle = '#4f6b78';
          ctx.fillText(`SKU ${row.__sku}`, innerX, cursorY);
          cursorY += 40;
          ctx.fillStyle = '#2C2C2C';
        }

        const photoAreaHeight = 420;
        const photoY = cursorY + 12;
        const photoRadius = 36;

        ctx.save();
        drawRoundedRect(ctx, innerX, photoY, innerWidth, photoAreaHeight, photoRadius);
        ctx.fillStyle = '#dff1f8';
        ctx.fill();
        ctx.restore();

        const itemImage = omitPhoto ? null : await loadImageForShare(row.__photoUrl, { timeout: 5000 });
        if (itemImage) {
          ctx.save();
          drawRoundedRect(ctx, innerX, photoY, innerWidth, photoAreaHeight, photoRadius);
          ctx.clip();
          ctx.fillStyle = '#dff1f8';
          ctx.fillRect(innerX, photoY, innerWidth, photoAreaHeight);
          const ratio = itemImage.width && itemImage.height ? itemImage.width / itemImage.height : 1;
          let drawWidth = innerWidth;
          let drawHeight = drawWidth / (ratio || 1);
          if (drawHeight > photoAreaHeight) {
            drawHeight = photoAreaHeight;
            drawWidth = drawHeight * (ratio || 1);
          }
          const dx = innerX + (innerWidth - drawWidth) / 2;
          const dy = photoY + (photoAreaHeight - drawHeight) / 2;
          ctx.drawImage(itemImage, dx, dy, drawWidth, drawHeight);
          ctx.restore();
        } else {
          ctx.save();
          drawRoundedRect(ctx, innerX, photoY, innerWidth, photoAreaHeight, photoRadius);
          ctx.clip();
          ctx.fillStyle = '#dff1f8';
          ctx.fillRect(innerX, photoY, innerWidth, photoAreaHeight);
          ctx.font = '500 28px "Inter", sans-serif';
          ctx.fillStyle = '#2596be';
          ctx.textAlign = 'center';
          ctx.fillText('Photo unavailable', centerX, photoY + photoAreaHeight / 2 - 16);
          ctx.fillText('Contact us for more details', centerX, photoY + photoAreaHeight / 2 + 16);
          ctx.restore();
          ctx.textAlign = 'left';
          ctx.fillStyle = '#2C2C2C';
        }

        cursorY = photoY + photoAreaHeight + 60;

        const details = createShareDetails(row);
        if (details.length) {
          ctx.font = '600 34px "Playfair Display", serif';
          ctx.fillStyle = '#2C2C2C';
          ctx.fillText('Item details', innerX, cursorY);
          cursorY += 46;

          const columnCount = Math.min(2, Math.max(1, details.length));
          const columnGap = columnCount > 1 ? 36 : 0;
          const columnWidth = (innerWidth - columnGap * (columnCount - 1)) / columnCount;
          const labelFont = '600 22px "Inter", sans-serif';
          const valueFont = '600 28px "Playfair Display", serif';
          const labelLineHeight = 26;
          const valueLineHeight = 36;
          const labelValueSpacing = 4;
          const blockSpacing = 18;

          const detailBlocks = details.map((detail) => {
            ctx.font = labelFont;
            const labelLines = wrapText(ctx, detail.label, columnWidth);
            const labelHeight = Math.max(labelLines.length, 1) * labelLineHeight;

            ctx.font = valueFont;
            const valueLines = wrapText(ctx, detail.value, columnWidth);
            const valueHeight = Math.max(valueLines.length, 1) * valueLineHeight;

            return {
              labelLines,
              valueLines,
              labelHeight,
              valueHeight,
              contentHeight: labelHeight + labelValueSpacing + valueHeight
            };
          });

          const rows = Math.ceil(detailBlocks.length / columnCount);
          let rowTop = cursorY;

          for (let rowIndex = 0; rowIndex < rows; rowIndex += 1) {
            let rowHeight = 0;

            for (let columnIndex = 0; columnIndex < columnCount; columnIndex += 1) {
              const detailIndex = rowIndex + columnIndex * rows;
              if (detailIndex >= detailBlocks.length) continue;

              const block = detailBlocks[detailIndex];
              const columnX = innerX + columnIndex * (columnWidth + columnGap);

              ctx.font = labelFont;
              ctx.fillStyle = '#4f6b78';
              block.labelLines.forEach((line, index) => {
                ctx.fillText(line, columnX, rowTop + index * labelLineHeight);
              });

              const valueStart = rowTop + block.labelHeight + labelValueSpacing;
              ctx.font = valueFont;
              ctx.fillStyle = '#2C2C2C';
              block.valueLines.forEach((line, index) => {
                ctx.fillText(line, columnX, valueStart + index * valueLineHeight);
              });

              rowHeight = Math.max(rowHeight, block.contentHeight);
            }

            const nextRowTop = rowTop + rowHeight + (rowIndex < rows - 1 ? blockSpacing : 0);
            rowTop = nextRowTop;
          }

          cursorY = rowTop + 6;
        }

        if (row.__description) {
          ctx.font = '600 34px "Playfair Display", serif';
          ctx.fillStyle = '#2C2C2C';
          ctx.fillText('Description', innerX, cursorY);
          cursorY += 44;
          ctx.font = '400 28px "Inter", sans-serif';
          ctx.fillStyle = '#4f6b78';
          const descriptionLines = wrapText(ctx, row.__description, innerWidth);
          for (const line of descriptionLines) {
            ctx.fillText(line, innerX, cursorY);
            cursorY += 36;
          }
          cursorY += 10;
        }

        return canvas;
      }

      async function handleShare(row, button) {
        if (!row) return;
        let originalLabel = '';
        if (button) {
          originalLabel = button.textContent;
          button.disabled = true;
          button.textContent = 'Preparing…';
        }

        try {
          const shareTitle = row.__name || 'Veridian Atelier item';
          const shareText = createShareSummaryText(row);
          const attempts = [false, true];
          let blob = null;
          let lastError = null;

          for (const omitPhoto of attempts) {
            try {
              const canvas = await createShareCanvas(row, { omitPhoto });
              if (!canvas) {
                throw new Error('Unable to prepare share canvas');
              }
              const exported = await new Promise((resolve, reject) => {
                canvas.toBlob((value) => {
                  if (value) {
                    resolve(value);
                  } else {
                    reject(new Error('Canvas export failed'));
                  }
                }, 'image/png', 0.95);
              });
              blob = exported;
              break;
            } catch (error) {
              lastError = error;
              if (!omitPhoto) {
                console.warn('Share card export failed, retrying without item photo', error);
                continue;
              }
            }
          }

          if (!blob) {
            throw lastError || new Error('Unable to prepare share canvas');
          }

          const filename = createShareFilename(row);
          let file = null;
          if (typeof File === 'function') {
            try {
              file = new File([blob], filename, { type: 'image/png' });
            } catch (error) {
              console.warn('File construction failed for share payload', error);
              file = null;
            }
          }

          if (file && navigator.canShare && navigator.canShare({ files: [file] })) {
            await navigator.share({
              files: [file],
              title: shareTitle,
              text: shareText
            });
          } else if (navigator.share) {
            await navigator.share({
              title: shareTitle,
              text: shareText
            });
            triggerDownload(blob, filename);
          } else {
            triggerDownload(blob, filename);
            window.alert('Share image saved. Send it via WhatsApp, email, or any preferred app.');
          }
        } catch (error) {
          console.error('Share preparation failed:', error);
          window.alert('Unable to prepare the share card right now. Please try again later.');
        } finally {
          if (button) {
            button.disabled = false;
            button.textContent = originalLabel || 'Share card';
          }
        }
      }

      let highlightTimeout = null;
      let lastHighlightedCardId = null;

      let lastFocusedDetailsTrigger = null;
      let lastOpenedDetailsRow = null;

      function normalizeDigits(value = '') {
        return String(value ?? '')
          .replace(/\u0660/g, '0').replace(/\u0661/g, '1').replace(/\u0662/g, '2')
          .replace(/\u0663/g, '3').replace(/\u0664/g, '4').replace(/\u0665/g, '5')
          .replace(/\u0666/g, '6').replace(/\u0667/g, '7').replace(/\u0668/g, '8')
          .replace(/\u0669/g, '9')
          .replace(/\u06F0/g, '0').replace(/\u06F1/g, '1').replace(/\u06F2/g, '2')
          .replace(/\u06F3/g, '3').replace(/\u06F4/g, '4').replace(/\u06F5/g, '5')
          .replace(/\u06F6/g, '6').replace(/\u06F7/g, '7').replace(/\u06F8/g, '8')
          .replace(/\u06F9/g, '9')
          .replace(/\u066B/g, '.').replace(/\u066C/g, ',');
      }


      function debounce(func, wait = 200) {
        let timeoutId;
        return function debounced(...args) {
          clearTimeout(timeoutId);
          timeoutId = setTimeout(() => func.apply(this, args), wait);
        };
      }
      function extractNumber(value) {
        if (typeof value === 'number') {
          return Number.isFinite(value) ? value : NaN;
        }
        const normalized = normalizeDigits(value);
        const match = normalized.match(/-?\d+(?:[.,]\d+)?/);
        if (!match) return NaN;
        const token = match[0];
        const formatted = token.includes(',') && !token.includes('.')
          ? token.replace(',', '.')
          : token.replace(/,/g, '');
        const num = Number.parseFloat(formatted);
        return Number.isFinite(num) ? num : NaN;
      }

      function sanitize(value) {
        const div = document.createElement('div');
        div.textContent = String(value ?? '');
        return div.textContent;
      }


      function createItemUid(row, index) {
        const sku = (row && row.__sku) || (row && row.sku) || '';
        const base = sku ? `sku-${sku}` : 'item';
        return `${base}-${index}`.replace(/[^a-zA-Z0-9_-]+/g, '-').toLowerCase();
      }
      function normalizePhotoUrl(value) {
        const raw = String(value ?? '').trim();
        if (!raw) return '';

        if (raw.startsWith('data:')) {
          return raw;
        }

        let token = raw.split(/\s+/)[0];

        if (raw.startsWith('=')) {
          const quotedUrl = raw.match(/["'](https?:\/\/[^"']+)["']/i);
          if (quotedUrl && quotedUrl[1]) {
            token = quotedUrl[1];
          } else {
            const bareUrl = raw.match(/https?:\/\/[^,\s)]+/i);
            if (bareUrl && bareUrl[0]) {
              token = bareUrl[0];
            }
          }
        } else {
          const inlineUrl = raw.match(/https?:\/\/[^\s"']+/i);
          if (inlineUrl && inlineUrl[0]) {
            token = inlineUrl[0];
          }
        }

        if (!/^https?:/i.test(token)) {
          if (/^drive\.google\.com/i.test(token)) {
            token = `https://${token}`;
          }
        }

        let url;
        try {
          url = new URL(token);
        } catch (error) {
          try {
            url = new URL(token, window.location.origin);
          } catch (nestedError) {
            return '';
          }
        }

        if (!['http:', 'https:'].includes(url.protocol)) {
          return '';
        }

        if (url.hostname.includes('drive.google.com')) {
          const match = url.pathname.match(/\/file\/d\/([^/]+)/);
          const id = match ? match[1] : url.searchParams.get('id');
          const resourceKey = url.searchParams.get('resourcekey');

          if (id) {
            const params = new URLSearchParams({ export: 'view', id });
            if (resourceKey) {
              params.set('resourcekey', resourceKey);
            }
            return `https://drive.google.com/uc?${params.toString()}`;
          }

          if (url.pathname.startsWith('/uc')) {
            const params = new URLSearchParams(url.search);
            if (resourceKey && !params.get('resourcekey')) {
              params.set('resourcekey', resourceKey);
              return `https://drive.google.com${url.pathname}?${params.toString()}`;
            }
          }
        }

        return url.href;
      }

      function loadImageWithTimeout(imgElement, src, timeout = 5000) {
        return new Promise((resolve, reject) => {
          let settled = false;

          const cleanup = () => {
            imgElement.onload = null;
            imgElement.onerror = null;
          };

          const timer = setTimeout(() => {
            if (settled) return;
            settled = true;
            cleanup();
            reject(new Error('Image load timeout'));
          }, timeout);

          imgElement.onload = () => {
            if (settled) return;
            settled = true;
            clearTimeout(timer);
            cleanup();
            resolve();
          };

          imgElement.onerror = () => {
            if (settled) return;
            settled = true;
            clearTimeout(timer);
            cleanup();
            reject(new Error('Image load failed'));
          };

          imgElement.src = src;
        });
      }

      function getDriveId(url = '') {
        const s = String(url).trim();
        if (!s) return null;

        const patterns = [
          /[?&]id=([A-Za-z0-9_-]+)/,
          /\/file\/d\/([A-Za-z0-9_-]+)/,
          /\/uc\?export=(?:download|view)&id=([A-Za-z0-9_-]+)/,
          /\/d\/([A-Za-z0-9_-]+)/,
          /\/view\?usp=sharing&id=([A-Za-z0-9_-]+)/,
          /drive\.google\.com\/file\/d\/([A-Za-z0-9_-]+)/
        ];

        for (const pattern of patterns) {
          const match = s.match(pattern);
          if (match && match[1]) {
            return match[1];
          }
        }

        if (/\.(jpg|jpeg|png|gif|webp)(\?.*)?$/i.test(s)) {
          return null;
        }

        return null;
      }

      function buildPhotoCandidateUrls(rawUrl) {
        const trimmed = String(rawUrl ?? '').trim();
        if (!trimmed) return [];

        const candidates = [];
        const seen = new Set();

        const pushCandidate = (candidate) => {
          const normalized = String(candidate ?? '').trim();
          if (!normalized || seen.has(normalized)) return;
          seen.add(normalized);
          candidates.push(normalized);
        };

        pushCandidate(trimmed);

        const driveId = getDriveId(trimmed);
        if (driveId) {
          let resourceKey = '';
          try {
            const parsed = new URL(trimmed);
            resourceKey = parsed.searchParams.get('resourcekey') || '';
          } catch (error) {
            resourceKey = '';
          }

          const suffix = resourceKey ? `&resourcekey=${encodeURIComponent(resourceKey)}` : '';

          pushCandidate(`https://drive.google.com/uc?export=view&id=${driveId}${suffix}`);
          pushCandidate(`https://drive.google.com/thumbnail?id=${driveId}&sz=s1600${suffix}`);
          pushCandidate(`https://lh3.googleusercontent.com/d/${driveId}=s1600`);
        }

        return candidates;
      }

      function normalizeRowKeys(row) {
        const out = {};
        let laborFeeRaw;
        let profitFeeRaw;

        for (const key of Object.keys(row || {})) {
          const value = row[key];
          const lower = key.trim().toLowerCase();

          out[key] = value;
          out[lower] = value;

          if (lower.includes('sku')) out.sku = value;
          if (lower.includes('timestamp')) out.timestamp = value;
          if (lower.includes('type')) out.type = value;
          if (lower.includes('status') || lower.includes('حالة')) out.availability = value;
          if (lower.includes('piece type') || lower.includes('نوع القطعة')) out.name = value;
          if (lower.includes('weight') || lower.includes('وزن')) out.weight = value;
          if (lower.includes('karat') || lower.includes('carat') || lower.includes('عيار')) out.karat = value;
          if (lower.includes('making fee') || lower.includes('أجور')) out.fees = value;
          if (lower.includes('اجور بالغرام')) laborFeeRaw = value;
          if (lower.includes('ربح لكل غرام')) profitFeeRaw = value;
          if (lower.includes('description') || lower.includes('وصف')) out.description = value;
          if (lower.includes('photo') || lower.includes('video') || lower.includes('image')) out.photo = value;
          if (lower.includes('أسم البائع')) out.soldby = value;
          if (lower.includes('تاريخ المبيع')) out.solddate = value;
          if (
            lower.includes('مبلغ البيع') ||
            lower.includes('sold price') ||
            lower.includes('sell price') ||
            lower.includes('sale price') ||
            lower.includes('sold amount') ||
            lower.includes('sale amount')
          ) {
            out.soldprice = value;
          }
          if (lower.includes('ملاحظات')) out.notes = value;
        }

        const hasLaborFee = typeof laborFeeRaw !== 'undefined' && String(laborFeeRaw ?? '').trim() !== '';
        const hasProfitFee = typeof profitFeeRaw !== 'undefined' && String(profitFeeRaw ?? '').trim() !== '';

        if (hasLaborFee || hasProfitFee) {
          const parseFeeComponent = (raw) => {
            const normalized = String(raw ?? '').trim();
            if (!normalized) return 0;
            const numeric = Number(normalized.replace(/[^0-9.,-]/g, '').replace(',', '.'));
            return Number.isFinite(numeric) ? numeric : 0;
          };

          const laborFee = parseFeeComponent(laborFeeRaw);
          const profitFee = parseFeeComponent(profitFeeRaw);
          const totalFees = laborFee + profitFee;

          if (Number.isFinite(totalFees)) {
            const formattedTotal = totalFees
              .toFixed(4)
              .replace(/\.0+$/, '')
              .replace(/(\.\d*?)0+$/, '$1');
            out.fees = formattedTotal;
          }
        }

        return out;
      }

      function normalizeCategoryValue(value = '') {
        return String(value ?? '').trim().toLowerCase();
      }

      function normalizeAvailabilityState(value = '') {
        const normalized = String(value ?? '').trim().toLowerCase();
        if (!normalized) {
          return 'unknown';
        }

        const negativePatterns = /not\s*available|unavailable|sold|reserved|out\s*of\s*stock|out-of-stock|on hold|on\s*hold|hold|pending|coming soon|preorder|pre-order/;
        if (negativePatterns.test(normalized)) {
          return 'not-available';
        }

        const positivePatterns = /available|in stock|instock|ready/;
        if (positivePatterns.test(normalized)) {
          return 'available';
        }

        return 'unknown';
      }

      function detectCategoryKey(rows = []) {
        if (!rows.length) return null;
        const keys = new Set();
        for (const row of rows) {
          for (const key of Object.keys(row)) {
            if (!key) continue;
            keys.add(key.trim().toLowerCase());
          }
        }
        const candidates = [
          'category',
          'type',
          'collection',
          'group',
          'line',
          'segment',
          'الصنف',
          'الفئة',
          'نوع',
          'name',
          'piece type | نوع القطعة'
        ];
        for (const candidate of candidates) {
          if (keys.has(candidate)) {
            return candidate;
          }
        }
        return null;
      }

      function computeItemPrice(weightStr, karatStr, feesStr, basePrice) {
        const weight = extractNumber(weightStr);
        const fees = extractNumber(feesStr) || 0;
        const karat = parseInt(String(karatStr ?? '').replace(/[^\d]/g, ''), 10) || 0;
        if (!Number.isFinite(basePrice) || !basePrice || !weight || !karat) {
          return null;
        }
        let purity;
        if (karat === 18) purity = 750 / 995;
        else if (karat === 21) purity = 875 / 995;
        else purity = karat / 24;
        const perGram = ((basePrice + PREMIUM) * OUNCE_GRAMS * purity) / 1000 + fees;
        const total = perGram * weight;
        if (!Number.isFinite(total)) return null;
        return { total, perGram, weight, karat };
      }

      function findExistingPrice(row) {
        for (const key of Object.keys(row)) {
          if (!key) continue;
          const lower = key.trim().toLowerCase();
          if (
            !lower ||
            lower.includes('sold') ||
            lower.includes('sale') ||
            lower.includes('cost')
          ) {
            continue;
          }
          if (lower.includes('price') || lower.includes('amount') || lower.includes('value')) {
            const numeric = extractNumber(row[key]);
            if (Number.isFinite(numeric)) {
              return { numeric, display: row[key] };
            }
          }
        }
        return null;
      }

      function formatPrice(value, fallbackText = t('priceNotAvailable')) {
        if (Number.isFinite(value)) {
          return formatCurrency(value);
        }
        return fallbackText;
      }

      function populateCategoryOptions(rows) {
        if (!categorySelect) return;
        const previousValue = categorySelect.value;
        const options = new Map();
        for (const row of rows) {
          const raw = row.__categoryRaw;
          const normalized = row.__categoryNormalized;
          if (!normalized) continue;
          if (!options.has(normalized)) {
            options.set(normalized, raw || '');
          }
        }
        const locale = getLocale();
        const entries = Array.from(options.entries()).sort((a, b) => {
          const labelA = a[1] || '';
          const labelB = b[1] || '';
          return labelA.localeCompare(labelB, locale || undefined, { sensitivity: 'base' });
        });

        categorySelect.innerHTML = '';
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = t('filterCategoryAll');
        categorySelect.appendChild(defaultOption);

        for (const [value, label] of entries) {
          const option = document.createElement('option');
          option.value = value;
          option.textContent = label;
          categorySelect.appendChild(option);
        }

        if (previousValue && options.has(previousValue)) {
          categorySelect.value = previousValue;
        } else {
          categorySelect.value = '';
        }
      }

      function updateStatus() {
        if (!state.dataLoaded) {
          refreshStatusText();
          refreshResultsCount();
          updateSearchResultsList();
          return;
        }

        uiState.total = state.rows.length;
        uiState.visible = state.filtered.length;
        uiState.statusMode = state.rows.length ? 'ready' : 'no-data';
        refreshStatusText();
        refreshResultsCount();
        updateSearchResultsList();
      }

      function focusCardById(targetId) {
        if (!targetId) return;
        const card = document.getElementById(targetId);
        if (!card) return;

        if (lastHighlightedCardId && lastHighlightedCardId !== targetId) {
          const previous = document.getElementById(lastHighlightedCardId);
          if (previous) {
            previous.classList.remove('item-card--highlight');
          }
        }

        card.classList.add('item-card--highlight');
        lastHighlightedCardId = targetId;

        card.scrollIntoView({ behavior: 'smooth', block: 'center' });
        if (typeof card.focus === 'function') {
          card.focus({ preventScroll: true });
        }

        if (highlightTimeout) {
          clearTimeout(highlightTimeout);
        }

        highlightTimeout = setTimeout(() => {
          card.classList.remove('item-card--highlight');
          if (lastHighlightedCardId === targetId) {
            lastHighlightedCardId = null;
          }
        }, 1800);
      }

      function updateSearchResultsList() {
        if (!searchResultsEl) return;

        const rawQuery = searchInput ? searchInput.value : state.searchQuery || '';
        const trimmed = rawQuery.trim();
        searchResultsEl.innerHTML = '';

        if (!trimmed) {
          searchResultsEl.hidden = true;
          return;
        }

        if (!state.searchActive) {
          const hint = document.createElement('p');
          hint.className = 'search-empty';
          hint.textContent = t('searchHint');
          searchResultsEl.appendChild(hint);
          searchResultsEl.hidden = false;
          return;
        }

        if (!state.dataLoaded) {
          const loading = document.createElement('p');
          loading.className = 'search-empty';
          loading.textContent = t('searchLoading');
          searchResultsEl.appendChild(loading);
          searchResultsEl.hidden = false;
          return;
        }

        const totalMatches = state.searchMatchCount ?? state.filtered.length;
        const visibleMatches = state.filtered.length;

        if (!totalMatches) {
          const empty = document.createElement('p');
          empty.className = 'search-empty';
          empty.textContent = t('searchNoMatches');
          searchResultsEl.appendChild(empty);
          searchResultsEl.hidden = false;
          return;
        }

        if (!visibleMatches) {
          const hiddenMessage = document.createElement('p');
          hiddenMessage.className = 'search-empty';
          hiddenMessage.textContent = t('searchHiddenMatches');
          searchResultsEl.appendChild(hiddenMessage);
          searchResultsEl.hidden = false;
          return;
        }

        const summary = document.createElement('p');
        summary.className = 'search-results__summary';
        if (state.searchMatchCount !== null && state.searchMatchCount !== visibleMatches) {
          summary.textContent = t('searchSummaryFiltered', {
            visible: formatNumber(visibleMatches),
            total: formatNumber(state.searchMatchCount)
          });
        } else if (visibleMatches === 1) {
          summary.textContent = t('searchSummarySingular');
        } else {
          summary.textContent = t('searchSummary', { count: formatNumber(visibleMatches) });
        }
        searchResultsEl.appendChild(summary);

        const limit = 8;
        const matches = state.filtered.slice(0, limit);

        const createMetaText = (row) => {
          const parts = [];
          if (row.__sku) parts.push(t('skuLabel', { value: row.__sku }));
          if (row.__categoryRaw) parts.push(row.__categoryRaw);
          if (row.__availabilityRaw) parts.push(row.__availabilityRaw);
          let priceText = '';
          if (Number.isFinite(row.__price)) {
            priceText = formatPrice(row.__price);
          } else if (row.__priceFallback) {
            priceText = row.__priceFallback;
          }
          if (priceText) parts.push(priceText);
          if (row.__description) {
            const snippet = row.__description.length > 90
              ? `${row.__description.slice(0, 87)}…`
              : row.__description;
            parts.push(snippet);
          }
          return parts.filter(Boolean).join(' • ');
        };

        for (const row of matches) {
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'search-result';
          if (row.__uid) {
            button.dataset.targetId = row.__uid;
          }

          const title = document.createElement('span');
          title.className = 'search-result-title';
          title.textContent = row.__name || t('itemDefaultName');
          button.appendChild(title);

          const metaText = createMetaText(row);
          if (metaText) {
            const meta = document.createElement('span');
            meta.className = 'search-result-meta';
            meta.textContent = metaText;
            button.appendChild(meta);
          }

          button.addEventListener('click', () => {
            if (row.__uid) {
              focusCardById(row.__uid);
            }
          });

          searchResultsEl.appendChild(button);
        }

        const remainder = totalMatches - matches.length;
        if (remainder > 0) {
          const more = document.createElement('p');
          more.className = 'search-result-meta';
          more.textContent = t(remainder === 1 ? 'searchMoreMatchesSingular' : 'searchMoreMatches', {
            count: formatNumber(remainder)
          });
          searchResultsEl.appendChild(more);
        }

        searchResultsEl.hidden = false;
      }

      function applyFilters() {
        if (!state.dataLoaded) {
          updateSearchResultsList();
          return;
        }
        const category = categorySelect.value;
        const availability = availabilitySelect.value;
        const priceMin = extractNumber(priceMinInput.value);
        const priceMax = extractNumber(priceMaxInput.value);

        let working = state.rows;

        if (state.searchActive) {
          const query = state.searchQueryNormalized;
          working = working.filter((row) => row.__searchHaystack && row.__searchHaystack.includes(query));
          state.searchMatchCount = working.length;
        } else {
          state.searchMatchCount = null;
        }

        state.filtered = working.filter((row) => {
          if (category && row.__categoryNormalized !== category) {
            return false;
          }

          if (availability === 'available' && row.__availabilityState !== 'available') {
            return false;
          }

          if (availability === 'not-available' && row.__availabilityState !== 'not-available') {
            return false;
          }

          if (Number.isFinite(priceMin)) {
            if (!Number.isFinite(row.__price) || row.__price < priceMin) {
              return false;
            }
          }

          if (Number.isFinite(priceMax)) {
            if (!Number.isFinite(row.__price) || row.__price > priceMax) {
              return false;
            }
          }

          return true;
        });

        sortFiltered();
        renderItems();
        updateStatus();
      }

      function fallbackComparison(a, b) {
        const nameComparison = (a.__name || '').localeCompare(b.__name || '', undefined, {
          sensitivity: 'base'
        });
        if (nameComparison !== 0) {
          return nameComparison;
        }
        return (a.__index ?? 0) - (b.__index ?? 0);
      }

      function compareByNumeric(a, b, extractor, direction = 'asc') {
        const valueA = extractor(a);
        const valueB = extractor(b);
        const hasA = Number.isFinite(valueA);
        const hasB = Number.isFinite(valueB);

        if (hasA && hasB) {
          if (valueA !== valueB) {
            return direction === 'desc' ? valueB - valueA : valueA - valueB;
          }
        } else if (hasA !== hasB) {
          return hasA ? -1 : 1;
        }

        return fallbackComparison(a, b);
      }

      function compareBySku(a, b) {
        const skuA = a.__sku || '';
        const skuB = b.__sku || '';
        const hasA = Boolean(skuA);
        const hasB = Boolean(skuB);

        if (hasA && hasB) {
          const comparison = skuA.localeCompare(skuB, undefined, {
            numeric: true,
            sensitivity: 'base'
          });
          if (comparison !== 0) {
            return comparison;
          }
        } else if (hasA !== hasB) {
          return hasA ? -1 : 1;
        }

        return fallbackComparison(a, b);
      }

      const SORT_COMPARATORS = {
        'price-asc': (a, b) => compareByNumeric(a, b, (row) => row.__price, 'asc'),
        'price-desc': (a, b) => compareByNumeric(a, b, (row) => row.__price, 'desc'),
        'weight-asc': (a, b) => compareByNumeric(a, b, (row) => row.__weight, 'asc'),
        'weight-desc': (a, b) => compareByNumeric(a, b, (row) => row.__weight, 'desc'),
        sku: compareBySku
      };

      function sortFiltered() {
        const comparator = SORT_COMPARATORS[state.sortBy] || SORT_COMPARATORS['price-asc'];
        state.filtered.sort(comparator);
      }

      function clampSortIndex(rawIndex) {
        const parsed = Number.parseInt(rawIndex, 10);
        if (!Number.isFinite(parsed)) {
          return RESOLVED_DEFAULT_SORT_INDEX;
        }
        return Math.min(Math.max(parsed, 0), SORT_OPTIONS.length - 1);
      }

      function updateSortDisplay(index) {
        const option = SORT_OPTIONS[index] ?? SORT_OPTIONS[RESOLVED_DEFAULT_SORT_INDEX] ?? SORT_OPTIONS[0];
        const labelText = t(option.labelKey);
        const shortLabelText = option.shortKey ? t(option.shortKey) : labelText;
        if (sortSelection) {
          sortSelection.textContent = t('sortCurrent', { label: labelText });
        }
        if (sortGroup) {
          sortGroup.setAttribute('data-active-index', String(index));
        }
        sortButtons.forEach((button) => {
          const buttonIndex = Number.parseInt(button.getAttribute('data-sort-index'), 10);
          const isActive = buttonIndex === index;
          button.classList.toggle('is-active', isActive);
          button.setAttribute('aria-checked', isActive ? 'true' : 'false');
          button.tabIndex = isActive ? 0 : -1;
          if (isActive && sortGroup) {
            const buttonId = button.id || '';
            sortGroup.setAttribute('aria-activedescendant', buttonId);
            sortGroup.setAttribute('data-active-label', shortLabelText);
          }
        });
      }

      function setSortByIndex(index, { trigger = true } = {}) {
        const resolvedIndex = clampSortIndex(index);
        const option = SORT_OPTIONS[resolvedIndex] ?? SORT_OPTIONS[RESOLVED_DEFAULT_SORT_INDEX] ?? SORT_OPTIONS[0];
        state.sortBy = option.value;
        state.sortIndex = resolvedIndex;
        updateSortDisplay(resolvedIndex);
        if (trigger) {
          sortFiltered();
          renderItems();
          updateStatus();
        }
      }

      function createMetaRow(label, value) {
        const wrapper = document.createElement('div');
        wrapper.className = 'item-card__meta-entry';

        const labelSpan = document.createElement('span');
        labelSpan.className = 'item-card__meta-label';
        labelSpan.textContent = label;

        const valueSpan = document.createElement('span');
        valueSpan.className = 'item-card__meta-value';
        valueSpan.textContent = value;

        wrapper.appendChild(labelSpan);
        wrapper.appendChild(valueSpan);
        return wrapper;
      }

      function createItemCard(row, viewMode = state.viewMode, options = {}) {
        const { interactive = viewMode === 'compact', role = 'listitem' } = options;
        const card = document.createElement('article');
        card.className = `item-card item-card--${viewMode}`;
        card.setAttribute('role', role);
        if (row.__uid && role === 'listitem') {
          card.id = row.__uid;
        }
        card.tabIndex = -1;
        if (interactive) {
          card.dataset.interactive = 'true';
          card.tabIndex = 0;
          card.setAttribute('aria-haspopup', 'dialog');
          card.setAttribute('aria-expanded', 'false');
        }

        const media = document.createElement('div');
        media.className = 'item-card__media';

        const showPlaceholder = () => {
          media.innerHTML = '';
          const placeholder = document.createElement('div');
          placeholder.className = 'item-card__photo item-card__photo--placeholder';
          placeholder.textContent = t('photoUnavailable');
          media.appendChild(placeholder);
        };

        if (row.__photoUrl) {
          const altText = row.__name ? t('photoAltNamed', { name: row.__name }) : t('photoAltItem');
          const image = document.createElement('img');
          image.className = 'item-card__photo';
          image.loading = 'lazy';
          image.decoding = 'async';
          image.crossOrigin = 'anonymous';
          image.alt = altText;
          media.appendChild(image);

          const candidateUrls = buildPhotoCandidateUrls(row.__photoUrl);
          if (!candidateUrls.length) {
            image.src = row.__photoUrl;
          } else {
            const urls = [...candidateUrls];
            const tryNext = () => {
              const nextUrl = urls.shift();
              if (!nextUrl) {
                showPlaceholder();
                return;
              }

              loadImageWithTimeout(image, nextUrl, 5000)
                .catch(() => {
                  if (urls.length) {
                    setTimeout(tryNext, 100);
                  } else {
                    showPlaceholder();
                  }
                });
            };

            tryNext();
          }
        } else {
          showPlaceholder();
        }
        card.appendChild(media);

        const body = document.createElement('div');
        body.className = 'item-card__body';

        const header = document.createElement('div');
        header.className = 'item-card__header';

        const titleBlock = document.createElement('div');
        titleBlock.className = 'item-card__title';

        if (row.__sku) {
          const skuChip = document.createElement('span');
          skuChip.className = 'item-card__sku';
          skuChip.textContent = t('skuLabel', { value: row.__sku });
          titleBlock.appendChild(skuChip);
        }

        const title = document.createElement('h3');
        title.className = 'item-card__name';
        title.textContent = row.__name || t('itemDefaultName');
        titleBlock.appendChild(title);

        header.appendChild(titleBlock);

        const priceBlock = document.createElement('div');
        priceBlock.className = 'item-card__price';
        const priceLabel = document.createElement('span');
        if (row.__priceSource === 'sheet') {
          priceLabel.textContent = t('priceSheet');
        } else if (row.__priceSource === 'estimated') {
          priceLabel.textContent = t('priceEstimated');
        } else {
          priceLabel.textContent = t('priceNotAvailable');
        }
        const priceValue = document.createElement('strong');
        priceValue.textContent = formatPrice(row.__price, row.__priceFallback || t('priceNotAvailable'));
        priceBlock.appendChild(priceLabel);
        priceBlock.appendChild(priceValue);
        header.appendChild(priceBlock);

        body.appendChild(header);

        const metaList = document.createElement('div');
        metaList.className = 'item-card__meta';

        const primaryMeta = document.createElement('div');
        primaryMeta.className = 'item-card__meta-row';
        const weightDisplay = Number.isFinite(row.__weight)
          ? formatWeightDisplay(row.__weight)
          : '';
        const weightValue = weightDisplay || row.__weightRaw;
        if (weightValue) {
          primaryMeta.appendChild(createMetaRow(t('metaWeight'), weightValue));
        }
        if (row.__karat) {
          primaryMeta.appendChild(createMetaRow(t('metaKarat'), row.__karat));
        }
        if (row.__categoryRaw) {
          primaryMeta.appendChild(createMetaRow(t('metaCategory'), row.__categoryRaw));
        }
        metaList.appendChild(primaryMeta);

        if (viewMode === 'detailed') {
          const secondaryMeta = document.createElement('div');
          secondaryMeta.className = 'item-card__meta-row';
          if (row.__fees) {
            secondaryMeta.appendChild(createMetaRow(t('metaFees'), row.__fees));
          }
          const availabilityText = row.__availabilityState === 'available'
            ? t('filterAvailabilityAvailable')
            : row.__availabilityState === 'not-available'
              ? t('filterAvailabilityNotAvailable')
              : row.__availabilityRaw;
          if (availabilityText) {
            secondaryMeta.appendChild(createMetaRow(t('metaStatus'), availabilityText));
          }
          const perGramDisplay = Number.isFinite(row.__perGram)
            ? formatPerGram(row.__perGram)
            : '';
          if (perGramDisplay) {
            secondaryMeta.appendChild(createMetaRow(t('metaPerGram'), perGramDisplay));
          }
          if (secondaryMeta.childElementCount) {
            metaList.appendChild(secondaryMeta);
          }
        }

        body.appendChild(metaList);

        if (viewMode === 'detailed' && row.__description) {
          const description = document.createElement('p');
          description.className = 'item-card__description';
          description.textContent = row.__description;
          body.appendChild(description);
        }

        if (row.__badges.length) {
          const badgeRow = document.createElement('div');
          badgeRow.className = 'item-card__badge-row';
          for (const badge of row.__badges) {
            const span = document.createElement('span');
            span.className = 'chip';
            if (badge.type === 'availability') {
              span.textContent = badge.state === 'available'
                ? t('filterAvailabilityAvailable')
                : t('filterAvailabilityNotAvailable');
            } else if (badge.type === 'timestamp') {
              span.textContent = t('badgeUpdated', { value: badge.value });
            } else if (badge.value) {
              span.textContent = badge.value;
            }
            badgeRow.appendChild(span);
          }
          body.appendChild(badgeRow);
        }

        const actionsRow = document.createElement('div');
        actionsRow.className = 'item-card__actions';
        const shareButton = document.createElement('button');
        shareButton.type = 'button';
        shareButton.className = 'share-button';
        shareButton.textContent = 'Share card';
        shareButton.addEventListener('click', () => {
          handleShare(row, shareButton);
        });
        actionsRow.appendChild(shareButton);
        body.appendChild(actionsRow);

        card.appendChild(body);

        if (interactive) {
          const handleClick = () => {
            openItemDetails(row, card);
          };

          const handleKeydown = (event) => {
            const key = event.key;
            if (key !== 'Enter' && key !== ' ') {
              return;
            }
            event.preventDefault();
            openItemDetails(row, card);
          };

          card.addEventListener('click', handleClick);
          card.addEventListener('keydown', handleKeydown);
        }

        return card;
      }

      function isItemDetailsOpen() {
        return Boolean(itemDetailsDialog && itemDetailsDialog.classList.contains('is-visible'));
      }

      function openItemDetails(row, triggerElement) {
        if (!itemDetailsDialog || !itemDetailsContainer) return;

        lastFocusedDetailsTrigger = triggerElement instanceof HTMLElement ? triggerElement : null;
        if (lastFocusedDetailsTrigger) {
          lastFocusedDetailsTrigger.setAttribute('aria-expanded', 'true');
        }

        lastOpenedDetailsRow = row;

        itemDetailsContainer.innerHTML = '';
        const detailCard = createItemCard(row, 'detailed', { interactive: false, role: 'article' });
        itemDetailsContainer.appendChild(detailCard);

        itemDetailsDialog.classList.add('is-visible');
        itemDetailsDialog.setAttribute('aria-hidden', 'false');
        document.body.classList.add('dialog-open');

        if (itemDetailsClose) {
          itemDetailsClose.focus();
        }
      }

      function closeItemDetails() {
        if (!itemDetailsDialog || !itemDetailsContainer) return;

        itemDetailsDialog.classList.remove('is-visible');
        itemDetailsDialog.setAttribute('aria-hidden', 'true');
        document.body.classList.remove('dialog-open');
        itemDetailsContainer.innerHTML = '';

        if (lastFocusedDetailsTrigger && document.body.contains(lastFocusedDetailsTrigger)) {
          lastFocusedDetailsTrigger.setAttribute('aria-expanded', 'false');
          lastFocusedDetailsTrigger.focus();
        }

        lastFocusedDetailsTrigger = null;
        lastOpenedDetailsRow = null;
      }

      if (itemDetailsDialog) {
        itemDetailsDialog.addEventListener('click', (event) => {
          if (event.target === itemDetailsDialog) {
            closeItemDetails();
          }
        });
      }

      if (itemDetailsClose) {
        itemDetailsClose.addEventListener('click', () => {
          closeItemDetails();
        });
      }

      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && isItemDetailsOpen()) {
          event.preventDefault();
          closeItemDetails();
        }
      });

      function renderItems() {
        if (!itemsGrid) return;
        itemsGrid.dataset.view = state.viewMode;

        if (!state.dataLoaded) {
          return;
        }

        if (highlightTimeout) {
          clearTimeout(highlightTimeout);
          highlightTimeout = null;
        }
        lastHighlightedCardId = null;

        itemsGrid.innerHTML = '';

        if (!state.filtered.length) {
          const empty = document.createElement('p');
          empty.className = 'empty-state';
          if (state.rows.length) {
            empty.dataset.emptyType = 'filters';
            empty.textContent = t('emptyFilters');
            uiState.emptyType = 'filters';
          } else {
            empty.dataset.emptyType = 'no-data';
            empty.textContent = t('emptyNoRows');
            uiState.emptyType = 'no-data';
          }
          itemsGrid.appendChild(empty);
          return;
        }

        uiState.emptyType = 'none';
        for (const row of state.filtered) {
          itemsGrid.appendChild(createItemCard(row));
        }
      }

      function parseRow(row) {
        const normalized = normalizeRowKeys(row);
        const priceInfo = computeItemPrice(normalized.weight, normalized.karat, normalized.fees, getActiveGoldPrice());
        let priceValue = priceInfo?.total ?? NaN;
        let perGramValue = priceInfo?.perGram ?? NaN;
        let priceSource = 'estimated';
        let priceFallbackDisplay = '';
        const weightValue = extractNumber(normalized.weight);
        const weightRaw = normalized.weight ? sanitize(normalized.weight) : '';

        if (!Number.isFinite(priceValue)) {
          const fallback = findExistingPrice(normalized);
          if (fallback) {
            priceValue = fallback.numeric;
            priceFallbackDisplay = sanitize(fallback.display);
            priceSource = 'sheet';
          } else {
            priceSource = 'unknown';
          }
        }

        if (!Number.isFinite(perGramValue) && Number.isFinite(priceValue) && Number.isFinite(weightValue)) {
          if (weightValue) {
            perGramValue = priceValue / weightValue;
          }
        }

        const categoryKey = state.categoryKey;
        const categoryRaw = categoryKey ? normalized[categoryKey] : (normalized.category ?? normalized.type ?? '');
        const categoryNormalized = normalizeCategoryValue(categoryRaw);
        const availabilityDisplay = sanitize(normalized.availability ?? '');
        const availabilityState = normalizeAvailabilityState(availabilityDisplay);
        const timestamp = normalized.timestamp ? sanitize(normalized.timestamp) : '';

        const badges = [];
        if (availabilityState === 'available' || availabilityState === 'not-available') {
          badges.push({ type: 'availability', state: availabilityState });
        } else if (availabilityDisplay) {
          badges.push({ type: 'text', value: availabilityDisplay });
        }
        if (timestamp) {
          badges.push({ type: 'timestamp', value: timestamp });
        }

        const parsed = {
          ...normalized,
          __name: sanitize(normalized.name ?? normalized['piece type | نوع القطعة'] ?? ''),
          __sku: sanitize(normalized.sku ?? ''),
          __weight: Number.isFinite(weightValue) ? weightValue : NaN,
          __weightRaw: weightRaw,
          __karat: sanitize(normalized.karat ?? ''),
          __fees: sanitize(normalized.fees ?? ''),
          __description: sanitize(normalized.description ?? ''),
          __availabilityRaw: availabilityDisplay,
          __availabilityState: availabilityState,
          __categoryRaw: sanitize(categoryRaw ?? ''),
          __categoryNormalized: categoryNormalized,
          __price: Number.isFinite(priceValue) ? priceValue : NaN,
          __priceSource: priceSource,
          __priceFallback: priceFallbackDisplay,
          __perGram: Number.isFinite(perGramValue) ? perGramValue : NaN,
          __photoUrl: normalizePhotoUrl(normalized.photo),
          __badges: badges,
          __timestamp: timestamp
        };

        const searchTokens = [
          parsed.__sku,
          parsed.__name,
          parsed.__description,
          parsed.__categoryRaw,
          parsed.__availabilityRaw,
          parsed.__fees,
          parsed.__karat,
          Number.isFinite(parsed.__price) ? parsed.__price.toString() : '',
          parsed.__priceFallback,
          parsed.__timestamp,
          parsed.__weightRaw
        ]
          .filter(Boolean)
          .join(' ');
        parsed.__searchHaystack = normalizeDigits(searchTokens).toLowerCase();

        return parsed;
      }

      function enrichRows(rows) {
        state.rawRows = Array.isArray(rows) ? rows.slice() : [];
        const sourceRows = Array.isArray(rows) ? rows : [];
        state.rows = sourceRows.map((row, index) => {
          const parsed = parseRow(row);
          parsed.__index = index;
          parsed.__uid = createItemUid(parsed, index);
          return parsed;
        });
        populateCategoryOptions(state.rows);
        state.dataLoaded = true;
        applyFilters();
      }

      async function fetchInventory() {
        const response = await fetch(INVENTORY_ENDPOINT, { credentials: 'include' });
        if (!response.ok) {
          throw new Error(`Inventory request failed (${response.status})`);
        }
        return response.json();
      }

      async function fetchGoldPrice() {
        try {
          const response = await fetch(GOLD_API, { cache: 'no-store' });
          if (!response.ok) {
            throw new Error(`Gold price request failed (${response.status})`);
          }
          const data = await response.json();
          const price = Number(data.price);
          if (Number.isFinite(price)) {
            state.goldPrice = price;
            state.goldUpdatedAt = data.updatedAtReadable || data.updatedAt || '';
          } else {
            state.goldPrice = null;
            state.goldUpdatedAt = '';
          }
        } catch (error) {
          console.warn('Gold price fetch failed:', error);
          state.goldPrice = null;
          state.goldUpdatedAt = '';
        } finally {
          refreshGoldStatus();
          if (!isManualGoldActive()) {
            refreshGoldDerivedFields();
          }
        }
      }

      function setSearchQuery(rawValue, { trigger = true } = {}) {
        const value = typeof rawValue === 'string' ? rawValue : '';
        const normalizedDigits = normalizeDigits(value);
        const trimmed = normalizedDigits.trim();
        state.searchQuery = value;
        state.searchQueryNormalized = trimmed.toLowerCase();
        state.searchActive = state.searchQueryNormalized.length >= 2;
        state.searchMatchCount = null;
        if (trigger) {
          applyFilters();
          if (!state.dataLoaded) {
            updateSearchResultsList();
          }
        }
      }

      function resetFilters() {
        categorySelect.value = '';
        availabilitySelect.value = '';
        priceMinInput.value = '';
        priceMaxInput.value = '';
        if (searchInput) {
          searchInput.value = '';
        }
        setSearchQuery('', { trigger: false });
        setSortByIndex(RESOLVED_DEFAULT_SORT_INDEX, { trigger: false });
        applyFilters();
      }

      function attachListeners() {
        if (languageToggle) {
          languageToggle.addEventListener('change', (event) => {
            applyLanguage(event.target.value);
          });
        }
        if (searchInput) {
          const debouncedSearch = debounce((value) => {
            setSearchQuery(value);
          }, 250);

          searchInput.addEventListener('input', (event) => {
            debouncedSearch(event.target.value);
          });

          searchInput.addEventListener('search', (event) => {
            setSearchQuery(event.target.value);
          });

          searchInput.addEventListener('focus', () => {
            if (state.searchActive) {
              updateSearchResultsList();
            }
          });
        }
        if (goldPriceInput) {
          goldPriceInput.addEventListener('input', () => {
            goldPriceInput.setCustomValidity('');
          });
        }
        if (goldPriceForm) {
          goldPriceForm.addEventListener('submit', (event) => {
            event.preventDefault();
            if (!goldPriceInput) return;
            const rawValue = String(goldPriceInput.value ?? '').trim();
            const value = extractNumber(rawValue);
            if (!Number.isFinite(value) || value <= 0) {
              goldPriceInput.setCustomValidity(t('goldInvalid'));
              if (typeof goldPriceInput.reportValidity === 'function') {
                goldPriceInput.reportValidity();
              }
              goldPriceInput.focus();
              return;
            }
            goldPriceInput.setCustomValidity('');
            if (setManualGoldPrice(value)) {
              goldPriceInput.value = '';
            }
          });
        }
        if (goldPriceClear) {
          goldPriceClear.addEventListener('click', () => {
            clearManualGoldPrice();
            if (goldPriceInput) {
              goldPriceInput.setCustomValidity('');
              goldPriceInput.value = '';
              goldPriceInput.focus();
            }
          });
        }
        if (goldSuggestionButtons.length) {
          goldSuggestionButtons.forEach((button) => {
            button.addEventListener('click', () => {
              const delta = Number(button.dataset.goldSuggestion || '0');
              if (!Number.isFinite(delta) || delta <= 0) return;
              const base = getSuggestionBasePrice();
              if (!Number.isFinite(base) || base <= 0) return;
              const newValue = base + delta;
              if (setManualGoldPrice(newValue) && goldPriceInput) {
                goldPriceInput.value = '';
                goldPriceInput.setCustomValidity('');
              }
            });
          });
        }
        categorySelect.addEventListener('change', applyFilters);
        availabilitySelect.addEventListener('change', applyFilters);
        priceMinInput.addEventListener('input', applyFilters);
        priceMaxInput.addEventListener('input', applyFilters);
        resetFiltersBtn.addEventListener('click', resetFilters);
        if (sortButtons.length) {
          const findButtonByIndex = (targetIndex) =>
            sortButtons.find((button) => Number.parseInt(button.getAttribute('data-sort-index'), 10) === targetIndex);

          sortButtons.forEach((button) => {
            button.addEventListener('click', () => {
              setSortByIndex(button.getAttribute('data-sort-index'));
            });

            button.addEventListener('keydown', (event) => {
              const key = event.key;
              const currentIndex = clampSortIndex(button.getAttribute('data-sort-index'));
              let nextIndex = null;

              if (key === 'ArrowRight' || key === 'ArrowDown') {
                nextIndex = (currentIndex + 1) % SORT_OPTIONS.length;
              } else if (key === 'ArrowLeft' || key === 'ArrowUp') {
                nextIndex = (currentIndex - 1 + SORT_OPTIONS.length) % SORT_OPTIONS.length;
              } else if (key === 'Home') {
                nextIndex = 0;
              } else if (key === 'End') {
                nextIndex = SORT_OPTIONS.length - 1;
              }

              if (nextIndex !== null) {
                event.preventDefault();
                setSortByIndex(nextIndex);
                const targetButton = findButtonByIndex(nextIndex);
                if (targetButton) {
                  window.requestAnimationFrame(() => {
                    targetButton.focus();
                  });
                }
              }
            });
          });
        }
      }

      async function initialize() {
        attachListeners();
        if (searchInput && searchInput.value.trim()) {
          setSearchQuery(searchInput.value, { trigger: false });
        }
        updateSearchResultsList();
        if (sortButtons.length) {
          const activeButton = sortButtons.find((button) => button.classList.contains('is-active'));
          const startingIndex = activeButton?.getAttribute('data-sort-index') ?? RESOLVED_DEFAULT_SORT_INDEX;
          setSortByIndex(startingIndex, { trigger: false });
        } else {
          setSortByIndex(RESOLVED_DEFAULT_SORT_INDEX, { trigger: false });
        }
        uiState.statusMode = 'loading';
        uiState.total = 0;
        uiState.visible = 0;
        refreshStatusText();
        refreshGoldStatus();

        try {
          const [inventoryData] = await Promise.all([fetchInventory(), fetchGoldPrice()]);
          const rows = Array.isArray(inventoryData) ? inventoryData : [];
          state.categoryKey = detectCategoryKey(rows);
          enrichRows(rows);
          refreshGoldStatus();
        } catch (error) {
          console.error('Inventory load failed:', error);
          state.rows = [];
          state.filtered = [];
          state.dataLoaded = false;
          uiState.statusMode = 'error';
          uiState.total = 0;
          uiState.visible = 0;
          refreshStatusText();
          refreshResultsCount();
          updateSearchResultsList();
          if (itemsGrid) {
            itemsGrid.innerHTML = '';
            const empty = document.createElement('p');
            empty.className = 'empty-state';
            empty.dataset.emptyType = 'error';
            empty.textContent = t('errorEmpty');
            itemsGrid.appendChild(empty);
            uiState.emptyType = 'error';
            refreshEmptyMessage();
          }
          refreshGoldStatus();
          return;
        }

        updateStatus();
      }

      refreshLanguageDependentText();
      initialize();
    })();
  </script>
</body>
</html>
