<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Veridian Atelier • Inventory Explorer</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Amiri&family=Inter:wght@400;500;600&family=Playfair+Display:wght@500;600;700&display=swap" rel="stylesheet">
  <link rel="icon" type="image/jpeg" href="../assets/logo-website-test.jpg">
  <link rel="apple-touch-icon" href="../assets/logo-website-test.jpg">
  <link rel="manifest" href="../manifest.webmanifest">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#2596be">
  <meta
    http-equiv="Content-Security-Policy"
    content="default-src 'self'; script-src 'self' 'unsafe-inline' https://unpkg.com; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; img-src 'self' https: data:; connect-src 'self' https://api.gold-api.com; child-src 'self' https://drive.google.com https://*.googleusercontent.com; frame-src 'self' https://drive.google.com https://*.googleusercontent.com; object-src 'none'; base-uri 'self'; frame-ancestors 'self'"
  >
  <script>
    window.__redirectToLogin = function redirectToLogin() {
      window.location.replace('../index.html');
    };

    window.handleUnauthorized = async function handleUnauthorized() {
      try {
        await fetch('../api/logout', { method: 'POST', credentials: 'include' });
      } catch (error) {
        console.warn('Failed to notify logout.', error);
      }
      window.__redirectToLogin();
    };

    (async () => {
      try {
        const response = await fetch('../api/session', { credentials: 'include' });
        if (!response.ok) {
          throw new Error('Session invalid');
        }
        const data = await response.json();
        if (!data?.authenticated) {
          throw new Error('Unauthenticated');
        }
      } catch (error) {
        window.__redirectToLogin();
      }
    })();
  </script>
  <style>
    :root {
      --pad: 18px;
      --gold-primary: #2596be;
      --gold-secondary: #2596be;
      --gold-dark: #1f7fa0;
      --gold-light: #e6f6fb;
      --ivory: #fafdff;
      --charcoal: #1f2a30;
      --warm-gray: #4f6b78;
      --accent-gold: #2596be;
      --bg: radial-gradient(circle at 10% 0%, rgba(37, 150, 190, 0.18) 0%, rgba(37, 150, 190, 0.08) 55%, #ffffff 100%);
      --glass: rgba(255, 255, 255, 0.94);
      --card-border: rgba(37, 150, 190, 0.26);
      --accent: var(--gold-primary);
      --accent-dark: var(--gold-dark);
      --text: var(--charcoal);
      --muted: var(--warm-gray);
      --shadow: 0 18px 40px -24px rgba(37, 150, 190, 0.35);
    }

    html {
      scroll-behavior: smooth;
    }

    * {
      box-sizing: border-box;
    }

    body {
      min-height: 100vh;
      margin: 0;
      font-family: 'Inter', system-ui, -apple-system, Segoe UI, sans-serif;
      color: var(--text);
      background: var(--bg);
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: calc(var(--pad) * 1.2) var(--pad) calc(var(--pad) * 1.6);
    }


    .page {
      width: min(1100px, 100%);
      display: flex;
      flex-direction: column;
      gap: clamp(18px, 3vw, 28px);
    }

    header {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .header-top {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }
    .language-toggle {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.82);
      border: 1px solid rgba(37, 150, 190, 0.2);
      box-shadow: inset 0 0 0 1px rgba(37, 150, 190, 0.12);
    }
    .language-toggle select {
      border: none;
      background: transparent;
      font-family: inherit;
      font-size: 0.95rem;
      font-weight: 600;
      color: var(--accent-dark);
      cursor: pointer;
      outline: none;
      appearance: none;
      padding: 0;
    }
    .language-toggle select option {
      color: var(--text);
    }
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .brand-logo {
      height: 56px;
      width: auto;
      object-fit: contain;
      filter: drop-shadow(0 6px 16px rgba(37, 150, 190, 0.25));
    }

    .page-nav {
      position: relative;
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 999px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.92), rgba(229, 246, 251, 0.78));
      border: 1px solid rgba(37, 150, 190, 0.25);
      box-shadow: 0 18px 32px -22px rgba(37, 150, 190, 0.45);
      max-width: 100%;
      overflow-x: auto;
      overflow-y: hidden;
      scroll-snap-type: x proximity;
      -webkit-overflow-scrolling: touch;
      scrollbar-width: none;
      backdrop-filter: blur(12px);
    }

    .page-nav::-webkit-scrollbar { display: none; }

    .nav-link {
      flex: 0 0 auto;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 10px 18px;
      border-radius: 999px;
      font-weight: 600;
      font-size: 0.95rem;
      color: var(--accent-dark);
      text-decoration: none;
      transition: transform 0.2s ease, background 0.2s ease, box-shadow 0.2s ease, color 0.2s ease;
      background: rgba(255, 255, 255, 0.82);
      scroll-snap-align: center;
      min-width: max-content;
      box-shadow: inset 0 0 0 1px rgba(37, 150, 190, 0.12);
    }

    .nav-link:hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 24px -18px rgba(37, 150, 190, 0.45);
    }

    .nav-link:focus-visible {
      outline: 2px solid rgba(37, 150, 190, 0.55);
      outline-offset: 2px;
    }

    .nav-link:active {
      transform: scale(0.98);
    }

    .nav-link.active {
      background: linear-gradient(135deg, var(--gold-primary), var(--gold-dark));
      color: #fff;
      box-shadow: 0 14px 30px -18px rgba(37, 150, 190, 0.6);
    }

    .hero-title {
      margin: 0;
      font-family: 'Playfair Display', 'Times New Roman', serif;
      font-size: clamp(1.6rem, 3.8vw, 2.4rem);
      letter-spacing: 0.02em;
      color: var(--text);
    }

    .hero-subtitle {
      margin: 0;
      font-size: clamp(0.95rem, 2vw, 1.05rem);
      color: var(--muted);
      max-width: 620px;
    }

    .glass-card {
      background: var(--glass);
      border: 1px solid var(--card-border);
      border-radius: 28px;
      padding: clamp(20px, 4vw, 32px);
      box-shadow: var(--shadow);
      backdrop-filter: blur(14px);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }

    .glass-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 25px 50px -12px rgba(37, 150, 190, 0.4);
    }

    .filter-card {
      display: grid;
      gap: 18px;
    }

    .filter-grid {
      display: grid;
      gap: 16px;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }

    .filter-group {
      display: grid;
      gap: 8px;
    }

    .sort-options {
      display: grid;
      gap: 12px;
      margin: 0;
      padding: 0;
      border: none;
    }

    .sort-options legend {
      font-size: 0.95rem;
      font-weight: 600;
      font-family: 'Playfair Display', serif;
      color: var(--accent-dark);
    }

    .sort-chips {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    }

    .sort-chip {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 4px;
      padding: 14px 16px;
      border-radius: 20px;
      border: 1px solid rgba(37, 150, 190, 0.22);
      background: linear-gradient(140deg, rgba(255, 255, 255, 0.92) 0%, rgba(230, 246, 251, 0.9) 100%);
      color: var(--muted);
      font-weight: 500;
      letter-spacing: 0.01em;
      transition: transform 0.25s ease, box-shadow 0.25s ease, border-color 0.25s ease, background 0.25s ease;
      cursor: pointer;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.45);
    }

    .sort-chip::after {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: radial-gradient(circle at 0% 0%, rgba(37, 150, 190, 0.18), transparent 60%);
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }

    .sort-chip:hover {
      transform: translateY(-2px);
      border-color: rgba(37, 150, 190, 0.38);
      box-shadow: 0 18px 32px -24px rgba(37, 150, 190, 0.55);
    }

    .sort-chip:hover::after {
      opacity: 1;
    }

    .sort-chip:focus-visible {
      outline: 3px solid rgba(37, 150, 190, 0.38);
      outline-offset: 3px;
    }

    .sort-chip__title {
      font-size: 0.95rem;
      font-weight: 600;
      color: var(--text);
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .sort-chip__badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: rgba(37, 150, 190, 0.18);
      color: var(--accent-dark);
      font-size: 0.75rem;
      font-weight: 600;
    }

    .sort-chip__subtitle {
      font-size: 0.75rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .sort-chip.is-active {
      background: linear-gradient(135deg, var(--accent), var(--accent-dark));
      border-color: rgba(37, 150, 190, 0.6);
      box-shadow: 0 22px 40px -20px rgba(37, 150, 190, 0.75);
      color: #fff;
    }

    .sort-chip.is-active::after {
      opacity: 0.5;
      background: radial-gradient(circle at 100% 0%, rgba(255, 255, 255, 0.35), transparent 65%);
    }

    .sort-chip.is-active .sort-chip__title,
    .sort-chip.is-active .sort-chip__subtitle {
      color: #fff;
    }

    .sort-chip.is-active .sort-chip__badge {
      background: rgba(255, 255, 255, 0.2);
      color: #fff;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.35);
    }

    .sort-options__current {
      margin: 0;
      font-size: 0.88rem;
      color: var(--muted);
    }

    label {
      font-weight: 600;
      font-size: 0.95rem;
      font-family: 'Playfair Display', serif;
    }

    select,
    button,
    input {
      font-family: inherit;
      border-radius: 14px;
      border: 1px solid rgba(37, 150, 190, 0.25);
      padding: 12px 14px;
      font-size: 0.98rem;
      background: rgba(255, 255, 255, 0.92);
      box-shadow: inset 0 1px 1px rgba(255, 255, 255, 0.4);
      transition: transform 120ms ease, box-shadow 200ms ease, border-color 160ms ease;
    }

    select:focus,
    button:focus,
    input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(37, 150, 190, 0.25);
    }

    button:focus-visible,
    input:focus-visible,
    select:focus-visible {
      outline: 2px solid var(--gold-primary);
      outline-offset: 2px;
    }

    button {
      background: linear-gradient(135deg, var(--gold-primary), var(--gold-dark));
      color: #fff;
      border: none;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 14px 32px -18px rgba(37, 150, 190, 0.45);
    }

    button:disabled {
      cursor: not-allowed;
      opacity: 0.65;
      background: rgba(37, 150, 190, 0.35);
      box-shadow: none;
    }

    button:not(:disabled):hover {
      transform: translateY(-1px);
    }

    .range-inputs {
      display: grid;
      grid-template-columns: minmax(0, 1fr) auto minmax(0, 1fr);
      align-items: center;
      gap: 8px;
    }

    .range-inputs input {
      width: 100%;
      min-width: 0;
    }

    .range-inputs span {
      font-weight: 600;
      color: var(--muted);
      font-size: 0.9rem;
      text-align: center;
    }

    .view-toggle {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      padding: 6px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.72);
      border: 1px solid rgba(37, 150, 190, 0.25);
      box-shadow: 0 12px 24px -18px rgba(37, 150, 190, 0.35);
      width: fit-content;
    }

    .toggle-pill {
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 999px;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 600;
    }

    .toggle-pill input {
      position: absolute;
      inset: 0;
      opacity: 0;
      cursor: pointer;
    }

    .toggle-pill__surface {
      position: absolute;
      inset: 0;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.82);
      transition: all 0.2s ease;
      box-shadow: inset 0 1px 1px rgba(255, 255, 255, 0.4);
    }

    .toggle-pill__label {
      position: relative;
      z-index: 1;
      padding: 8px 18px;
      color: var(--accent-dark);
      white-space: nowrap;
    }

    .toggle-pill input:checked ~ .toggle-pill__surface {
      background: linear-gradient(135deg, var(--gold-primary), var(--gold-dark));
      box-shadow: 0 14px 30px -20px rgba(37, 150, 190, 0.55);
    }

    .toggle-pill input:checked ~ .toggle-pill__label {
      color: #fff;
    }

    .status-row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .status-row strong {
      color: var(--accent-dark);
    }

    .results-card {
      display: grid;
      gap: 18px;
    }

    .results-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .results-count {
      font-weight: 600;
      color: var(--accent-dark);
      font-family: 'Playfair Display', serif;
    }

    .items-grid {
      display: grid;
      gap: clamp(16px, 2.5vw, 22px);
    }

    .items-grid[data-view="detailed"] {
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
    }

    .items-grid[data-view="compact"] {
      grid-template-columns: repeat(3, minmax(0, 1fr));
    }

    .item-card {
      display: grid;
      gap: 16px;
      padding: 18px;
      border-radius: 22px;
      border: 1px solid rgba(37, 150, 190, 0.25);
      background: rgba(255, 255, 255, 0.9);
      box-shadow: 0 18px 40px -24px rgba(37, 150, 190, 0.35);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .item-card--highlight {
      box-shadow: 0 0 0 3px rgba(37, 150, 190, 0.35), 0 25px 48px -20px rgba(37, 150, 190, 0.45);
      transform: translateY(-1px);
    }

    .item-card--compact {
      grid-template-rows: auto 1fr;
      padding: 14px;
    }

    .item-card--detailed {
      grid-template-columns: minmax(0, 240px) 1fr;
      align-items: stretch;
    }

    .item-card:hover {
      transform: translateY(-1px);
      box-shadow: 0 25px 48px -20px rgba(37, 150, 190, 0.45);
    }

    .item-card[data-interactive="true"] {
      cursor: pointer;
    }

    .item-card:focus-visible {
      outline: 3px solid rgba(37, 150, 190, 0.45);
      outline-offset: 4px;
    }

    .item-card__media {
      position: relative;
      border-radius: 18px;
      overflow: hidden;
      background: rgba(37, 150, 190, 0.08);
      box-shadow: inset 0 0 0 1px rgba(37, 150, 190, 0.12);
    }

    .item-card--compact .item-card__media {
      aspect-ratio: 1;
    }

    .item-card--detailed .item-card__media {
      min-height: 240px;
      aspect-ratio: 3 / 4;
    }

    .item-card__photo {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .item-card__photo--placeholder {
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--muted);
      font-weight: 600;
      background: rgba(255, 255, 255, 0.6);
      padding: 16px;
      text-align: center;
    }

    .item-card__body {
      display: grid;
      gap: 16px;
    }

    .item-card--compact .item-card__body {
      gap: 12px;
      justify-items: center;
      text-align: center;
    }

    .item-card__header {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
    }

    .item-card--compact .item-card__header {
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100%;
      gap: 6px;
    }

    .item-card--compact .item-card__title {
      text-align: center;
    }

    .item-card__title {
      display: grid;
      gap: 4px;
    }

    .item-card__name {
      margin: 0;
      font-family: 'Playfair Display', serif;
      font-size: 1.1rem;
    }

    .item-card--compact .item-card__name {
      font-size: 1rem;
    }

    .item-card__sku {
      display: inline-flex;
      align-items: center;
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(37, 150, 190, 0.12);
      color: var(--accent-dark);
      font-weight: 600;
      font-size: 0.85rem;
    }

    .item-card--compact .item-card__sku {
      justify-content: center;
      width: 100%;
    }

    .item-card__price {
      display: grid;
      gap: 4px;
      text-align: right;
    }

    .item-card--compact .item-card__price {
      text-align: center;
      width: 100%;
    }

    .item-card__price span {
      color: var(--muted);
      font-size: 0.85rem;
    }

    .item-card--compact .item-card__price span {
      font-size: 0.8rem;
    }

    .item-card__price strong {
      font-family: 'Playfair Display', serif;
      font-size: 1.2rem;
      color: var(--accent-dark);
    }

    .item-card--compact .item-card__price strong {
      font-size: 1.35rem;
    }

    .item-card__meta {
      display: grid;
      gap: 12px;
      font-size: 0.95rem;
      width: 100%;
    }

    .item-card__meta-row {
      display: grid;
      gap: 8px;
    }

    .item-card__meta-entry {
      display: grid;
      grid-template-columns: max-content minmax(0, 1fr);
      gap: 8px;
      align-items: baseline;
      width: 100%;
    }

    .item-card__meta-label {
      color: var(--muted);
      font-weight: 600;
    }

    .item-card__meta-label::after {
      content: ':';
      margin-left: 4px;
      color: rgba(139, 125, 107, 0.7);
    }

    .item-card__meta-value {
      justify-self: start;
      color: var(--accent-dark);
      font-weight: 600;
      text-align: start;
      word-break: break-word;
    }

    .item-card--compact .item-card__meta {
      justify-items: center;
      text-align: start;
    }

    .item-card--compact .item-card__meta-entry {
      margin: 0 auto;
      max-width: 260px;
    }

    .item-card--compact .item-card__meta-value {
      justify-self: start;
    }

    .item-card__description {
      margin: 0;
      color: var(--muted);
      line-height: 1.5;
    }

    .item-card--compact .item-card__description {
      display: none;
    }

    .item-card--compact .item-card__meta-row:not(:first-child) {
      display: none;
    }

    .item-card__badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      font-size: 0.85rem;
    }

    .item-card--compact .item-card__badge-row {
      justify-content: center;
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      border-radius: 999px;
      background: rgba(229, 246, 251, 0.85);
      border: 1px solid rgba(37, 150, 190, 0.25);
      color: var(--accent-dark);
      font-weight: 600;
    }

    .search-container {
      display: grid;
      gap: 10px;
      width: 100%;
    }

    .search-container input {
      width: 100%;
      border-radius: 16px;
      padding: 14px 18px;
      font-size: 1rem;
      background: rgba(255, 255, 255, 0.9);
      border: 1.5px solid rgba(31, 127, 160, 0.16);
      transition: all 0.3s ease;
    }

    .search-container input:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(37, 150, 190, 0.18);
      background: rgba(255, 255, 255, 0.95);
    }

    .search-container label {
      font-weight: 600;
      font-size: 0.9rem;
      color: var(--muted);
    }

    .search-results {
      border: 1px solid var(--card-border);
      border-radius: 18px;
      background: rgba(255, 255, 255, 0.86);
      box-shadow: var(--shadow);
      padding: 12px;
      display: grid;
      gap: 10px;
    }

    .search-results[hidden] {
      display: none;
    }

    .search-results button.search-result {
      display: flex;
      flex-direction: column;
      text-align: start;
      gap: 6px;
      padding: 12px;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid rgba(37, 150, 190, 0.24);
      border-radius: 16px;
      color: var(--text);
      font-weight: 500;
      transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
    }

    .search-results button.search-result:hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 28px -16px rgba(37, 150, 190, 0.35);
      border-color: rgba(37, 150, 190, 0.45);
    }

    .search-results button.search-result:focus-visible {
      outline: 3px solid rgba(37, 150, 190, 0.45);
      outline-offset: 2px;
    }

    .search-result-title {
      font-size: 0.95rem;
      font-weight: 600;
      color: var(--text);
      line-height: 1.3;
    }

    .search-result-meta {
      font-size: 0.8rem;
      color: var(--muted);
      line-height: 1.4;
    }

    .search-empty {
      margin: 0;
      text-align: center;
      padding: 26px 18px;
      color: var(--warm-gray);
      font-style: italic;
      background: rgba(37, 150, 190, 0.08);
      border-radius: 16px;
      border: 2px dashed rgba(37, 150, 190, 0.2);
    }

    .search-results__summary {
      margin: 0;
      font-size: 0.85rem;
      color: var(--muted);
    }

    .empty-state {
      margin: 0;
      padding: 16px;
      border-radius: 16px;
      background: rgba(255, 255, 255, 0.86);
      border: 1px dashed rgba(37, 150, 190, 0.35);
      color: var(--muted);
      text-align: center;
      font-size: 0.98rem;
    }

    .item-details-dialog {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: clamp(20px, 6vw, 40px);
      background: rgba(15, 42, 52, 0.45);
      backdrop-filter: blur(6px);
      z-index: 1000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s ease;
    }

    .item-details-dialog.is-visible {
      opacity: 1;
      pointer-events: auto;
    }

    .item-details-dialog__surface {
      position: relative;
      width: min(540px, 100%);
      max-height: min(90vh, 720px);
      overflow: hidden auto;
      border-radius: 30px;
      border: 1px solid rgba(37, 150, 190, 0.3);
      border-inline-end: 2px solid rgba(37, 150, 190, 0.48);
      background:
        radial-gradient(circle at 100% 18%, rgba(37, 150, 190, 0.16), transparent 55%),
        linear-gradient(140deg, rgba(255, 255, 255, 0.97) 0%, rgba(229, 246, 251, 0.93) 100%);
      box-shadow:
        0 40px 70px -35px rgba(37, 150, 190, 0.6),
        20px 0 36px -28px rgba(37, 150, 190, 0.5),
        inset 0 0 0 1px rgba(255, 255, 255, 0.45);
      padding: clamp(20px, 4vw, 32px);
      display: grid;
      gap: clamp(18px, 3vw, 26px);
    }

    .item-details-dialog__surface::after {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: inherit;
      pointer-events: none;
      border-inline-end: 1px solid rgba(19, 94, 120, 0.55);
      box-shadow: inset -12px 0 22px -20px rgba(37, 150, 190, 0.45);
      mix-blend-mode: multiply;
      opacity: 0.8;
    }

    .item-details-dialog__close {
      position: absolute;
      top: 16px;
      inset-inline-end: 16px;
      border: none;
      background: rgba(255, 255, 255, 0.92);
      border-radius: 999px;
      padding: 8px 16px;
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--accent-dark);
      cursor: pointer;
      box-shadow: 0 14px 32px -20px rgba(37, 150, 190, 0.45);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .item-details-dialog__close:hover {
      transform: translateY(-1px);
      box-shadow: 0 20px 36px -24px rgba(37, 150, 190, 0.5);
    }

    .item-details-dialog__close:focus-visible {
      outline: 2px solid rgba(37, 150, 190, 0.6);
      outline-offset: 3px;
    }

    .item-details-dialog__body {
      display: grid;
    }

    .item-details-dialog__body .item-card {
      box-shadow: none;
      border: 1px solid rgba(37, 150, 190, 0.28);
      background: rgba(255, 255, 255, 0.98);
    }

    .item-details-dialog__body .item-card__media {
      display: flex;
      align-items: center;
      justify-content: center;
      aspect-ratio: auto;
      max-height: min(65vh, 460px);
      padding: 10px;
      background: rgba(37, 150, 190, 0.04);
    }

    .item-details-dialog__body .item-card__photo {
      width: 100%;
      height: auto;
      max-height: 100%;
      object-fit: contain;
    }

    .item-details-dialog__body .item-card:hover {
      transform: none;
      box-shadow: none;
    }

    body.dialog-open {
      overflow: hidden;
    }
    body.rtl {
      direction: rtl;
      font-family: 'Amiri', 'Inter', system-ui, -apple-system, Segoe UI, sans-serif;
    }
    body.rtl header {
      text-align: right;
      align-items: flex-end;
    }
    body.rtl .header-top {
      justify-content: flex-start;
    }
    body.rtl .page-nav {
      direction: rtl;
      justify-content: flex-end;
    }
    body.rtl .filter-grid,
    body.rtl .sort-options,
    body.rtl .view-toggle,
    body.rtl .status-row,
    body.rtl .items-grid,
    body.rtl .item-card__meta-row {
      direction: rtl;
    }
    body.rtl .filter-group,
    body.rtl .sort-options,
    body.rtl .view-toggle,
    body.rtl .status-row,
    body.rtl .results-header {
      text-align: right;
    }
    body.rtl .sort-chip__title,
    body.rtl .toggle-pill__label,
    body.rtl .item-card__price,
    body.rtl .item-card__badge-row,
    body.rtl .item-card__description {
      text-align: right;
    }
    body.rtl .item-card__header {
      flex-direction: row-reverse;
    }
    body.rtl .item-card__price {
      align-items: flex-start;
    }
    body.rtl .item-card__meta-entry {
      justify-content: space-between;
    }
    body.rtl .item-card__sku {
      justify-content: center;
    }

    @media (max-width: 1100px) {
      .items-grid[data-view="compact"] {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    @media (max-width: 900px) {
      .item-card--detailed {
        grid-template-columns: 1fr;
      }

      .item-card--detailed .item-card__media {
        aspect-ratio: 4 / 3;
      }
    }

    @media (max-width: 720px) {
      body { padding-top: 60px; }
      header { text-align: center; align-items: center; }
      .header-top {
        width: 100%;
        display: grid;
        justify-items: center;
      }
      .page-nav {
        width: 100%;
        justify-content: flex-start;
      }
      .brand-logo { height: 46px; }
      .status-row { justify-content: center; }
      .items-grid[data-view="compact"] { grid-template-columns: repeat(2, minmax(0, 1fr)); }
      .item-card--compact .item-card__header { align-items: center; }
      .item-card--compact .item-card__price { text-align: center; }
    }

    @media (max-width: 360px) {
      .items-grid[data-view="compact"] {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="page" id="inventoryPage">
    <header>
      <div class="header-top">
        <img src="../assets/logo-website-test.jpg" alt="Veridian Atelier logo" class="brand-logo" />
        <nav class="page-nav" aria-label="Workspace navigation">
          <a class="nav-link" href="./index.html" data-i18n="navScanner">Scanner</a>
          <a class="nav-link active" href="./items.html" aria-current="page" data-i18n="navInventory">Inventory</a>
          <a class="nav-link" href="./sales.html" data-i18n="navSales">Sales log</a>
          <a class="nav-link" href="./purchases.html" data-i18n="navPurchases">Purchase log</a>
          <a class="nav-link" href="./statement.html" data-i18n="navStatement">Gold statement</a>
        </nav>
        <div class="language-toggle">
          <label for="languageToggle" class="sr-only" data-i18n="languageLabel">Language</label>
          <select id="languageToggle" aria-label="Select language">
            <option value="en">English</option>
            <option value="ar">العربية</option>
          </select>
        </div>
      </div>
      <h1 class="hero-title" data-i18n="heroTitle">Inventory explorer</h1>
      <p class="hero-subtitle" data-i18n="heroSubtitle">Browse the current collection, refine by category and target price, and pick the layout that suits the conversation.</p>
      <div class="search-container">
        <label class="sr-only" for="inventorySearch" data-i18n="searchLabel">Search inventory</label>
        <input
          type="search"
          id="inventorySearch"
          name="inventory-search"
          placeholder="Search items by SKU, category, or description…"
          autocomplete="off"
          spellcheck="false"
        />
        <div id="inventorySearchResults" class="search-results" hidden aria-live="polite"></div>
      </div>
    </header>

    <section class="glass-card filter-card" id="filtersSection" aria-label="Inventory filters">
      <div class="filter-grid">
        <div class="filter-group">
          <label for="categoryFilter" data-i18n="filterCategoryLabel">Category</label>
          <select id="categoryFilter" name="category">
            <option value="" data-i18n="filterCategoryAll">All categories</option>
          </select>
        </div>
        <div class="filter-group">
          <label for="availabilityFilter" data-i18n="filterAvailabilityLabel">Availability</label>
          <select id="availabilityFilter" name="availability">
            <option value="" data-i18n="filterAvailabilityAll">All items</option>
            <option value="available" data-i18n="filterAvailabilityAvailable">Available</option>
            <option value="not-available" data-i18n="filterAvailabilityNotAvailable">Not available</option>
          </select>
        </div>
        <div class="filter-group">
          <label for="priceMin" data-i18n="filterPriceLabel">Price range</label>
          <div class="range-inputs">
            <input type="number" id="priceMin" placeholder="Min" min="0" step="0.01" inputmode="decimal">
            <span data-i18n="filterPriceTo">to</span>
            <input type="number" id="priceMax" placeholder="Max" min="0" step="0.01" inputmode="decimal">
          </div>
        </div>
      </div>
      <fieldset class="sort-options">
        <legend data-i18n="sortLegend">Sort by</legend>
        <div
          class="sort-chips"
          data-sort-group
          role="radiogroup"
          aria-label="Sort inventory by"
          aria-describedby="sortSelection"
        >
          <button
            type="button"
            class="sort-chip"
            data-sort-button
            data-sort-index="0"
            id="sortOptionSku"
            role="radio"
            aria-checked="false"
            tabindex="-1"
          >
            <span class="sort-chip__title">
              <span class="sort-chip__badge" aria-hidden="true">#</span>
              <span class="sort-chip__label" data-sort-label></span>
            </span>
            <span class="sort-chip__subtitle" data-sort-subtitle></span>
          </button>
          <button
            type="button"
            class="sort-chip is-active"
            data-sort-button
            data-sort-index="1"
            id="sortOptionPriceAsc"
            role="radio"
            aria-checked="true"
            tabindex="0"
          >
            <span class="sort-chip__title">
              <span class="sort-chip__badge" aria-hidden="true">↑</span>
              <span class="sort-chip__label" data-sort-label></span>
            </span>
            <span class="sort-chip__subtitle" data-sort-subtitle></span>
          </button>
          <button
            type="button"
            class="sort-chip"
            data-sort-button
            data-sort-index="2"
            id="sortOptionPriceDesc"
            role="radio"
            aria-checked="false"
            tabindex="-1"
          >
            <span class="sort-chip__title">
              <span class="sort-chip__badge" aria-hidden="true">↓</span>
              <span class="sort-chip__label" data-sort-label></span>
            </span>
            <span class="sort-chip__subtitle" data-sort-subtitle></span>
          </button>
          <button
            type="button"
            class="sort-chip"
            data-sort-button
            data-sort-index="3"
            id="sortOptionWeightAsc"
            role="radio"
            aria-checked="false"
            tabindex="-1"
          >
            <span class="sort-chip__title">
              <span class="sort-chip__badge" aria-hidden="true">⇧</span>
              <span class="sort-chip__label" data-sort-label></span>
            </span>
            <span class="sort-chip__subtitle" data-sort-subtitle></span>
          </button>
          <button
            type="button"
            class="sort-chip"
            data-sort-button
            data-sort-index="4"
            id="sortOptionWeightDesc"
            role="radio"
            aria-checked="false"
            tabindex="-1"
          >
            <span class="sort-chip__title">
              <span class="sort-chip__badge" aria-hidden="true">⇩</span>
              <span class="sort-chip__label" data-sort-label></span>
            </span>
            <span class="sort-chip__subtitle" data-sort-subtitle></span>
          </button>
        </div>
        <p class="sort-options__current" id="sortSelection" aria-live="polite" data-i18n-dynamic>Sorting by Price (Low to High)</p>
      </fieldset>
      <div class="status-row">
        <div id="itemsStatus" aria-live="polite" data-i18n="statusLoading" data-i18n-dynamic>Loading inventory…</div>
        <div id="goldStatus" aria-live="polite"></div>
      </div>
      <div>
        <button type="button" id="resetFilters" data-i18n="resetFilters">Reset filters</button>
      </div>
    </section>

    <section class="glass-card results-card" id="resultsSection" aria-label="Inventory results">
      <div class="results-header">
        <h2 data-i18n="resultsHeading">Items</h2>
        <span class="results-count" id="resultsCount" data-i18n-dynamic>0 items</span>
      </div>
      <div class="items-grid" id="itemsGrid" role="list" data-view="compact"></div>
    </section>
  </div>

  <div
    class="item-details-dialog"
    id="itemDetailsDialog"
    role="dialog"
    aria-modal="true"
    aria-hidden="true"
    aria-labelledby="itemDetailsHeading"
  >
    <div class="item-details-dialog__surface" role="document">
      <h2 class="sr-only" id="itemDetailsHeading" data-i18n="detailsHeading">Item details</h2>
      <button type="button" class="item-details-dialog__close" id="itemDetailsClose" data-i18n="detailsClose">
        Close details
      </button>
      <div class="item-details-dialog__body" id="itemDetailsContainer"></div>
    </div>
  </div>

  <script>
    (function () {
      'use strict';

      const DEFAULT_CONFIG = {
        inventoryEndpoint: '/api/inventory',
        authEndpoint: '/api/auth',
        salesEndpoint: '/api/sales',
        goldPriceUrl: 'https://api.gold-api.com/price/XAU'
      };

      const APP_CONFIG = Object.freeze({
        ...DEFAULT_CONFIG,
        ...(window.APP_CONFIG && typeof window.APP_CONFIG === 'object' ? window.APP_CONFIG : {})
      });

      const INVENTORY_ENDPOINT = APP_CONFIG.inventoryEndpoint;
      const GOLD_API = APP_CONFIG.goldPriceUrl;
      const PREMIUM = 30;
      const OUNCE_GRAMS = 32;

      const categorySelect = document.getElementById('categoryFilter');
      const availabilitySelect = document.getElementById('availabilityFilter');
      const priceMinInput = document.getElementById('priceMin');
      const priceMaxInput = document.getElementById('priceMax');
      const resetFiltersBtn = document.getElementById('resetFilters');
      const sortGroup = document.querySelector('[data-sort-group]');
      const sortButtons = Array.from(document.querySelectorAll('[data-sort-button]'));
      const sortSelection = document.getElementById('sortSelection');
      const itemsGrid = document.getElementById('itemsGrid');
      const resultsCount = document.getElementById('resultsCount');
      const itemsStatus = document.getElementById('itemsStatus');
      const goldStatus = document.getElementById('goldStatus');
      const searchInput = document.getElementById('inventorySearch');
      const searchResultsEl = document.getElementById('inventorySearchResults');
      const searchLabel = document.querySelector('[data-i18n="searchLabel"]');
      const languageToggle = document.getElementById('languageToggle');
      const filtersSection = document.getElementById('filtersSection');
      const resultsSection = document.getElementById('resultsSection');
      const itemDetailsDialog = document.getElementById('itemDetailsDialog');
      const itemDetailsContainer = document.getElementById('itemDetailsContainer');
      const itemDetailsClose = document.getElementById('itemDetailsClose');
      const i18nElements = document.querySelectorAll('[data-i18n]');

      const translations = {
        en: {
          pageTitle: 'Veridian Atelier • Inventory Explorer',
          languageLabel: 'Language',
          languageSelectAria: 'Select language',
          navScanner: 'Scanner',
          navInventory: 'Inventory',
          navSales: 'Sales log',
          navPurchases: 'Purchase log',
          navStatement: 'Gold statement',
          heroTitle: 'Inventory explorer',
          heroSubtitle:
            'Browse the current collection, refine by category and target price, and pick the layout that suits the conversation.',
          searchLabel: 'Search inventory',
          searchPlaceholder: 'Search items by SKU, category, or description…',
          searchHint: 'Type at least two characters to search the inventory.',
          searchLoading: 'Inventory still loading…',
          searchNoMatches: 'No items match this search. Adjust the filters or try another term.',
          searchHiddenMatches: 'All matching items are hidden by the current filters.',
          searchSummary: '{count} matches shown below.',
          searchSummarySingular: '1 match shown below.',
          searchSummaryFiltered: '{visible} of {total} matches shown with current filters.',
          searchMoreMatches: '+{count} more matches available in the grid.',
          searchMoreMatchesSingular: '+1 more match available in the grid.',
          filtersSectionAria: 'Inventory filters',
          filterCategoryLabel: 'Category',
          filterCategoryAll: 'All categories',
          filterAvailabilityLabel: 'Availability',
          filterAvailabilityAll: 'All items',
          filterAvailabilityAvailable: 'Available',
          filterAvailabilityNotAvailable: 'Not available',
          filterPriceLabel: 'Price range',
          filterPriceTo: 'to',
          filterPriceMinPlaceholder: 'Min',
          filterPriceMaxPlaceholder: 'Max',
          sortLegend: 'Sort by',
          sortAriaLabel: 'Sort inventory by',
          sortOptionSku: 'SKU',
          sortOptionSkuSubtitle: 'Catalog order',
          sortOptionSkuShort: 'SKU',
          sortAnnouncementSku: 'Sorted by SKU (ascending)',
          sortOptionPrice: 'Price',
          sortOptionPriceAscSubtitle: 'Low → High',
          sortOptionPriceAscShort: 'Price ↑',
          sortAnnouncementPriceAsc: 'Sorted by price low to high',
          sortOptionPriceDescSubtitle: 'High → Low',
          sortOptionPriceDescShort: 'Price ↓',
          sortAnnouncementPriceDesc: 'Sorted by price high to low',
          sortOptionWeight: 'Weight',
          sortOptionWeightAscSubtitle: 'Light → Heavy',
          sortOptionWeightAscShort: 'Weight ↑',
          sortAnnouncementWeightAsc: 'Sorted by weight light to heavy',
          sortOptionWeightDescSubtitle: 'Heavy → Light',
          sortOptionWeightDescShort: 'Weight ↓',
          sortAnnouncementWeightDesc: 'Sorted by weight heavy to light',
          sortCurrent: 'Sorting by {label}',
          statusLoading: 'Loading inventory…',
          statusNoData: 'No inventory data available yet.',
          statusSummary: 'Showing <strong>{visible}</strong> of <strong>{total}</strong> items',
          resultsHeading: 'Items',
          resultsCountSingular: '{count} item',
          resultsCountPlural: '{count} items',
          resetFilters: 'Reset filters',
          detailsHeading: 'Item details',
          detailsClose: 'Close details',
          viewModeCompact: 'Compact',
          goldStatusWithPrice: 'Gold price {price}',
          goldStatusUpdated: 'updated {time}',
          goldStatusUnavailable: 'Gold price unavailable — prices shown use sheet data only.',
          goldStatusSeparator: ' • ',
          photoUnavailable: 'Photo unavailable',
          photoAltNamed: '{name} photo',
          photoAltItem: 'Item photo',
          skuLabel: 'SKU {value}',
          itemDefaultName: 'Item',
          priceSheet: 'Sheet price',
          priceEstimated: 'Estimated price',
          priceNotAvailable: 'Not available',
          metaWeight: 'Weight',
          metaKarat: 'Karat',
          metaCategory: 'Category',
          metaFees: 'Fees',
          metaStatus: 'Status',
          metaPerGram: 'Per gram',
          badgeUpdated: 'Updated {value}',
          unitGram: 'g',
          weightDisplay: '{value} g',
          perGramDisplay: '{value} / g',
          emptyFilters:
            'No items match your filters yet. Adjust the filters or reset them to see the full collection.',
          emptyNoRows: 'No inventory rows are available yet.',
          errorStatus: 'Unable to load inventory. Please refresh after checking your connection.',
          errorEmpty: 'We could not reach the inventory service. Please try again in a moment.'
        },
        ar: {
          pageTitle: 'Veridian Atelier • مستكشف المخزون',
          languageLabel: 'اللغة',
          languageSelectAria: 'اختيار اللغة',
          navScanner: 'الماسح',
          navInventory: 'المخزون',
          navSales: 'سجل المبيعات',
          navPurchases: 'سجل المشتريات',
          navStatement: 'بيان الذهب',
          heroTitle: 'مستكشف المخزون',
          heroSubtitle:
            'تصفح التشكيلة الحالية، وقم بتصفية النتائج حسب الفئة والسعر المستهدف، واختر العرض الأنسب للحوار.',
          searchLabel: 'ابحث في المخزون',
          searchPlaceholder: 'ابحث عن القطع برمز الصنف أو الفئة أو الوصف…',
          searchHint: 'اكتب حرفين على الأقل لبدء البحث في المخزون.',
          searchLoading: 'لا يزال المخزون قيد التحميل…',
          searchNoMatches: 'لا توجد قطع مطابقة لهذا البحث. عدّل المرشحات أو جرّب عبارة أخرى.',
          searchHiddenMatches: 'جميع القطع المطابقة مخفية بسبب المرشحات الحالية.',
          searchSummary: '{count} نتيجة معروضة أدناه.',
          searchSummarySingular: 'نتيجة واحدة معروضة أدناه.',
          searchSummaryFiltered: '{visible} من {total} نتيجة معروضة وفقًا للمرشحات الحالية.',
          searchMoreMatches: '+{count} نتيجة إضافية متاحة ضمن الشبكة.',
          searchMoreMatchesSingular: '+نتيجة إضافية واحدة متاحة ضمن الشبكة.',
          filtersSectionAria: 'مرشحات المخزون',
          filterCategoryLabel: 'الفئة',
          filterCategoryAll: 'جميع الفئات',
          filterAvailabilityLabel: 'التوفر',
          filterAvailabilityAll: 'جميع القطع',
          filterAvailabilityAvailable: 'متوفر',
          filterAvailabilityNotAvailable: 'غير متوفر',
          filterPriceLabel: 'نطاق السعر',
          filterPriceTo: 'إلى',
          filterPriceMinPlaceholder: 'الحد الأدنى',
          filterPriceMaxPlaceholder: 'الحد الأقصى',
          sortLegend: 'ترتيب حسب',
          sortAriaLabel: 'ترتيب المخزون حسب',
          sortOptionSku: 'رمز الصنف',
          sortOptionSkuSubtitle: 'ترتيب الكتالوج',
          sortOptionSkuShort: 'رمز',
          sortAnnouncementSku: 'تم الترتيب حسب رمز الصنف تصاعديًا',
          sortOptionPrice: 'السعر',
          sortOptionPriceAscSubtitle: 'منخفض → مرتفع',
          sortOptionPriceAscShort: 'السعر ↑',
          sortAnnouncementPriceAsc: 'تم الترتيب حسب السعر من الأقل إلى الأعلى',
          sortOptionPriceDescSubtitle: 'مرتفع → منخفض',
          sortOptionPriceDescShort: 'السعر ↓',
          sortAnnouncementPriceDesc: 'تم الترتيب حسب السعر من الأعلى إلى الأقل',
          sortOptionWeight: 'الوزن',
          sortOptionWeightAscSubtitle: 'خفيف → ثقيل',
          sortOptionWeightAscShort: 'الوزن ↑',
          sortAnnouncementWeightAsc: 'تم الترتيب حسب الوزن من الأخف إلى الأثقل',
          sortOptionWeightDescSubtitle: 'ثقيل → خفيف',
          sortOptionWeightDescShort: 'الوزن ↓',
          sortAnnouncementWeightDesc: 'تم الترتيب حسب الوزن من الأثقل إلى الأخف',
          sortCurrent: 'يتم الترتيب حسب {label}',
          statusLoading: 'جاري تحميل المخزون…',
          statusNoData: 'لا تتوفر بيانات مخزون بعد.',
          statusSummary: 'عرض <strong>{visible}</strong> من أصل <strong>{total}</strong> قطعة',
          resultsHeading: 'القطع',
          resultsCountSingular: '{count} قطعة',
          resultsCountPlural: '{count} قطع',
          resetFilters: 'إعادة تعيين المرشحات',
          detailsHeading: 'تفاصيل القطعة',
          detailsClose: 'إغلاق التفاصيل',
          viewModeCompact: 'عرض مضغوط',
          goldStatusWithPrice: 'سعر الذهب {price}',
          goldStatusUpdated: 'تم التحديث في {time}',
          goldStatusUnavailable: 'تعذر الحصول على سعر الذهب — يتم استخدام بيانات الجدول فقط.',
          goldStatusSeparator: ' • ',
          photoUnavailable: 'الصورة غير متاحة',
          photoAltNamed: 'صورة {name}',
          photoAltItem: 'صورة القطعة',
          skuLabel: 'رمز الصنف {value}',
          itemDefaultName: 'قطعة',
          priceSheet: 'سعر الجدول',
          priceEstimated: 'سعر تقديري',
          priceNotAvailable: 'غير متاح',
          metaWeight: 'الوزن',
          metaKarat: 'العيار',
          metaCategory: 'الفئة',
          metaFees: 'الأجور',
          metaStatus: 'الحالة',
          metaPerGram: 'لكل غرام',
          badgeUpdated: 'تم التحديث {value}',
          unitGram: 'غ',
          weightDisplay: '{value} غ',
          perGramDisplay: '{value} / غ',
          emptyFilters:
            'لا توجد قطع مطابقة للمرشحات الحالية. عدّل المرشحات أو أعد تعيينها لمشاهدة المجموعة كاملة.',
          emptyNoRows: 'لا توجد صفوف مخزون متاحة بعد.',
          errorStatus: 'تعذر تحميل المخزون. يرجى التحديث بعد التحقق من الاتصال.',
          errorEmpty: 'تعذر الوصول إلى خدمة المخزون. حاول مرة أخرى بعد قليل.'
        }
      };

      let currentLanguage = localStorage.getItem('statementLanguage') === 'ar' ? 'ar' : 'en';

      function t(key, replacements) {
        const langTable = translations[currentLanguage] || translations.en;
        const template = key in langTable ? langTable[key] : translations.en[key] || key;
        if (!replacements) return template;
        return template.replace(/\{(\w+)\}/g, (match, token) => {
          if (Object.prototype.hasOwnProperty.call(replacements, token)) {
            return replacements[token];
          }
          return match;
        });
      }

      function getLocale() {
        return currentLanguage === 'ar' ? 'ar-EG' : undefined;
      }

      function formatNumber(value) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) return String(value ?? '');
        const locale = getLocale();
        return numeric.toLocaleString(locale);
      }

      function formatCurrency(value) {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) return t('priceNotAvailable');
        const locale = getLocale();
        return numeric.toLocaleString(locale, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
      }

      function formatWeightDisplay(value) {
        if (!Number.isFinite(value)) return '';
        const locale = getLocale();
        const formatted = value.toLocaleString(locale, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        return t('weightDisplay', { value: formatted });
      }

      function formatPerGram(value) {
        if (!Number.isFinite(value)) return '';
        const locale = getLocale();
        const formatted = value.toLocaleString(locale, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        return t('perGramDisplay', { value: formatted });
      }

      function updateLanguageAttributes() {
        document.documentElement.lang = currentLanguage === 'ar' ? 'ar' : 'en';
        document.documentElement.dir = currentLanguage === 'ar' ? 'rtl' : 'ltr';
        document.body.classList.toggle('rtl', currentLanguage === 'ar');
      }

      function renderStaticText() {
        document.title = t('pageTitle');
        i18nElements.forEach((element) => {
          if (!(element instanceof HTMLElement)) return;
          if (element.hasAttribute('data-i18n-dynamic')) return;
          const key = element.getAttribute('data-i18n');
          if (!key) return;
          element.textContent = t(key);
        });

        if (languageToggle) {
          languageToggle.value = currentLanguage;
          languageToggle.setAttribute('aria-label', t('languageSelectAria'));
        }

        if (filtersSection) {
          filtersSection.setAttribute('aria-label', t('filtersSectionAria'));
        }

        if (resultsSection) {
          resultsSection.setAttribute('aria-label', t('resultsHeading'));
        }

        if (sortGroup) {
          sortGroup.setAttribute('aria-label', t('sortAriaLabel'));
        }

        if (priceMinInput) {
          priceMinInput.placeholder = t('filterPriceMinPlaceholder');
        }
        if (priceMaxInput) {
          priceMaxInput.placeholder = t('filterPriceMaxPlaceholder');
        }
        if (searchInput) {
          searchInput.placeholder = t('searchPlaceholder');
        }
        if (searchLabel) {
          searchLabel.textContent = t('searchLabel');
        }
        updateSearchResultsList();
      }

      function updateFilterOptionLabels() {
        if (categorySelect) {
          const defaultOption = categorySelect.querySelector('option[value=""]');
          if (defaultOption) {
            defaultOption.textContent = t('filterCategoryAll');
          }
        }
        if (availabilitySelect) {
          const defaultOption = availabilitySelect.querySelector('option[value=""]');
          const availableOption = availabilitySelect.querySelector('option[value="available"]');
          const notAvailableOption = availabilitySelect.querySelector('option[value="not-available"]');
          if (defaultOption) defaultOption.textContent = t('filterAvailabilityAll');
          if (availableOption) availableOption.textContent = t('filterAvailabilityAvailable');
          if (notAvailableOption) notAvailableOption.textContent = t('filterAvailabilityNotAvailable');
        }
      }

      function updateSortLabels() {
        sortButtons.forEach((button) => {
          const index = clampSortIndex(button.getAttribute('data-sort-index'));
          const option = SORT_OPTIONS[index] ?? SORT_OPTIONS[0];
          const labelEl = button.querySelector('.sort-chip__label');
          const subtitleEl = button.querySelector('.sort-chip__subtitle');
          if (labelEl) labelEl.textContent = t(option.labelKey);
          if (subtitleEl) subtitleEl.textContent = t(option.subtitleKey);
          if (option.announcementKey) {
            button.setAttribute('aria-label', t(option.announcementKey));
          }
        });
        if (sortGroup) {
          sortGroup.setAttribute('aria-label', t('sortAriaLabel'));
        }
      }

      const uiState = {
        statusMode: 'loading',
        total: 0,
        visible: 0,
        emptyType: 'none'
      };

      function refreshStatusText() {
        if (!itemsStatus) return;
        if (uiState.statusMode === 'loading') {
          itemsStatus.textContent = t('statusLoading');
          return;
        }
        if (uiState.statusMode === 'error') {
          itemsStatus.textContent = t('errorStatus');
          return;
        }
        if (uiState.statusMode === 'no-data') {
          itemsStatus.textContent = t('statusNoData');
          return;
        }
        const visibleText = formatNumber(uiState.visible);
        const totalText = formatNumber(uiState.total);
        itemsStatus.innerHTML = t('statusSummary', { visible: visibleText, total: totalText });
      }

      function refreshResultsCount() {
        if (!resultsCount) return;
        const count = Number(uiState.visible);
        const formatted = formatNumber(count);
        if (count === 1) {
          resultsCount.textContent = t('resultsCountSingular', { count: formatted });
        } else {
          resultsCount.textContent = t('resultsCountPlural', { count: formatted });
        }
      }

      function refreshGoldStatus() {
        if (!goldStatus) return;
        if (Number.isFinite(state.goldPrice)) {
          const priceText = formatCurrency(state.goldPrice);
          const parts = [t('goldStatusWithPrice', { price: priceText })];
          if (state.goldUpdatedAt) {
            parts.push(t('goldStatusUpdated', { time: sanitize(state.goldUpdatedAt) }));
          }
          goldStatus.textContent = parts.join(t('goldStatusSeparator'));
        } else {
          goldStatus.textContent = t('goldStatusUnavailable');
        }
      }

      function refreshEmptyMessage() {
        if (!itemsGrid) return;
        const emptyEl = itemsGrid.querySelector('.empty-state');
        if (!emptyEl) return;
        const type = emptyEl.dataset.emptyType || uiState.emptyType;
        if (type === 'filters') {
          emptyEl.textContent = t('emptyFilters');
        } else if (type === 'no-data') {
          emptyEl.textContent = t('emptyNoRows');
        } else if (type === 'error') {
          emptyEl.textContent = t('errorEmpty');
        }
      }

      function refreshLanguageDependentText() {
        updateLanguageAttributes();
        renderStaticText();
        updateFilterOptionLabels();
        updateSortLabels();
        const activeIndex = Number.isInteger(state.sortIndex)
          ? state.sortIndex
          : RESOLVED_DEFAULT_SORT_INDEX;
        setSortByIndex(activeIndex, { trigger: false });
        refreshGoldStatus();
        refreshStatusText();
        refreshResultsCount();
        refreshEmptyMessage();
        if (isItemDetailsOpen() && lastOpenedDetailsRow && itemDetailsContainer) {
          itemDetailsContainer.innerHTML = '';
          const detailCard = createItemCard(lastOpenedDetailsRow, 'detailed', { interactive: false, role: 'article' });
          itemDetailsContainer.appendChild(detailCard);
        }
        if (state.dataLoaded) {
          applyFilters();
        }
      }

      function applyLanguage(language) {
        const nextLanguage = translations[language] ? language : 'en';
        if (currentLanguage !== nextLanguage) {
          currentLanguage = nextLanguage;
          localStorage.setItem('statementLanguage', currentLanguage);
        }
        refreshLanguageDependentText();
      }

      const SORT_OPTIONS = Object.freeze([
        {
          value: 'sku',
          labelKey: 'sortOptionSku',
          subtitleKey: 'sortOptionSkuSubtitle',
          shortKey: 'sortOptionSkuShort',
          announcementKey: 'sortAnnouncementSku'
        },
        {
          value: 'price-asc',
          labelKey: 'sortOptionPrice',
          subtitleKey: 'sortOptionPriceAscSubtitle',
          shortKey: 'sortOptionPriceAscShort',
          announcementKey: 'sortAnnouncementPriceAsc'
        },
        {
          value: 'price-desc',
          labelKey: 'sortOptionPrice',
          subtitleKey: 'sortOptionPriceDescSubtitle',
          shortKey: 'sortOptionPriceDescShort',
          announcementKey: 'sortAnnouncementPriceDesc'
        },
        {
          value: 'weight-asc',
          labelKey: 'sortOptionWeight',
          subtitleKey: 'sortOptionWeightAscSubtitle',
          shortKey: 'sortOptionWeightAscShort',
          announcementKey: 'sortAnnouncementWeightAsc'
        },
        {
          value: 'weight-desc',
          labelKey: 'sortOptionWeight',
          subtitleKey: 'sortOptionWeightDescSubtitle',
          shortKey: 'sortOptionWeightDescShort',
          announcementKey: 'sortAnnouncementWeightDesc'
        }
      ]);
      const DEFAULT_SORT_INDEX = SORT_OPTIONS.findIndex((option) => option.value === 'price-asc');
      const RESOLVED_DEFAULT_SORT_INDEX = DEFAULT_SORT_INDEX >= 0 ? DEFAULT_SORT_INDEX : 0;

      const state = {
        rows: [],
        filtered: [],
        viewMode: 'compact',
        sortBy: SORT_OPTIONS[RESOLVED_DEFAULT_SORT_INDEX]?.value ?? SORT_OPTIONS[0].value,
        sortIndex: RESOLVED_DEFAULT_SORT_INDEX,
        goldPrice: null,
        goldUpdatedAt: '',
        categoryKey: null,
        searchQuery: '',
        searchQueryNormalized: '',
        searchActive: false,
        searchMatchCount: null,
        dataLoaded: false
      };

      let highlightTimeout = null;
      let lastHighlightedCardId = null;

      let lastFocusedDetailsTrigger = null;
      let lastOpenedDetailsRow = null;

      function normalizeDigits(value = '') {
        return String(value ?? '')
          .replace(/\u0660/g, '0').replace(/\u0661/g, '1').replace(/\u0662/g, '2')
          .replace(/\u0663/g, '3').replace(/\u0664/g, '4').replace(/\u0665/g, '5')
          .replace(/\u0666/g, '6').replace(/\u0667/g, '7').replace(/\u0668/g, '8')
          .replace(/\u0669/g, '9')
          .replace(/\u06F0/g, '0').replace(/\u06F1/g, '1').replace(/\u06F2/g, '2')
          .replace(/\u06F3/g, '3').replace(/\u06F4/g, '4').replace(/\u06F5/g, '5')
          .replace(/\u06F6/g, '6').replace(/\u06F7/g, '7').replace(/\u06F8/g, '8')
          .replace(/\u06F9/g, '9')
          .replace(/\u066B/g, '.').replace(/\u066C/g, ',');
      }


      function debounce(func, wait = 200) {
        let timeoutId;
        return function debounced(...args) {
          clearTimeout(timeoutId);
          timeoutId = setTimeout(() => func.apply(this, args), wait);
        };
      }
      function extractNumber(value) {
        if (typeof value === 'number') {
          return Number.isFinite(value) ? value : NaN;
        }
        const normalized = normalizeDigits(value);
        const match = normalized.match(/-?\d+(?:[.,]\d+)?/);
        if (!match) return NaN;
        const token = match[0];
        const formatted = token.includes(',') && !token.includes('.')
          ? token.replace(',', '.')
          : token.replace(/,/g, '');
        const num = Number.parseFloat(formatted);
        return Number.isFinite(num) ? num : NaN;
      }

      function sanitize(value) {
        const div = document.createElement('div');
        div.textContent = String(value ?? '');
        return div.textContent;
      }


      function createItemUid(row, index) {
        const sku = (row && row.__sku) || (row && row.sku) || '';
        const base = sku ? `sku-${sku}` : 'item';
        return `${base}-${index}`.replace(/[^a-zA-Z0-9_-]+/g, '-').toLowerCase();
      }
      function normalizePhotoUrl(value) {
        const raw = String(value ?? '').trim();
        if (!raw) return '';

        if (raw.startsWith('data:')) {
          return raw;
        }

        let token = raw.split(/\s+/)[0];

        if (raw.startsWith('=')) {
          const quotedUrl = raw.match(/["'](https?:\/\/[^"']+)["']/i);
          if (quotedUrl && quotedUrl[1]) {
            token = quotedUrl[1];
          } else {
            const bareUrl = raw.match(/https?:\/\/[^,\s)]+/i);
            if (bareUrl && bareUrl[0]) {
              token = bareUrl[0];
            }
          }
        } else {
          const inlineUrl = raw.match(/https?:\/\/[^\s"']+/i);
          if (inlineUrl && inlineUrl[0]) {
            token = inlineUrl[0];
          }
        }

        if (!/^https?:/i.test(token)) {
          if (/^drive\.google\.com/i.test(token)) {
            token = `https://${token}`;
          }
        }

        let url;
        try {
          url = new URL(token);
        } catch (error) {
          try {
            url = new URL(token, window.location.origin);
          } catch (nestedError) {
            return '';
          }
        }

        if (!['http:', 'https:'].includes(url.protocol)) {
          return '';
        }

        if (url.hostname.includes('drive.google.com')) {
          const match = url.pathname.match(/\/file\/d\/([^/]+)/);
          const id = match ? match[1] : url.searchParams.get('id');
          const resourceKey = url.searchParams.get('resourcekey');

          if (id) {
            const params = new URLSearchParams({ export: 'view', id });
            if (resourceKey) {
              params.set('resourcekey', resourceKey);
            }
            return `https://drive.google.com/uc?${params.toString()}`;
          }

          if (url.pathname.startsWith('/uc')) {
            const params = new URLSearchParams(url.search);
            if (resourceKey && !params.get('resourcekey')) {
              params.set('resourcekey', resourceKey);
              return `https://drive.google.com${url.pathname}?${params.toString()}`;
            }
          }
        }

        return url.href;
      }

      function loadImageWithTimeout(imgElement, src, timeout = 5000) {
        return new Promise((resolve, reject) => {
          let settled = false;

          const cleanup = () => {
            imgElement.onload = null;
            imgElement.onerror = null;
          };

          const timer = setTimeout(() => {
            if (settled) return;
            settled = true;
            cleanup();
            reject(new Error('Image load timeout'));
          }, timeout);

          imgElement.onload = () => {
            if (settled) return;
            settled = true;
            clearTimeout(timer);
            cleanup();
            resolve();
          };

          imgElement.onerror = () => {
            if (settled) return;
            settled = true;
            clearTimeout(timer);
            cleanup();
            reject(new Error('Image load failed'));
          };

          imgElement.src = src;
        });
      }

      function getDriveId(url = '') {
        const s = String(url).trim();
        if (!s) return null;

        const patterns = [
          /[?&]id=([A-Za-z0-9_-]+)/,
          /\/file\/d\/([A-Za-z0-9_-]+)/,
          /\/uc\?export=(?:download|view)&id=([A-Za-z0-9_-]+)/,
          /\/d\/([A-Za-z0-9_-]+)/,
          /\/view\?usp=sharing&id=([A-Za-z0-9_-]+)/,
          /drive\.google\.com\/file\/d\/([A-Za-z0-9_-]+)/
        ];

        for (const pattern of patterns) {
          const match = s.match(pattern);
          if (match && match[1]) {
            return match[1];
          }
        }

        if (/\.(jpg|jpeg|png|gif|webp)(\?.*)?$/i.test(s)) {
          return null;
        }

        return null;
      }

      function buildPhotoCandidateUrls(rawUrl) {
        const trimmed = String(rawUrl ?? '').trim();
        if (!trimmed) return [];

        const candidates = [];
        const seen = new Set();

        const pushCandidate = (candidate) => {
          const normalized = String(candidate ?? '').trim();
          if (!normalized || seen.has(normalized)) return;
          seen.add(normalized);
          candidates.push(normalized);
        };

        pushCandidate(trimmed);

        const driveId = getDriveId(trimmed);
        if (driveId) {
          let resourceKey = '';
          try {
            const parsed = new URL(trimmed);
            resourceKey = parsed.searchParams.get('resourcekey') || '';
          } catch (error) {
            resourceKey = '';
          }

          const suffix = resourceKey ? `&resourcekey=${encodeURIComponent(resourceKey)}` : '';

          pushCandidate(`https://drive.google.com/uc?export=view&id=${driveId}${suffix}`);
          pushCandidate(`https://drive.google.com/thumbnail?id=${driveId}&sz=s1600${suffix}`);
          pushCandidate(`https://lh3.googleusercontent.com/d/${driveId}=s1600`);
        }

        return candidates;
      }

      function normalizeRowKeys(row) {
        const out = {};
        let laborFeeRaw;
        let profitFeeRaw;

        for (const key of Object.keys(row || {})) {
          const value = row[key];
          const lower = key.trim().toLowerCase();

          out[key] = value;
          out[lower] = value;

          if (lower.includes('sku')) out.sku = value;
          if (lower.includes('timestamp')) out.timestamp = value;
          if (lower.includes('type')) out.type = value;
          if (lower.includes('status') || lower.includes('حالة')) out.availability = value;
          if (lower.includes('piece type') || lower.includes('نوع القطعة')) out.name = value;
          if (lower.includes('weight') || lower.includes('وزن')) out.weight = value;
          if (lower.includes('karat') || lower.includes('carat') || lower.includes('عيار')) out.karat = value;
          if (lower.includes('making fee') || lower.includes('أجور')) out.fees = value;
          if (lower.includes('اجور بالغرام')) laborFeeRaw = value;
          if (lower.includes('ربح لكل غرام')) profitFeeRaw = value;
          if (lower.includes('description') || lower.includes('وصف')) out.description = value;
          if (lower.includes('photo') || lower.includes('video') || lower.includes('image')) out.photo = value;
          if (lower.includes('أسم البائع')) out.soldby = value;
          if (lower.includes('تاريخ المبيع')) out.solddate = value;
          if (
            lower.includes('مبلغ البيع') ||
            lower.includes('sold price') ||
            lower.includes('sell price') ||
            lower.includes('sale price') ||
            lower.includes('sold amount') ||
            lower.includes('sale amount')
          ) {
            out.soldprice = value;
          }
          if (lower.includes('ملاحظات')) out.notes = value;
        }

        const hasLaborFee = typeof laborFeeRaw !== 'undefined' && String(laborFeeRaw ?? '').trim() !== '';
        const hasProfitFee = typeof profitFeeRaw !== 'undefined' && String(profitFeeRaw ?? '').trim() !== '';

        if (hasLaborFee || hasProfitFee) {
          const parseFeeComponent = (raw) => {
            const normalized = String(raw ?? '').trim();
            if (!normalized) return 0;
            const numeric = Number(normalized.replace(/[^0-9.,-]/g, '').replace(',', '.'));
            return Number.isFinite(numeric) ? numeric : 0;
          };

          const laborFee = parseFeeComponent(laborFeeRaw);
          const profitFee = parseFeeComponent(profitFeeRaw);
          const totalFees = laborFee + profitFee;

          if (Number.isFinite(totalFees)) {
            const formattedTotal = totalFees
              .toFixed(4)
              .replace(/\.0+$/, '')
              .replace(/(\.\d*?)0+$/, '$1');
            out.fees = formattedTotal;
          }
        }

        return out;
      }

      function normalizeCategoryValue(value = '') {
        return String(value ?? '').trim().toLowerCase();
      }

      function normalizeAvailabilityState(value = '') {
        const normalized = String(value ?? '').trim().toLowerCase();
        if (!normalized) {
          return 'unknown';
        }

        const negativePatterns = /not\s*available|unavailable|sold|reserved|out\s*of\s*stock|out-of-stock|on hold|on\s*hold|hold|pending|coming soon|preorder|pre-order/;
        if (negativePatterns.test(normalized)) {
          return 'not-available';
        }

        const positivePatterns = /available|in stock|instock|ready/;
        if (positivePatterns.test(normalized)) {
          return 'available';
        }

        return 'unknown';
      }

      function detectCategoryKey(rows = []) {
        if (!rows.length) return null;
        const keys = new Set();
        for (const row of rows) {
          for (const key of Object.keys(row)) {
            if (!key) continue;
            keys.add(key.trim().toLowerCase());
          }
        }
        const candidates = [
          'category',
          'type',
          'collection',
          'group',
          'line',
          'segment',
          'الصنف',
          'الفئة',
          'نوع',
          'name',
          'piece type | نوع القطعة'
        ];
        for (const candidate of candidates) {
          if (keys.has(candidate)) {
            return candidate;
          }
        }
        return null;
      }

      function computeItemPrice(weightStr, karatStr, feesStr, basePrice) {
        const weight = extractNumber(weightStr);
        const fees = extractNumber(feesStr) || 0;
        const karat = parseInt(String(karatStr ?? '').replace(/[^\d]/g, ''), 10) || 0;
        if (!Number.isFinite(basePrice) || !basePrice || !weight || !karat) {
          return null;
        }
        let purity;
        if (karat === 18) purity = 750 / 995;
        else if (karat === 21) purity = 875 / 995;
        else purity = karat / 24;
        const perGram = ((basePrice + PREMIUM) * OUNCE_GRAMS * purity) / 1000 + fees;
        const total = perGram * weight;
        if (!Number.isFinite(total)) return null;
        return { total, perGram, weight, karat };
      }

      function findExistingPrice(row) {
        for (const key of Object.keys(row)) {
          if (!key) continue;
          const lower = key.trim().toLowerCase();
          if (
            !lower ||
            lower.includes('sold') ||
            lower.includes('sale') ||
            lower.includes('cost')
          ) {
            continue;
          }
          if (lower.includes('price') || lower.includes('amount') || lower.includes('value')) {
            const numeric = extractNumber(row[key]);
            if (Number.isFinite(numeric)) {
              return { numeric, display: row[key] };
            }
          }
        }
        return null;
      }

      function formatPrice(value, fallbackText = t('priceNotAvailable')) {
        if (Number.isFinite(value)) {
          return formatCurrency(value);
        }
        return fallbackText;
      }

      function populateCategoryOptions(rows) {
        if (!categorySelect) return;
        const previousValue = categorySelect.value;
        const options = new Map();
        for (const row of rows) {
          const raw = row.__categoryRaw;
          const normalized = row.__categoryNormalized;
          if (!normalized) continue;
          if (!options.has(normalized)) {
            options.set(normalized, raw || '');
          }
        }
        const locale = getLocale();
        const entries = Array.from(options.entries()).sort((a, b) => {
          const labelA = a[1] || '';
          const labelB = b[1] || '';
          return labelA.localeCompare(labelB, locale || undefined, { sensitivity: 'base' });
        });

        categorySelect.innerHTML = '';
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = t('filterCategoryAll');
        categorySelect.appendChild(defaultOption);

        for (const [value, label] of entries) {
          const option = document.createElement('option');
          option.value = value;
          option.textContent = label;
          categorySelect.appendChild(option);
        }

        if (previousValue && options.has(previousValue)) {
          categorySelect.value = previousValue;
        } else {
          categorySelect.value = '';
        }
      }

      function updateStatus() {
        if (!state.dataLoaded) {
          refreshStatusText();
          refreshResultsCount();
          updateSearchResultsList();
          return;
        }

        uiState.total = state.rows.length;
        uiState.visible = state.filtered.length;
        uiState.statusMode = state.rows.length ? 'ready' : 'no-data';
        refreshStatusText();
        refreshResultsCount();
        updateSearchResultsList();
      }

      function focusCardById(targetId) {
        if (!targetId) return;
        const card = document.getElementById(targetId);
        if (!card) return;

        if (lastHighlightedCardId && lastHighlightedCardId !== targetId) {
          const previous = document.getElementById(lastHighlightedCardId);
          if (previous) {
            previous.classList.remove('item-card--highlight');
          }
        }

        card.classList.add('item-card--highlight');
        lastHighlightedCardId = targetId;

        card.scrollIntoView({ behavior: 'smooth', block: 'center' });
        if (typeof card.focus === 'function') {
          card.focus({ preventScroll: true });
        }

        if (highlightTimeout) {
          clearTimeout(highlightTimeout);
        }

        highlightTimeout = setTimeout(() => {
          card.classList.remove('item-card--highlight');
          if (lastHighlightedCardId === targetId) {
            lastHighlightedCardId = null;
          }
        }, 1800);
      }

      function updateSearchResultsList() {
        if (!searchResultsEl) return;

        const rawQuery = searchInput ? searchInput.value : state.searchQuery || '';
        const trimmed = rawQuery.trim();
        searchResultsEl.innerHTML = '';

        if (!trimmed) {
          searchResultsEl.hidden = true;
          return;
        }

        if (!state.searchActive) {
          const hint = document.createElement('p');
          hint.className = 'search-empty';
          hint.textContent = t('searchHint');
          searchResultsEl.appendChild(hint);
          searchResultsEl.hidden = false;
          return;
        }

        if (!state.dataLoaded) {
          const loading = document.createElement('p');
          loading.className = 'search-empty';
          loading.textContent = t('searchLoading');
          searchResultsEl.appendChild(loading);
          searchResultsEl.hidden = false;
          return;
        }

        const totalMatches = state.searchMatchCount ?? state.filtered.length;
        const visibleMatches = state.filtered.length;

        if (!totalMatches) {
          const empty = document.createElement('p');
          empty.className = 'search-empty';
          empty.textContent = t('searchNoMatches');
          searchResultsEl.appendChild(empty);
          searchResultsEl.hidden = false;
          return;
        }

        if (!visibleMatches) {
          const hiddenMessage = document.createElement('p');
          hiddenMessage.className = 'search-empty';
          hiddenMessage.textContent = t('searchHiddenMatches');
          searchResultsEl.appendChild(hiddenMessage);
          searchResultsEl.hidden = false;
          return;
        }

        const summary = document.createElement('p');
        summary.className = 'search-results__summary';
        if (state.searchMatchCount !== null && state.searchMatchCount !== visibleMatches) {
          summary.textContent = t('searchSummaryFiltered', {
            visible: formatNumber(visibleMatches),
            total: formatNumber(state.searchMatchCount)
          });
        } else if (visibleMatches === 1) {
          summary.textContent = t('searchSummarySingular');
        } else {
          summary.textContent = t('searchSummary', { count: formatNumber(visibleMatches) });
        }
        searchResultsEl.appendChild(summary);

        const limit = 8;
        const matches = state.filtered.slice(0, limit);

        const createMetaText = (row) => {
          const parts = [];
          if (row.__sku) parts.push(t('skuLabel', { value: row.__sku }));
          if (row.__categoryRaw) parts.push(row.__categoryRaw);
          if (row.__availabilityRaw) parts.push(row.__availabilityRaw);
          let priceText = '';
          if (Number.isFinite(row.__price)) {
            priceText = formatPrice(row.__price);
          } else if (row.__priceFallback) {
            priceText = row.__priceFallback;
          }
          if (priceText) parts.push(priceText);
          if (row.__description) {
            const snippet = row.__description.length > 90
              ? `${row.__description.slice(0, 87)}…`
              : row.__description;
            parts.push(snippet);
          }
          return parts.filter(Boolean).join(' • ');
        };

        for (const row of matches) {
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'search-result';
          if (row.__uid) {
            button.dataset.targetId = row.__uid;
          }

          const title = document.createElement('span');
          title.className = 'search-result-title';
          title.textContent = row.__name || t('itemDefaultName');
          button.appendChild(title);

          const metaText = createMetaText(row);
          if (metaText) {
            const meta = document.createElement('span');
            meta.className = 'search-result-meta';
            meta.textContent = metaText;
            button.appendChild(meta);
          }

          button.addEventListener('click', () => {
            if (row.__uid) {
              focusCardById(row.__uid);
            }
          });

          searchResultsEl.appendChild(button);
        }

        const remainder = totalMatches - matches.length;
        if (remainder > 0) {
          const more = document.createElement('p');
          more.className = 'search-result-meta';
          more.textContent = t(remainder === 1 ? 'searchMoreMatchesSingular' : 'searchMoreMatches', {
            count: formatNumber(remainder)
          });
          searchResultsEl.appendChild(more);
        }

        searchResultsEl.hidden = false;
      }

      function applyFilters() {
        if (!state.dataLoaded) {
          updateSearchResultsList();
          return;
        }
        const category = categorySelect.value;
        const availability = availabilitySelect.value;
        const priceMin = extractNumber(priceMinInput.value);
        const priceMax = extractNumber(priceMaxInput.value);

        let working = state.rows;

        if (state.searchActive) {
          const query = state.searchQueryNormalized;
          working = working.filter((row) => row.__searchHaystack && row.__searchHaystack.includes(query));
          state.searchMatchCount = working.length;
        } else {
          state.searchMatchCount = null;
        }

        state.filtered = working.filter((row) => {
          if (category && row.__categoryNormalized !== category) {
            return false;
          }

          if (availability === 'available' && row.__availabilityState !== 'available') {
            return false;
          }

          if (availability === 'not-available' && row.__availabilityState !== 'not-available') {
            return false;
          }

          if (Number.isFinite(priceMin)) {
            if (!Number.isFinite(row.__price) || row.__price < priceMin) {
              return false;
            }
          }

          if (Number.isFinite(priceMax)) {
            if (!Number.isFinite(row.__price) || row.__price > priceMax) {
              return false;
            }
          }

          return true;
        });

        sortFiltered();
        renderItems();
        updateStatus();
      }

      function fallbackComparison(a, b) {
        const nameComparison = (a.__name || '').localeCompare(b.__name || '', undefined, {
          sensitivity: 'base'
        });
        if (nameComparison !== 0) {
          return nameComparison;
        }
        return (a.__index ?? 0) - (b.__index ?? 0);
      }

      function compareByNumeric(a, b, extractor, direction = 'asc') {
        const valueA = extractor(a);
        const valueB = extractor(b);
        const hasA = Number.isFinite(valueA);
        const hasB = Number.isFinite(valueB);

        if (hasA && hasB) {
          if (valueA !== valueB) {
            return direction === 'desc' ? valueB - valueA : valueA - valueB;
          }
        } else if (hasA !== hasB) {
          return hasA ? -1 : 1;
        }

        return fallbackComparison(a, b);
      }

      function compareBySku(a, b) {
        const skuA = a.__sku || '';
        const skuB = b.__sku || '';
        const hasA = Boolean(skuA);
        const hasB = Boolean(skuB);

        if (hasA && hasB) {
          const comparison = skuA.localeCompare(skuB, undefined, {
            numeric: true,
            sensitivity: 'base'
          });
          if (comparison !== 0) {
            return comparison;
          }
        } else if (hasA !== hasB) {
          return hasA ? -1 : 1;
        }

        return fallbackComparison(a, b);
      }

      const SORT_COMPARATORS = {
        'price-asc': (a, b) => compareByNumeric(a, b, (row) => row.__price, 'asc'),
        'price-desc': (a, b) => compareByNumeric(a, b, (row) => row.__price, 'desc'),
        'weight-asc': (a, b) => compareByNumeric(a, b, (row) => row.__weight, 'asc'),
        'weight-desc': (a, b) => compareByNumeric(a, b, (row) => row.__weight, 'desc'),
        sku: compareBySku
      };

      function sortFiltered() {
        const comparator = SORT_COMPARATORS[state.sortBy] || SORT_COMPARATORS['price-asc'];
        state.filtered.sort(comparator);
      }

      function clampSortIndex(rawIndex) {
        const parsed = Number.parseInt(rawIndex, 10);
        if (!Number.isFinite(parsed)) {
          return RESOLVED_DEFAULT_SORT_INDEX;
        }
        return Math.min(Math.max(parsed, 0), SORT_OPTIONS.length - 1);
      }

      function updateSortDisplay(index) {
        const option = SORT_OPTIONS[index] ?? SORT_OPTIONS[RESOLVED_DEFAULT_SORT_INDEX] ?? SORT_OPTIONS[0];
        const labelText = t(option.labelKey);
        const shortLabelText = option.shortKey ? t(option.shortKey) : labelText;
        if (sortSelection) {
          sortSelection.textContent = t('sortCurrent', { label: labelText });
        }
        if (sortGroup) {
          sortGroup.setAttribute('data-active-index', String(index));
        }
        sortButtons.forEach((button) => {
          const buttonIndex = Number.parseInt(button.getAttribute('data-sort-index'), 10);
          const isActive = buttonIndex === index;
          button.classList.toggle('is-active', isActive);
          button.setAttribute('aria-checked', isActive ? 'true' : 'false');
          button.tabIndex = isActive ? 0 : -1;
          if (isActive && sortGroup) {
            const buttonId = button.id || '';
            sortGroup.setAttribute('aria-activedescendant', buttonId);
            sortGroup.setAttribute('data-active-label', shortLabelText);
          }
        });
      }

      function setSortByIndex(index, { trigger = true } = {}) {
        const resolvedIndex = clampSortIndex(index);
        const option = SORT_OPTIONS[resolvedIndex] ?? SORT_OPTIONS[RESOLVED_DEFAULT_SORT_INDEX] ?? SORT_OPTIONS[0];
        state.sortBy = option.value;
        state.sortIndex = resolvedIndex;
        updateSortDisplay(resolvedIndex);
        if (trigger) {
          sortFiltered();
          renderItems();
          updateStatus();
        }
      }

      function createMetaRow(label, value) {
        const wrapper = document.createElement('div');
        wrapper.className = 'item-card__meta-entry';

        const labelSpan = document.createElement('span');
        labelSpan.className = 'item-card__meta-label';
        labelSpan.textContent = label;

        const valueSpan = document.createElement('span');
        valueSpan.className = 'item-card__meta-value';
        valueSpan.textContent = value;

        wrapper.appendChild(labelSpan);
        wrapper.appendChild(valueSpan);
        return wrapper;
      }

      function createItemCard(row, viewMode = state.viewMode, options = {}) {
        const { interactive = viewMode === 'compact', role = 'listitem' } = options;
        const card = document.createElement('article');
        card.className = `item-card item-card--${viewMode}`;
        card.setAttribute('role', role);
        if (row.__uid && role === 'listitem') {
          card.id = row.__uid;
        }
        card.tabIndex = -1;
        if (interactive) {
          card.dataset.interactive = 'true';
          card.tabIndex = 0;
          card.setAttribute('aria-haspopup', 'dialog');
          card.setAttribute('aria-expanded', 'false');
        }

        const media = document.createElement('div');
        media.className = 'item-card__media';

        const showPlaceholder = () => {
          media.innerHTML = '';
          const placeholder = document.createElement('div');
          placeholder.className = 'item-card__photo item-card__photo--placeholder';
          placeholder.textContent = t('photoUnavailable');
          media.appendChild(placeholder);
        };

        if (row.__photoUrl) {
          const altText = row.__name ? t('photoAltNamed', { name: row.__name }) : t('photoAltItem');
          const image = document.createElement('img');
          image.className = 'item-card__photo';
          image.loading = 'lazy';
          image.decoding = 'async';
          image.crossOrigin = 'anonymous';
          image.alt = altText;
          media.appendChild(image);

          const candidateUrls = buildPhotoCandidateUrls(row.__photoUrl);
          if (!candidateUrls.length) {
            image.src = row.__photoUrl;
          } else {
            const urls = [...candidateUrls];
            const tryNext = () => {
              const nextUrl = urls.shift();
              if (!nextUrl) {
                showPlaceholder();
                return;
              }

              loadImageWithTimeout(image, nextUrl, 5000)
                .catch(() => {
                  if (urls.length) {
                    setTimeout(tryNext, 100);
                  } else {
                    showPlaceholder();
                  }
                });
            };

            tryNext();
          }
        } else {
          showPlaceholder();
        }
        card.appendChild(media);

        const body = document.createElement('div');
        body.className = 'item-card__body';

        const header = document.createElement('div');
        header.className = 'item-card__header';

        const titleBlock = document.createElement('div');
        titleBlock.className = 'item-card__title';

        if (row.__sku) {
          const skuChip = document.createElement('span');
          skuChip.className = 'item-card__sku';
          skuChip.textContent = t('skuLabel', { value: row.__sku });
          titleBlock.appendChild(skuChip);
        }

        const title = document.createElement('h3');
        title.className = 'item-card__name';
        title.textContent = row.__name || t('itemDefaultName');
        titleBlock.appendChild(title);

        header.appendChild(titleBlock);

        const priceBlock = document.createElement('div');
        priceBlock.className = 'item-card__price';
        const priceLabel = document.createElement('span');
        if (row.__priceSource === 'sheet') {
          priceLabel.textContent = t('priceSheet');
        } else if (row.__priceSource === 'estimated') {
          priceLabel.textContent = t('priceEstimated');
        } else {
          priceLabel.textContent = t('priceNotAvailable');
        }
        const priceValue = document.createElement('strong');
        priceValue.textContent = formatPrice(row.__price, row.__priceFallback || t('priceNotAvailable'));
        priceBlock.appendChild(priceLabel);
        priceBlock.appendChild(priceValue);
        header.appendChild(priceBlock);

        body.appendChild(header);

        const metaList = document.createElement('div');
        metaList.className = 'item-card__meta';

        const primaryMeta = document.createElement('div');
        primaryMeta.className = 'item-card__meta-row';
        const weightDisplay = Number.isFinite(row.__weight)
          ? formatWeightDisplay(row.__weight)
          : '';
        const weightValue = weightDisplay || row.__weightRaw;
        if (weightValue) {
          primaryMeta.appendChild(createMetaRow(t('metaWeight'), weightValue));
        }
        if (row.__karat) {
          primaryMeta.appendChild(createMetaRow(t('metaKarat'), row.__karat));
        }
        if (row.__categoryRaw) {
          primaryMeta.appendChild(createMetaRow(t('metaCategory'), row.__categoryRaw));
        }
        metaList.appendChild(primaryMeta);

        if (viewMode === 'detailed') {
          const secondaryMeta = document.createElement('div');
          secondaryMeta.className = 'item-card__meta-row';
          if (row.__fees) {
            secondaryMeta.appendChild(createMetaRow(t('metaFees'), row.__fees));
          }
          const availabilityText = row.__availabilityState === 'available'
            ? t('filterAvailabilityAvailable')
            : row.__availabilityState === 'not-available'
              ? t('filterAvailabilityNotAvailable')
              : row.__availabilityRaw;
          if (availabilityText) {
            secondaryMeta.appendChild(createMetaRow(t('metaStatus'), availabilityText));
          }
          const perGramDisplay = Number.isFinite(row.__perGram)
            ? formatPerGram(row.__perGram)
            : '';
          if (perGramDisplay) {
            secondaryMeta.appendChild(createMetaRow(t('metaPerGram'), perGramDisplay));
          }
          if (secondaryMeta.childElementCount) {
            metaList.appendChild(secondaryMeta);
          }
        }

        body.appendChild(metaList);

        if (viewMode === 'detailed' && row.__description) {
          const description = document.createElement('p');
          description.className = 'item-card__description';
          description.textContent = row.__description;
          body.appendChild(description);
        }

        if (row.__badges.length) {
          const badgeRow = document.createElement('div');
          badgeRow.className = 'item-card__badge-row';
          for (const badge of row.__badges) {
            const span = document.createElement('span');
            span.className = 'chip';
            if (badge.type === 'availability') {
              span.textContent = badge.state === 'available'
                ? t('filterAvailabilityAvailable')
                : t('filterAvailabilityNotAvailable');
            } else if (badge.type === 'timestamp') {
              span.textContent = t('badgeUpdated', { value: badge.value });
            } else if (badge.value) {
              span.textContent = badge.value;
            }
            badgeRow.appendChild(span);
          }
          body.appendChild(badgeRow);
        }

        card.appendChild(body);

        if (interactive) {
          const handleClick = () => {
            openItemDetails(row, card);
          };

          const handleKeydown = (event) => {
            const key = event.key;
            if (key !== 'Enter' && key !== ' ') {
              return;
            }
            event.preventDefault();
            openItemDetails(row, card);
          };

          card.addEventListener('click', handleClick);
          card.addEventListener('keydown', handleKeydown);
        }

        return card;
      }

      function isItemDetailsOpen() {
        return Boolean(itemDetailsDialog && itemDetailsDialog.classList.contains('is-visible'));
      }

      function openItemDetails(row, triggerElement) {
        if (!itemDetailsDialog || !itemDetailsContainer) return;

        lastFocusedDetailsTrigger = triggerElement instanceof HTMLElement ? triggerElement : null;
        if (lastFocusedDetailsTrigger) {
          lastFocusedDetailsTrigger.setAttribute('aria-expanded', 'true');
        }

        lastOpenedDetailsRow = row;

        itemDetailsContainer.innerHTML = '';
        const detailCard = createItemCard(row, 'detailed', { interactive: false, role: 'article' });
        itemDetailsContainer.appendChild(detailCard);

        itemDetailsDialog.classList.add('is-visible');
        itemDetailsDialog.setAttribute('aria-hidden', 'false');
        document.body.classList.add('dialog-open');

        if (itemDetailsClose) {
          itemDetailsClose.focus();
        }
      }

      function closeItemDetails() {
        if (!itemDetailsDialog || !itemDetailsContainer) return;

        itemDetailsDialog.classList.remove('is-visible');
        itemDetailsDialog.setAttribute('aria-hidden', 'true');
        document.body.classList.remove('dialog-open');
        itemDetailsContainer.innerHTML = '';

        if (lastFocusedDetailsTrigger && document.body.contains(lastFocusedDetailsTrigger)) {
          lastFocusedDetailsTrigger.setAttribute('aria-expanded', 'false');
          lastFocusedDetailsTrigger.focus();
        }

        lastFocusedDetailsTrigger = null;
        lastOpenedDetailsRow = null;
      }

      if (itemDetailsDialog) {
        itemDetailsDialog.addEventListener('click', (event) => {
          if (event.target === itemDetailsDialog) {
            closeItemDetails();
          }
        });
      }

      if (itemDetailsClose) {
        itemDetailsClose.addEventListener('click', () => {
          closeItemDetails();
        });
      }

      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && isItemDetailsOpen()) {
          event.preventDefault();
          closeItemDetails();
        }
      });

      function renderItems() {
        if (!itemsGrid) return;
        itemsGrid.dataset.view = state.viewMode;

        if (!state.dataLoaded) {
          return;
        }

        if (highlightTimeout) {
          clearTimeout(highlightTimeout);
          highlightTimeout = null;
        }
        lastHighlightedCardId = null;

        itemsGrid.innerHTML = '';

        if (!state.filtered.length) {
          const empty = document.createElement('p');
          empty.className = 'empty-state';
          if (state.rows.length) {
            empty.dataset.emptyType = 'filters';
            empty.textContent = t('emptyFilters');
            uiState.emptyType = 'filters';
          } else {
            empty.dataset.emptyType = 'no-data';
            empty.textContent = t('emptyNoRows');
            uiState.emptyType = 'no-data';
          }
          itemsGrid.appendChild(empty);
          return;
        }

        uiState.emptyType = 'none';
        for (const row of state.filtered) {
          itemsGrid.appendChild(createItemCard(row));
        }
      }

      function parseRow(row) {
        const normalized = normalizeRowKeys(row);
        const priceInfo = computeItemPrice(normalized.weight, normalized.karat, normalized.fees, state.goldPrice);
        let priceValue = priceInfo?.total ?? NaN;
        let perGramValue = priceInfo?.perGram ?? NaN;
        let priceSource = 'estimated';
        let priceFallbackDisplay = '';
        const weightValue = extractNumber(normalized.weight);
        const weightRaw = normalized.weight ? sanitize(normalized.weight) : '';

        if (!Number.isFinite(priceValue)) {
          const fallback = findExistingPrice(normalized);
          if (fallback) {
            priceValue = fallback.numeric;
            priceFallbackDisplay = sanitize(fallback.display);
            priceSource = 'sheet';
          } else {
            priceSource = 'unknown';
          }
        }

        if (!Number.isFinite(perGramValue) && Number.isFinite(priceValue) && Number.isFinite(weightValue)) {
          if (weightValue) {
            perGramValue = priceValue / weightValue;
          }
        }

        const categoryKey = state.categoryKey;
        const categoryRaw = categoryKey ? normalized[categoryKey] : (normalized.category ?? normalized.type ?? '');
        const categoryNormalized = normalizeCategoryValue(categoryRaw);
        const availabilityDisplay = sanitize(normalized.availability ?? '');
        const availabilityState = normalizeAvailabilityState(availabilityDisplay);
        const timestamp = normalized.timestamp ? sanitize(normalized.timestamp) : '';

        const badges = [];
        if (availabilityState === 'available' || availabilityState === 'not-available') {
          badges.push({ type: 'availability', state: availabilityState });
        } else if (availabilityDisplay) {
          badges.push({ type: 'text', value: availabilityDisplay });
        }
        if (timestamp) {
          badges.push({ type: 'timestamp', value: timestamp });
        }

        const parsed = {
          ...normalized,
          __name: sanitize(normalized.name ?? normalized['piece type | نوع القطعة'] ?? ''),
          __sku: sanitize(normalized.sku ?? ''),
          __weight: Number.isFinite(weightValue) ? weightValue : NaN,
          __weightRaw: weightRaw,
          __karat: sanitize(normalized.karat ?? ''),
          __fees: sanitize(normalized.fees ?? ''),
          __description: sanitize(normalized.description ?? ''),
          __availabilityRaw: availabilityDisplay,
          __availabilityState: availabilityState,
          __categoryRaw: sanitize(categoryRaw ?? ''),
          __categoryNormalized: categoryNormalized,
          __price: Number.isFinite(priceValue) ? priceValue : NaN,
          __priceSource: priceSource,
          __priceFallback: priceFallbackDisplay,
          __perGram: Number.isFinite(perGramValue) ? perGramValue : NaN,
          __photoUrl: normalizePhotoUrl(normalized.photo),
          __badges: badges,
          __timestamp: timestamp
        };

        const searchTokens = [
          parsed.__sku,
          parsed.__name,
          parsed.__description,
          parsed.__categoryRaw,
          parsed.__availabilityRaw,
          parsed.__fees,
          parsed.__karat,
          Number.isFinite(parsed.__price) ? parsed.__price.toString() : '',
          parsed.__priceFallback,
          parsed.__timestamp,
          parsed.__weightRaw
        ]
          .filter(Boolean)
          .join(' ');
        parsed.__searchHaystack = normalizeDigits(searchTokens).toLowerCase();

        return parsed;
      }

      function enrichRows(rows) {
        state.rows = rows.map((row, index) => {
          const parsed = parseRow(row);
          parsed.__index = index;
          parsed.__uid = createItemUid(parsed, index);
          return parsed;
        });
        populateCategoryOptions(state.rows);
        state.dataLoaded = true;
        applyFilters();
      }

      async function fetchInventory() {
        const response = await fetch(INVENTORY_ENDPOINT, { credentials: 'include' });
        if (!response.ok) {
          throw new Error(`Inventory request failed (${response.status})`);
        }
        return response.json();
      }

      async function fetchGoldPrice() {
        try {
          const response = await fetch(GOLD_API, { cache: 'no-store' });
          if (!response.ok) {
            throw new Error(`Gold price request failed (${response.status})`);
          }
          const data = await response.json();
          const price = Number(data.price);
          if (Number.isFinite(price)) {
            state.goldPrice = price;
            state.goldUpdatedAt = data.updatedAtReadable || data.updatedAt || '';
          } else {
            state.goldPrice = null;
          }
        } catch (error) {
          console.warn('Gold price fetch failed:', error);
          state.goldPrice = null;
        }
      }

      function setSearchQuery(rawValue, { trigger = true } = {}) {
        const value = typeof rawValue === 'string' ? rawValue : '';
        const normalizedDigits = normalizeDigits(value);
        const trimmed = normalizedDigits.trim();
        state.searchQuery = value;
        state.searchQueryNormalized = trimmed.toLowerCase();
        state.searchActive = state.searchQueryNormalized.length >= 2;
        state.searchMatchCount = null;
        if (trigger) {
          applyFilters();
          if (!state.dataLoaded) {
            updateSearchResultsList();
          }
        }
      }

      function resetFilters() {
        categorySelect.value = '';
        availabilitySelect.value = '';
        priceMinInput.value = '';
        priceMaxInput.value = '';
        if (searchInput) {
          searchInput.value = '';
        }
        setSearchQuery('', { trigger: false });
        setSortByIndex(RESOLVED_DEFAULT_SORT_INDEX, { trigger: false });
        applyFilters();
      }

      function attachListeners() {
        if (languageToggle) {
          languageToggle.addEventListener('change', (event) => {
            applyLanguage(event.target.value);
          });
        }
        if (searchInput) {
          const debouncedSearch = debounce((value) => {
            setSearchQuery(value);
          }, 250);

          searchInput.addEventListener('input', (event) => {
            debouncedSearch(event.target.value);
          });

          searchInput.addEventListener('search', (event) => {
            setSearchQuery(event.target.value);
          });

          searchInput.addEventListener('focus', () => {
            if (state.searchActive) {
              updateSearchResultsList();
            }
          });
        }
        categorySelect.addEventListener('change', applyFilters);
        availabilitySelect.addEventListener('change', applyFilters);
        priceMinInput.addEventListener('input', applyFilters);
        priceMaxInput.addEventListener('input', applyFilters);
        resetFiltersBtn.addEventListener('click', resetFilters);
        if (sortButtons.length) {
          const findButtonByIndex = (targetIndex) =>
            sortButtons.find((button) => Number.parseInt(button.getAttribute('data-sort-index'), 10) === targetIndex);

          sortButtons.forEach((button) => {
            button.addEventListener('click', () => {
              setSortByIndex(button.getAttribute('data-sort-index'));
            });

            button.addEventListener('keydown', (event) => {
              const key = event.key;
              const currentIndex = clampSortIndex(button.getAttribute('data-sort-index'));
              let nextIndex = null;

              if (key === 'ArrowRight' || key === 'ArrowDown') {
                nextIndex = (currentIndex + 1) % SORT_OPTIONS.length;
              } else if (key === 'ArrowLeft' || key === 'ArrowUp') {
                nextIndex = (currentIndex - 1 + SORT_OPTIONS.length) % SORT_OPTIONS.length;
              } else if (key === 'Home') {
                nextIndex = 0;
              } else if (key === 'End') {
                nextIndex = SORT_OPTIONS.length - 1;
              }

              if (nextIndex !== null) {
                event.preventDefault();
                setSortByIndex(nextIndex);
                const targetButton = findButtonByIndex(nextIndex);
                if (targetButton) {
                  window.requestAnimationFrame(() => {
                    targetButton.focus();
                  });
                }
              }
            });
          });
        }
      }

      async function initialize() {
        attachListeners();
        if (searchInput && searchInput.value.trim()) {
          setSearchQuery(searchInput.value, { trigger: false });
        }
        updateSearchResultsList();
        if (sortButtons.length) {
          const activeButton = sortButtons.find((button) => button.classList.contains('is-active'));
          const startingIndex = activeButton?.getAttribute('data-sort-index') ?? RESOLVED_DEFAULT_SORT_INDEX;
          setSortByIndex(startingIndex, { trigger: false });
        } else {
          setSortByIndex(RESOLVED_DEFAULT_SORT_INDEX, { trigger: false });
        }
        uiState.statusMode = 'loading';
        uiState.total = 0;
        uiState.visible = 0;
        refreshStatusText();
        refreshGoldStatus();

        try {
          const [inventoryData] = await Promise.all([fetchInventory(), fetchGoldPrice()]);
          const rows = Array.isArray(inventoryData) ? inventoryData : [];
          state.categoryKey = detectCategoryKey(rows);
          enrichRows(rows);
          refreshGoldStatus();
        } catch (error) {
          console.error('Inventory load failed:', error);
          state.rows = [];
          state.filtered = [];
          state.dataLoaded = false;
          uiState.statusMode = 'error';
          uiState.total = 0;
          uiState.visible = 0;
          refreshStatusText();
          refreshResultsCount();
          updateSearchResultsList();
          if (itemsGrid) {
            itemsGrid.innerHTML = '';
            const empty = document.createElement('p');
            empty.className = 'empty-state';
            empty.dataset.emptyType = 'error';
            empty.textContent = t('errorEmpty');
            itemsGrid.appendChild(empty);
            uiState.emptyType = 'error';
            refreshEmptyMessage();
          }
          refreshGoldStatus();
          return;
        }

        updateStatus();
      }

      refreshLanguageDependentText();
      initialize();
    })();
  </script>
</body>
</html>
