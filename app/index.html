<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ghandour Juwellery • Smart Barcode Scanner</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Amiri&family=Inter:wght@400;500;600&family=Playfair+Display:wght@500;600;700&display=swap" rel="stylesheet">
  <!-- App icons / favicon (updated logo) -->
  <link rel="icon" type="image/jpeg" href="../assets/logo-website-test.jpg">
  <link rel="apple-touch-icon" href="../assets/logo-website-test.jpg">
  <link rel="manifest" href="../manifest.webmanifest">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#D4AF37">
  <meta
    http-equiv="Content-Security-Policy"
    content="default-src 'self'; script-src 'self' 'unsafe-inline' https://unpkg.com; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; img-src 'self' https: data:; connect-src 'self' https://api.gold-api.com; child-src 'self' https://drive.google.com https://*.googleusercontent.com; frame-src 'self' https://drive.google.com https://*.googleusercontent.com; object-src 'none'; base-uri 'self'; frame-ancestors 'self'"
  >
  <script>if (sessionStorage.getItem('authenticated') !== 'true') { window.location.replace('../index.html'); }</script>
  <style>
    :root {
      --pad: 18px;

      /* === Luxurious Gold Palette === */
      --gold-primary: #D4AF37;       /* Rich gold */
      --gold-secondary: #FFD700;     /* Bright gold */
      --gold-dark: #B8860B;          /* Dark gold/bronze */
      --gold-light: #F5E6B3;         /* Light gold/beige */
      --ivory: #F8F8FF;              /* Ivory/off-white */
      --charcoal: #2C2C2C;           /* Dark text */
      --warm-gray: #8B7D6B;          /* Warm gray for muted text */
      --accent-gold: #C9A227;        /* Accent gold */

      /* === App tokens derived from palette === */
      --bg: radial-gradient(circle at 10% 0%, rgba(212, 175, 55, 0.15) 0%, rgba(212, 175, 55, 0.05) 55%, #ffffff 100%);
      --glass: rgba(255, 255, 255, 0.92);
      --card-border: rgba(212, 175, 55, 0.3);
      --accent: var(--gold-primary);
      --accent-dark: var(--gold-dark);
      --gold: var(--gold-primary);
      --royal: #1f3a93;
      --text: var(--charcoal);
      --muted: var(--warm-gray);
      --shadow: 0 18px 40px -24px rgba(212, 175, 55, 0.35);
    }
    html {
      scroll-behavior: smooth;
    }
    * { box-sizing: border-box; }
    body {
      min-height: 100vh;
      margin: 0;
      font-family: 'Inter', system-ui, -apple-system, Segoe UI, sans-serif;
      color: var(--text);
      background: var(--bg);
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: calc(var(--pad) * 1.2) var(--pad) calc(var(--pad) * 1.6);
    }
    .bismillah {
      margin: 0 0 clamp(10px, 2vw, 18px);
      font-family: 'Amiri', 'Scheherazade New', serif;
      font-size: clamp(1.1rem, 2.6vw, 1.35rem);
      color: var(--accent-dark);
      letter-spacing: 0.02em;
      text-align: center;
      align-self: center;
      direction: rtl;
      font-weight: 600;
    }
    .page {
      width: min(1100px, 100%);
      display: flex;
      flex-direction: column;
      gap: clamp(18px, 3vw, 28px);
    }
    .header-top {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }
    .page-nav {
      position: relative;
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 999px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.92), rgba(255, 253, 245, 0.78));
      border: 1px solid rgba(212, 175, 55, 0.25);
      box-shadow: 0 18px 32px -22px rgba(212, 175, 55, 0.45);
      max-width: 100%;
      overflow-x: auto;
      overflow-y: hidden;
      scroll-snap-type: x proximity;
      -webkit-overflow-scrolling: touch;
      scrollbar-width: none;
      backdrop-filter: blur(12px);
    }
    .page-nav::-webkit-scrollbar { display: none; }
    .nav-link {
      flex: 0 0 auto;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 10px 18px;
      border-radius: 999px;
      font-weight: 600;
      font-size: 0.95rem;
      color: var(--accent-dark);
      text-decoration: none;
      transition: transform 0.2s ease, background 0.2s ease, box-shadow 0.2s ease, color 0.2s ease;
      background: rgba(255, 255, 255, 0.82);
      scroll-snap-align: center;
      min-width: max-content;
      box-shadow: inset 0 0 0 1px rgba(212, 175, 55, 0.12);
    }
    .nav-link:hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 24px -18px rgba(212, 175, 55, 0.45);
    }
    .nav-link:focus-visible {
      outline: 2px solid rgba(212, 175, 55, 0.55);
      outline-offset: 2px;
    }
    .nav-link:active {
      transform: scale(0.98);
    }
    .nav-link.active {
      background: linear-gradient(135deg, var(--gold-primary), var(--gold-dark));
      color: #fff;
      box-shadow: 0 14px 30px -18px rgba(212, 175, 55, 0.6);
    }
    header {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .brand-logo {
      height: 56px;
      width: auto;
      object-fit: contain;
      filter: drop-shadow(0 6px 16px rgba(212, 175, 55, 0.25));
    }
    .hero-title {
      margin: 0;
      font-family: 'Playfair Display', 'Times New Roman', serif;
      font-size: clamp(1.6rem, 3.8vw, 2.4rem);
      letter-spacing: 0.02em;
      color: var(--text);
    }
    .hero-subtitle {
      margin: 0;
      font-size: clamp(0.95rem, 2vw, 1.05rem);
      color: var(--muted);
      max-width: 520px;
    }
    .badge-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .badge-row .chip {
      background: rgba(255, 253, 245, 0.8);
      border: 1px solid rgba(212, 175, 55, 0.25);
      box-shadow: var(--shadow);
    }
    .muted { color: var(--muted); }
    a, .item-card-link { color: var(--accent-dark); }

    .permission-hint ul {
      margin: 8px 0 0;
      padding-left: 20px;
    }

    .permission-hint li {
      margin-bottom: 4px;
      line-height: 1.45;
    }

    .glass-card {
      background: rgba(255, 255, 255, 0.92);
      border: 1px solid rgba(255, 255, 255, 0.6);
      border-radius: 28px;
      padding: clamp(20px, 4vw, 32px);
      box-shadow:
        0 20px 40px -24px rgba(28, 30, 43, 0.25),
        inset 0 1px 1px rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(20px);
      position: relative;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }

    .glass-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 28px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.4), transparent);
      pointer-events: none;
    }

    .glass-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 25px 50px -12px rgba(212, 175, 55, 0.4);
    }

    .content-grid {
      display: grid;
      grid-template-columns: minmax(0, 2fr) minmax(0, 1fr);
      gap: clamp(18px, 3vw, 32px);
      align-items: start;
    }
    
    .scanner-panel {
      display: flex;
      flex-direction: column;
      gap: 18px;
      position: relative;
    }
    #preview {
      width: 100%;
      max-width: 560px;
      border-radius: 22px;
      background: #000;
      box-shadow: 0 18px 40px -20px rgba(212, 175, 55, 0.4);
      border: 1px solid rgba(255, 255, 255, 0.2);
      aspect-ratio: 3 / 2;
      object-fit: cover;
      transition: all 0.3s ease;
    }

    #preview.scanning {
      box-shadow: 0 0 30px rgba(212, 175, 55, 0.6);
      border: 2px solid var(--gold-primary);
    }

    .scanner-status {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 4px 8px;
      border-radius: 8px;
      font-size: 0.8rem;
      z-index: 10;
    }
    #hud {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }
    select, button, input {
      font-family: inherit;
      border-radius: 14px;
      border: 1px solid rgba(212, 175, 55, 0.25); /* gold tone */
      padding: 12px 14px;
      font-size: 0.98rem;
      background: rgba(255, 255, 255, 0.92);
      box-shadow: inset 0 1px 1px rgba(255, 255, 255, 0.4);
      transition: transform 120ms ease, box-shadow 200ms ease, border-color 160ms ease;
    }
    select:focus, button:focus, input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(212, 175, 55, 0.25);
    }
    button:focus-visible,
    input:focus-visible,
    select:focus-visible {
      outline: 2px solid var(--gold-primary);
      outline-offset: 2px;
    }
    button {
      background: linear-gradient(135deg, var(--gold-primary), var(--gold-dark));
      color: #fff;
      border: none;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 14px 32px -18px rgba(212, 175, 55, 0.45);
    }
    button:disabled {
      cursor: not-allowed;
      opacity: 0.65;
      background: rgba(212, 175, 55, 0.35);
      box-shadow: none;
    }
    button:not(:disabled):hover { transform: translateY(-1px); }

    .action-success {
      background: linear-gradient(135deg, #1a8f55, #147a45) !important;
    }

    .action-error {
      background: linear-gradient(135deg, #d84a63, #c13a52) !important;
    }

    @keyframes pulse-gold {
      0% { box-shadow: 0 0 0 0 rgba(212, 175, 55, 0.7); }
      70% { box-shadow: 0 0 0 10px rgba(212, 175, 55, 0); }
      100% { box-shadow: 0 0 0 0 rgba(212, 175, 55, 0); }
    }

    .pulse {
      animation: pulse-gold 2s infinite;
    }

    #result {
      font-size: 1.05rem;
      min-height: 1.2em;
      display: inline-block;
      padding: 6px 12px;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.72);
      border: 1px solid rgba(255, 255, 255, 0.45);
    }
    #hint { color: var(--muted); font-size: 0.95rem; }

    #manualForm { margin-top: 8px; }
    #manualEntry {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }
    #manualEntry label {
      font-weight: 600;
      font-size: 0.95rem;
      font-family: 'Playfair Display', serif;
    }
    #manualEntry input {
      width: 160px;
    }

    #goldPriceForm {
      margin-top: 12px;
      display: grid;
      gap: 6px;
    }
    #goldPriceEntry {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }
    #goldPriceEntry label {
      font-weight: 600;
      font-size: 0.95rem;
      font-family: 'Playfair Display', serif;
    }
    #goldPriceEntry input {
      width: 160px;
    }
    #goldPriceStatus {
      color: var(--muted);
      font-size: 0.9rem;
    }
    #goldPriceClear {
      background: rgba(255, 255, 255, 0.92);
      border: 1px solid rgba(212, 175, 55, 0.25);
      color: var(--accent-dark);
      box-shadow: none;
      font-weight: 500;
    }

    .gold-price-suggestions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      font-size: 0.9rem;
      color: var(--muted);
    }

    .gold-price-suggestions span {
      font-weight: 500;
    }

    .gold-price-suggestions button {
      background: rgba(255, 253, 245, 0.9);
      border: 1px solid rgba(212, 175, 55, 0.25);
      color: var(--accent-dark);
      box-shadow: none;
      padding: 8px 12px;
      font-size: 0.88rem;
    }

    .gold-price-suggestions button:disabled {
      opacity: 0.6;
    }

    .hardware-card {
      display: grid;
      gap: 12px;
      padding: 18px;
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.5);
      background: rgba(255, 255, 255, 0.85);
      box-shadow: 0 22px 40px -24px rgba(212, 175, 55, 0.25);
    }
    .hardware-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }
    .hardware-header h3 {
      margin: 0;
      font-family: 'Playfair Display', serif;
      font-size: 1.2rem;
      letter-spacing: 0.02em;
    }
    .hardware-toggle {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 0.95rem;
      color: var(--muted);
    }
    .hardware-toggle input {
      margin: 0;
      width: auto;
    }
    .hardware-input {
      display: grid;
      gap: 8px;
    }
    .hardware-input label {
      font-weight: 600;
      font-size: 0.95rem;
    }
    #hardwareField {
      font-size: 1.05rem;
      letter-spacing: 0.04em;
    }
    #hardwareClear {
      width: fit-content;
    }
    #hardwareStatus {
      font-size: 0.95rem;
      color: var(--muted);
    }
    .hardware-log {
      list-style: none;
      padding: 0;
      margin: 0;
      display: grid;
      gap: 8px;
    }
    .hardware-log li {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 12px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(212, 175, 55, 0.18);
      background: rgba(212, 175, 55, 0.08);
      font-size: 0.95rem;
    }
    .hardware-log code {
      font-family: 'Inter', monospace;
      font-weight: 600;
      color: var(--accent-dark);
      background: rgba(255, 255, 255, 0.6);
      padding: 2px 6px;
      border-radius: 8px;
    }
    .hardware-log time {
      font-size: 0.85rem;
      color: var(--muted);
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 14px;
      border: 1px solid rgba(212, 175, 55, 0.25);
      border-radius: 999px;
      font-size: 0.85rem;
      letter-spacing: 0.02em;
      color: var(--gold-dark);
      background: rgba(255, 253, 245, 0.8);
    }
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      border: 0;
    }

    footer {
      grid-column: 1 / -1;
      margin-top: clamp(20px, 4vw, 38px);
      color: var(--muted);
      font-size: 0.9rem;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .contact-row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }

    .contact-row strong {
      color: var(--text);
    }

    .contact-action {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 10px 16px;
      border-radius: 999px;
      background: linear-gradient(135deg, var(--gold-primary), var(--gold-dark));
      color: #fff;
      text-decoration: none;
      font-weight: 600;
      box-shadow: 0 12px 28px -18px rgba(212, 175, 55, 0.45);
      transition: transform 150ms ease, box-shadow 150ms ease;
    }

    .contact-action:hover {
      transform: translateY(-1px);
      box-shadow: 0 16px 32px -18px rgba(212, 175, 55, 0.55);
    }

    .ok { color: #1a8f55; }
    .err { color: #d84a63; }

    #result.flash { animation: flash 420ms ease-out; }
    @keyframes flash { from { background: rgba(255, 244, 164, 0.9); } to { background: rgba(255, 255, 255, 0.72); } }

    .results-panel {
      display: flex;
      flex-direction: column;
      gap: 18px;
      min-height: 100%;
    }
    .search-container {
      display: grid;
      gap: 10px;
    }
    .search-container input {
      width: 100%;
      border-radius: 16px;
      padding: 14px 18px;
      font-size: 1rem;
      background: rgba(255, 255, 255, 0.9);
      border: 1.5px solid rgba(28, 30, 43, 0.1);
      transition: all 0.3s ease;
    }

    .search-container input:focus {
      border-color: var(--gold);
      box-shadow: 0 0 0 3px rgba(212, 175, 55, 0.15);
      background: rgba(255, 255, 255, 0.95);
    }
    .search-container label {
      font-weight: 600;
      font-size: 0.9rem;
      color: var(--muted);
    }
    .category-browser {
      display: grid;
      gap: 12px;
    }

    .browser-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
    }

    .browser-header label {
      font-weight: 600;
      font-size: 0.95rem;
      color: var(--accent-dark);
      margin: 0;
    }

    .browser-controls {
      display: flex;
      gap: 4px;
    }

    .browser-nav {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 1px solid var(--card-border);
      background: var(--glass);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s ease;
      padding: 0;
    }

    .browser-nav:hover:not(:disabled) {
      background: var(--gold);
      border-color: var(--gold);
      color: white;
      transform: translateY(-1px);
    }

    .browser-nav:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .browser-nav svg {
      display: block;
    }

    .category-scroll-container {
      position: relative;
      overflow: hidden;
    }

    .category-chips {
      display: flex;
      gap: 8px;
      overflow-x: auto;
      scroll-behavior: smooth;
      padding: 4px 2px 12px;
      scrollbar-width: none;
      -ms-overflow-style: none;
    }

    .category-chips::-webkit-scrollbar {
      display: none;
    }

    .category-chip {
      flex-shrink: 0;
      padding: 10px 18px;
      border-radius: 20px;
      border: 1px solid var(--card-border);
      background: rgba(255, 255, 255, 0.7);
      color: var(--text);
      font-size: 0.9rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      white-space: nowrap;
      position: relative;
      overflow: hidden;
    }

    .category-chip::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
      transition: left 0.5s ease;
    }

    .category-chip:hover::before {
      left: 100%;
    }

    .category-chip:hover {
      background: rgba(212, 175, 55, 0.1);
      border-color: var(--gold);
      transform: translateY(-2px);
      box-shadow: 0 8px 20px -8px rgba(212, 175, 55, 0.3);
    }

    .category-chip.active {
      background: linear-gradient(135deg, var(--gold), var(--royal));
      color: white;
      border-color: transparent;
      box-shadow: 0 8px 20px -8px rgba(212, 175, 55, 0.5);
    }

    .category-chip.active::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.2), transparent);
      border-radius: 20px;
    }

    .category-hint {
      font-size: 0.85rem;
      color: var(--muted);
      margin: 0;
      text-align: center;
      padding: 8px 0;
      border-top: 1px solid rgba(218, 214, 208, 0.3);
    }
    .category-results-title {
      font-weight: 600;
      font-size: 0.9rem;
      color: var(--accent-dark);
    }
    .search-results {
      border: 1px solid var(--card-border);
      border-radius: 18px;
      background: rgba(255, 255, 255, 0.78);
      box-shadow: var(--shadow);
      padding: 12px;
    }
    .search-results[hidden] {
      display: none;
    }

    /* Category results grid layout */
    .category-results-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 12px;
      margin-top: 12px;
    }

    /* Enhanced search result with image */
    .search-result.with-image {
      display: flex;
      padding: 12px;
      height: auto;
      min-height: 80px;
      text-align: left;
      background: rgba(255, 255, 255, 0.85);
      border: 1px solid rgba(212, 175, 55, 0.2);
      border-radius: 16px;
      transition: all 0.2s ease;
    }

    .search-result.with-image:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px -8px rgba(212, 175, 55, 0.3);
      border-color: rgba(212, 175, 55, 0.4);
    }

    .search-result-content {
      display: flex;
      align-items: center;
      gap: 12px;
      width: 100%;
    }

    .search-result-text {
      flex: 1;
      min-width: 0; /* Allow text to shrink */
    }

    .search-result-image {
      position: relative;
      flex-shrink: 0;
      width: 60px;
      height: 60px;
      border-radius: 10px;
      overflow: hidden;
      border: 1px solid rgba(212, 175, 55, 0.2);
      background: #f8f8f8;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--warm-gray);
      font-size: 0.7rem;
    }

    .search-result-image.loading::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 20px;
      height: 20px;
      border: 2px solid rgba(212, 175, 55, 0.3);
      border-top: 2px solid var(--gold-primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: translate(-50%, -50%) rotate(0deg); }
      100% { transform: translate(-50%, -50%) rotate(360deg); }
    }

    .search-result-image.no-image {
      background: linear-gradient(135deg, rgba(212, 175, 55, 0.1), rgba(184, 134, 11, 0.05));
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 4px;
    }

    .search-result-image.no-image::before {
      content: '\1F4F7';
      font-size: 1.2rem;
    }

    .search-result-image img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transition: transform 0.2s ease;
      display: block;
    }

    .search-result.with-image:hover .search-result-image img {
      transform: scale(1.05);
    }

    /* Update existing search result styles to accommodate images */
    .search-results button.search-result {
      display: flex;
      gap: 12px;
      align-items: center;
      text-align: left;
      padding: 12px;
      background: rgba(255, 255, 255, 0.85);
      border: 1px solid rgba(212, 175, 55, 0.2);
      color: var(--text);
      font-weight: 500;
      box-shadow: none;
      border-radius: 16px;
    }

    .search-result-title {
      font-size: 0.95rem;
      font-weight: 600;
      color: var(--text);
      display: block;
      margin-bottom: 4px;
      line-height: 1.3;
    }

    .search-result-meta {
      font-size: 0.8rem;
      color: var(--muted);
      line-height: 1.4;
    }

    /* Responsive adjustments */
    @media (max-width: 480px) {
      .hero-title {
        font-size: 1.8rem;
      }

      .hero-subtitle {
        font-size: 0.9rem;
      }

      #hud {
        justify-content: center;
      }

      #hud select,
      #hud button {
        flex: 1;
        min-width: 0;
        font-size: 0.9rem;
        padding: 10px 12px;
      }

      .contact-row {
        flex-direction: column;
        align-items: center;
        text-align: center;
      }

      .category-results-grid {
        grid-template-columns: 1fr;
      }

      .search-result-content {
        gap: 10px;
      }

      .search-result-image {
        width: 50px;
        height: 50px;
      }

      .search-result-title {
        font-size: 0.9rem;
      }

      .search-result-meta {
        font-size: 0.75rem;
      }
    }

    @media (min-width: 768px) {
      .category-results-grid {
        grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
      }
    }
    .search-empty, .results-placeholder {
      text-align: center;
      padding: 40px 20px;
      color: var(--warm-gray);
      font-style: italic;
      background: rgba(212, 175, 55, 0.05);
      border-radius: 16px;
      border: 2px dashed rgba(212, 175, 55, 0.2);
    }
    .results-panel h2 {
      margin: 0;
      font-family: 'Playfair Display', serif;
      font-size: clamp(1.3rem, 2.6vw, 1.8rem);
    }
    .search-empty::before {
      content: '\1F50D';
      display: block;
      font-size: 2rem;
      margin-bottom: 10px;
      opacity: 0.6;
    }
    #itemCard {
      display: none;
      padding: clamp(18px, 3vw, 26px);
      border-radius: 24px;
      border: 1px solid rgba(255, 255, 255, 0.55);
      background: rgba(255, 255, 255, 0.82);
      box-shadow: 0 26px 48px -24px rgba(212, 175, 55, 0.35);
      gap: clamp(16px, 2.6vw, 30px);
    }
    #itemCard h3 {
      margin: 0;
      font-family: 'Playfair Display', serif;
      letter-spacing: 0.015em;
      font-size: clamp(1.6rem, 3vw, 2.2rem);
      line-height: 1.2;
    }
    #itemCard img {
      width: min(100%, 420px);
      height: auto;
      border-radius: 20px;
      box-shadow: 0 26px 48px -24px rgba(212, 175, 55, 0.4);
      margin: 0 auto;
      object-fit: contain;
      display: block;
    }
    #itemCard:focus {
      outline: 2px solid var(--gold-primary);
      outline-offset: 4px;
    }
    .item-card-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: clamp(18px, 4vw, 42px);
      align-items: start;
    }
    .item-card-media {
      display: flex;
      justify-content: center;
      align-items: flex-start;
    }
    .item-card-media iframe {
      border-radius: 20px;
      box-shadow: 0 26px 48px -24px rgba(212, 175, 55, 0.4);
      border: 0;
      width: min(100%, 420px);
      min-height: 260px;
    }
    .item-card-copy {
      font-size: clamp(1.05rem, 2vw, 1.18rem);
      line-height: 1.65;
    }
    .item-card-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 14px;
      border-radius: 999px;
      background: rgba(212, 175, 55, 0.12);
      border: 1px solid rgba(212, 175, 55, 0.35);
      color: var(--gold-dark);
      font-weight: 600;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      font-size: 0.78rem;
      margin-bottom: 14px;
    }
    .item-card-meta {
      display: grid;
      gap: 12px;
    }
    .item-card-meta strong {
      color: var(--text);
      font-weight: 600;
    }
    .item-card-description {
      background: rgba(255, 255, 255, 0.7);
      border-radius: 18px;
      padding: 14px 18px;
      line-height: 1.7;
    }
    .item-card-price {
      margin-top: 4px;
      padding: 16px 18px;
      border-radius: 18px;
      background: linear-gradient(135deg, rgba(212, 175, 55, 0.14), rgba(184, 134, 11, 0.18));
      border: 1px solid rgba(212, 175, 55, 0.28);
      box-shadow: 0 18px 32px -24px rgba(212, 175, 55, 0.35);
    }
    .item-card-price strong {
      font-size: clamp(1.15rem, 2.2vw, 1.35rem);
    }
    .item-card-price .muted {
      margin-top: 6px;
      font-size: 0.95rem;
    }
    .history-card {
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.5);
      background: rgba(255, 255, 255, 0.85);
      box-shadow: 0 22px 40px -24px rgba(212, 175, 55, 0.25);
      padding: 18px;
      display: grid;
      gap: 12px;
    }
    .history-card[hidden] {
      display: none;
    }
    .history-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }
    .history-header h3 {
      margin: 0;
      font-family: 'Playfair Display', serif;
      font-size: 1.05rem;
    }
    #clearHistoryBtn {
      background: rgba(255, 255, 255, 0.92);
      border: 1px solid rgba(212, 175, 55, 0.25);
      color: var(--accent-dark);
      box-shadow: none;
      font-weight: 500;
    }
    #clearHistoryBtn:hover {
      transform: translateY(-1px);
    }
    .history-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 8px;
    }
    .history-item {
      background: rgba(212, 175, 55, 0.08);
      border: 1px solid rgba(212, 175, 55, 0.18);
      border-radius: 14px;
      padding: 10px 12px;
      display: grid;
      gap: 4px;
      text-align: left;
      color: var(--text);
      font-weight: 500;
      box-shadow: none;
    }
    .history-item:hover {
      transform: translateY(-1px);
    }
    .history-item-primary {
      font-size: 0.96rem;
    }
    .history-item-meta {
      font-size: 0.8rem;
      color: var(--muted);
    }
    .toast-container {
      position: fixed;
      top: 20px;
      right: 20px;
      display: grid;
      gap: 10px;
      z-index: 1000;
    }
    .toast {
      min-width: 220px;
      padding: 12px 16px;
      border-radius: 12px;
      color: #fff;
      font-weight: 500;
      box-shadow: var(--shadow);
      transform: translateX(120%);
      transition: transform 0.3s ease;
    }
    .toast.visible {
      transform: translateX(0);
    }
    .toast-info { background: var(--accent); }
    .toast-success { background: #1a8f55; }
    .toast-error { background: #d84a63; }
    .item-card-link {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      margin-top: 12px;
      font-weight: 600;
      color: var(--accent);
      text-decoration: none;
    }
    .item-card-link::after {
      content: '↗';
      font-size: 0.85em;
    }
    @media (max-width: 720px) {
      #itemCard {
        text-align: center;
      }
      .item-card-copy {
        font-size: 1rem;
      }
      .item-card-price {
        text-align: left;
      }
      .toast-container {
        left: 50%;
        right: auto;
        transform: translateX(-50%);
      }
    }

    @media (max-width: 960px) {
      .content-grid {
        grid-template-columns: 1fr;
      }
      .results-panel {
        order: 2;
      }
    }

    @media (max-width: 720px) {
      body { padding-top: 60px; }
      header { text-align: center; align-items: center; }
      .header-top {
        width: 100%;
        display: grid;
        justify-items: center;
      }
      .page-nav {
        width: 100%;
        justify-content: flex-start;
      }
      .brand-logo { height: 46px; }
      .badge-row { justify-content: center; }
      footer { text-align: center; align-items: center; }
    }
  </style>

  <!-- ZXing UMD build (fallback engine) -->
  <script id="zxing-script" src="https://unpkg.com/@zxing/browser@latest"></script>
</head>
<body>
  <!-- Authenticated application -->
  <div class="page" id="mainContent">
    <p class="bismillah" lang="ar" dir="rtl">بِسْمِ اللَّـهِ الرَّحْمَـٰنِ الرَّحِيمِ</p>
    <header>
      <div class="header-top">
        <img src="../assets/logo-website-test.jpg" alt="Test Barcode Website logo" class="brand-logo" />
        <nav class="page-nav" aria-label="Workspace navigation">
          <a class="nav-link active" href="./index.html" aria-current="page">Scanner</a>
          <a class="nav-link" href="./items.html">Inventory</a>
          <a class="nav-link" href="./sales.html">Sales log</a>
          <a class="nav-link" href="./purchases.html">Purchase log</a>
          <a class="nav-link" href="./statement.html">Gold statement</a>
        </nav>
      </div>
      <div class="badge-row">
        <span class="chip">Ghandour Juwellery</span>
      </div>
      <h1 class="hero-title">Instant barcode console</h1>
      <p class="hero-subtitle">Scan a piece to pull up its story, photos, and live valuation without scrolling.</p>
      <div id="support" class="muted">Initializing…</div>
    </header>

    <div class="content-grid">
      <section class="glass-card results-panel" aria-label="Item details">
        <h2>Item details</h2>
        <div class="search-container">
          <label class="sr-only" for="searchInput">Search inventory</label>
          <input
            type="search"
            id="searchInput"
            name="search"
            placeholder="Search items by name, SKU, or description…"
            autocomplete="off"
            spellcheck="false"
          />
          <div id="searchResults" class="search-results" hidden aria-live="polite"></div>
        </div>
        <div id="categorySection" class="category-browser" hidden>
          <div class="browser-header">
            <label for="categorySelect">Browse by collection</label>
            <div class="browser-controls">
              <button type="button" id="categoryPrev" class="browser-nav" disabled aria-label="Previous categories">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M15 18l-6-6 6-6" />
                </svg>
              </button>
              <button type="button" id="categoryNext" class="browser-nav" disabled aria-label="Next categories">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M9 18l6-6-6-6" />
                </svg>
              </button>
            </div>
          </div>

          <div class="category-scroll-container">
            <div class="category-chips" id="categoryChips" role="tablist" aria-label="Product categories">
              <!-- Chips will be dynamically added here -->
            </div>
          </div>

          <div id="categoryResults" class="search-results category-results" hidden aria-live="polite"></div>
        </div>
        <div id="itemPlaceholder" class="results-placeholder">Scan or enter a SKU to see the item information here.</div>
        <div id="itemCard" tabindex="-1"></div>
        <div id="historyCard" class="history-card" hidden>
          <div class="history-header">
            <h3>Recent scans</h3>
            <button type="button" id="clearHistoryBtn">Clear</button>
          </div>
          <ul id="scanHistoryList" class="history-list"></ul>
        </div>
      </section>

      <section class="glass-card scanner-panel" aria-label="Live barcode scanner">
      <video id="preview" playsinline muted></video>

      <div id="hud" aria-label="Camera controls">
        <select id="cameraSelect" aria-label="Camera" disabled></select>
        <button id="startBtn" disabled>Start</button>
        <button id="stopBtn" disabled>Stop</button>
        <button id="switchBtn" disabled>Switch</button>
        <button id="torchBtn" disabled>Toggle torch</button>
      </div>

      <div>
        <div id="result">No barcode yet…</div>
        <div id="hint">Tip: Serve over HTTPS. On iPhone, allow camera; hold 15–25 cm away; keep the code flat; use Torch.</div>
      </div>

      <form id="manualForm" aria-label="Manual barcode entry">
        <div id="manualEntry">
          <label for="manualInput">Manual entry:</label>
          <input
            type="number"
            id="manualInput"
            name="manualInput"
            min="100000"
            max="399999"
            inputmode="numeric"
            placeholder="100001"
            required
          />
          <button type="submit">Lookup</button>
        </div>
      </form>

      <form id="goldPriceForm" aria-label="Gold price override">
        <div id="goldPriceEntry">
          <label for="goldPriceInput">Gold price override:</label>
          <input
            type="number"
            id="goldPriceInput"
            name="goldPriceInput"
            min="0"
            step="0.01"
            inputmode="decimal"
            placeholder="2300"
          />
          <button type="submit">Apply</button>
          <button type="button" id="goldPriceClear">Use live price</button>
        </div>
        <div id="goldPriceStatus" class="muted">Using live price…</div>
        <div class="gold-price-suggestions" role="group" aria-label="Quick gold price suggestions">
          <span>Quick add:</span>
          <button type="button" data-gold-suggestion="30">Live + 30</button>
          <button type="button" data-gold-suggestion="50">Live + 50</button>
          <button type="button" data-gold-suggestion="70">Live + 70</button>
          <button type="button" data-gold-suggestion="100">Live + 100</button>
        </div>
      </form>

      <div class="hardware-card" aria-label="Bluetooth scanner capture">
        <div class="hardware-header">
          <h3>Bluetooth scanner capture</h3>
          <label class="hardware-toggle">
            <input type="checkbox" id="hardwareToggle" checked />
            Enable capture
          </label>
        </div>
        <p class="muted" style="margin: 0;">
          Pair your handheld laser scanner with this device. Most scanners behave like a keyboard: keep the capture field focused
          and each trigger will type the barcode followed by Enter. The app will look up the item instantly.
        </p>
        <div class="hardware-input">
          <label for="hardwareField">Scanner input field</label>
          <input
            id="hardwareField"
            type="text"
            inputmode="none"
            autocomplete="off"
            spellcheck="false"
            placeholder="Ready to scan…"
            aria-describedby="hardwareStatus"
          />
          <button type="button" id="hardwareClear">Clear history</button>
        </div>
        <div id="hardwareStatus">Awaiting scan…</div>
        <ul id="hardwareLog" class="hardware-log" aria-live="polite" aria-label="Recent scans"></ul>
      </div>
      </section>
    </div>

    <footer>
      <div class="badge-row">
        <span class="chip" id="engineChip">Engine: —</span>
        <span class="chip">HTTPS required</span>
        <span class="chip">iOS & Android</span>
        <span class="chip">Code128, EAN/UPC, Code39, ITF, QR</span>
      </div>
      <div class="contact-row">
        <span>Need help staging a private showing? Contact our concierge team at <strong>ajouni178@gmail.com</strong>.</span>
        <a class="contact-action" id="whatsAppLink" href="https://wa.me/" target="_blank" rel="noopener">WhatsApp us</a>
      </div>
    </footer>
  </div>

<script>



(function () {
  const video = document.getElementById('preview');
  const cameraSelect = document.getElementById('cameraSelect');
  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  const switchBtn = document.getElementById('switchBtn');
  const torchBtn = document.getElementById('torchBtn');
  const resultEl = document.getElementById('result');
  const supportEl = document.getElementById('support');
  const engineChip = document.getElementById('engineChip');
  const itemCard = document.getElementById('itemCard');
  const itemPlaceholder = document.getElementById('itemPlaceholder');
  const manualForm = document.getElementById('manualForm');
  const manualInput = document.getElementById('manualInput');
  const goldPriceForm = document.getElementById('goldPriceForm');
  const goldPriceInput = document.getElementById('goldPriceInput');
  const goldPriceClear = document.getElementById('goldPriceClear');
  const goldPriceStatus = document.getElementById('goldPriceStatus');
  const goldSuggestionButtons = Array.from(document.querySelectorAll('[data-gold-suggestion]'));
  const searchInput = document.getElementById('searchInput');
  const searchResultsEl = document.getElementById('searchResults');
  const categorySection = document.getElementById('categorySection');
  const categoryHint = document.getElementById('categoryHint');
  const categoryResultsEl = document.getElementById('categoryResults');
  const historyCard = document.getElementById('historyCard');
  const historyList = document.getElementById('scanHistoryList');
  const clearHistoryBtn = document.getElementById('clearHistoryBtn');
  const hardwareToggle = document.getElementById('hardwareToggle');
  const hardwareField = document.getElementById('hardwareField');
  const hardwareStatus = document.getElementById('hardwareStatus');
  const hardwareLog = document.getElementById('hardwareLog');
  const hardwareClear = document.getElementById('hardwareClear');
  const hardwareCard = document.querySelector('.hardware-card');
  const whatsAppLink = document.getElementById('whatsAppLink');

  const DEFAULT_CONFIG = {
    authEndpoint: '/api/auth',
    inventoryEndpoint: '/api/inventory',
    salesEndpoint: '/api/sales',
    whatsappNumber: '393481651384',
    goldPriceUrl: 'https://api.gold-api.com/price/XAU'
  };

  const APP_CONFIG = Object.freeze({
    ...DEFAULT_CONFIG,
    ...(window.APP_CONFIG && typeof window.APP_CONFIG === 'object' ? window.APP_CONFIG : {})
  });

  const AUTH_ENDPOINT = APP_CONFIG.authEndpoint;
  const INVENTORY_ENDPOINT = APP_CONFIG.inventoryEndpoint;
  const SALES_ENDPOINT = APP_CONFIG.salesEndpoint;
  const GOLD_API = APP_CONFIG.goldPriceUrl;

  if (whatsAppLink) {
    const rawNumber = String(APP_CONFIG.whatsappNumber ?? '').replace(/[^\d]/g, '');
    if (rawNumber) {
      whatsAppLink.href = `https://wa.me/${rawNumber}`;
    } else {
      whatsAppLink.href = 'https://wa.me/';
    }
  }

  const HARDWARE_HISTORY_LIMIT = 8;
  const HARDWARE_AUTO_COMMIT_MS = 160;
  const SCAN_HISTORY_KEY = 'scan_history_v1';
  const MAX_HISTORY = 50;
  const HISTORY_DISPLAY_LIMIT = 10;
  const CACHE_KEY = 'inventory_cache_v1';
  const CACHE_TTL = 5 * 60 * 1000;
  const TOAST_DURATION = 4000;
  const CATEGORY_COLUMN_CANDIDATES = [
    'category',
    'type',
    'collection',
    'group',
    'line',
    'segment',
    'الصنف',
    'الفئة',
    'نوع',
    'name',
    'piece type | نوع القطعة', // Add your field
    'type' // Add your field
  ];

  function getToastContainer() {
    let container = document.querySelector('.toast-container');
    if (!container) {
      container = document.createElement('div');
      container.className = 'toast-container';
      document.body.appendChild(container);
    }
    return container;
  }

  function showToast(message, type = 'info') {
    try {
      const container = getToastContainer();
      const toast = document.createElement('div');
      toast.className = `toast toast-${type}`;
      const sanitizedMessage = sanitizeInput(message);
      toast.innerHTML = sanitizedMessage;
      container.appendChild(toast);
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          toast.classList.add('visible');
        });
      });
      setTimeout(() => {
        toast.classList.remove('visible');
        setTimeout(() => {
          toast.remove();
          if (!container.childElementCount) {
            container.remove();
          }
        }, 300);
      }, TOAST_DURATION);
    } catch (err) {
      console.warn('Toast rendering failed:', err);
    }
  }

  function sanitizeInput(input) {
    const div = document.createElement('div');
    div.textContent = String(input ?? '');
    return div.innerHTML;
  }

  function loadImageWithTimeout(imgElement, src, timeout = 5000) {
    return new Promise((resolve, reject) => {
      let settled = false;
      const cleanup = () => {
        imgElement.onload = null;
        imgElement.onerror = null;
      };

      const timer = setTimeout(() => {
        if (settled) return;
        settled = true;
        cleanup();
        reject(new Error('Image load timeout'));
      }, timeout);

      imgElement.onload = () => {
        if (settled) return;
        settled = true;
        clearTimeout(timer);
        cleanup();
        resolve();
      };

      imgElement.onerror = () => {
        if (settled) return;
        settled = true;
        clearTimeout(timer);
        cleanup();
        reject(new Error('Image load failed'));
      };

      imgElement.src = src;
    });
  }

  function validateSKU(sku) {
    const skuStr = String(sku ?? '').trim();
    if (/['"\\;()]/.test(skuStr)) {
      throw new Error('Invalid characters in SKU');
    }
    if (!/^\d{5,6}$/.test(skuStr)) {
      throw new Error('SKU must be 5-6 digits');
    }
    const num = Number.parseInt(skuStr, 10);
    if (num < 100000 || num > 399999) {
      throw new Error('SKU must be between 100000 and 399999');
    }
    return skuStr;
  }

  function debounce(func, wait = 200) {
    let timeout;
    return function debounced(...args) {
      clearTimeout(timeout);
      timeout = setTimeout(() => func.apply(this, args), wait);
    };
  }
  let hardwareEnabled = hardwareToggle ? hardwareToggle.checked : false;
  let hardwareKeyBuffer = '';
  let hardwareBufferTimer = null;
  const hardwareScanAttempts = new Map();
  const HARDWARE_MAX_ATTEMPTS = 10;
  const HARDWARE_ATTEMPT_WINDOW = 60 * 1000;

  function allowHardwareScan(key = 'global') {
    const now = Date.now();
    const attempts = hardwareScanAttempts.get(key) ?? [];
    const recent = attempts.filter((timestamp) => now - timestamp < HARDWARE_ATTEMPT_WINDOW);
    if (recent.length >= HARDWARE_MAX_ATTEMPTS) {
      hardwareScanAttempts.set(key, recent);
      return false;
    }
    recent.push(now);
    hardwareScanAttempts.set(key, recent);
    return true;
  }

  function updateHardwareStatus(message) {
    if (hardwareStatus) hardwareStatus.textContent = message;
  }

  function clearHardwareLog() {
    if (!hardwareLog) return;
    while (hardwareLog.firstChild) hardwareLog.removeChild(hardwareLog.firstChild);
  }

  function appendHardwareLog(value) {
    if (!hardwareLog) return;
    const entry = document.createElement('li');
    const code = document.createElement('code');
    code.textContent = value;
    const time = document.createElement('time');
    const now = new Date();
    time.dateTime = now.toISOString();
    time.textContent = now.toLocaleTimeString();
    entry.appendChild(code);
    entry.appendChild(time);
    hardwareLog.prepend(entry);
    while (hardwareLog.children.length > HARDWARE_HISTORY_LIMIT) {
      hardwareLog.removeChild(hardwareLog.lastChild);
    }
  }

  function commitHardwareScan(rawValue) {
    const normalized = String(rawValue ?? '').trim();
    if (!normalized) {
      updateHardwareStatus(hardwareEnabled ? 'Awaiting scan…' : 'Capture paused');
      return;
    }
    if (!allowHardwareScan()) {
      const limitMessage = 'Too many scan attempts. Please wait.';
      updateHardwareStatus(limitMessage);
      showToast(limitMessage, 'error');
      return;
    }
    appendHardwareLog(normalized);
    updateHardwareStatus(`Last scan: ${normalized}`);
    if (hardwareField) {
      hardwareField.value = '';
    }
    lastValue = null;
    handleDetected(normalized, 'bluetooth');
    if (hardwareEnabled) {
      hardwareField?.focus();
    }
  }

  hardwareToggle?.addEventListener('change', () => {
    hardwareEnabled = hardwareToggle.checked;
    hardwareKeyBuffer = '';
    hardwareScanAttempts.clear();
    if (hardwareBufferTimer) {
      clearTimeout(hardwareBufferTimer);
      hardwareBufferTimer = null;
    }
    if (hardwareField) {
      hardwareField.disabled = !hardwareEnabled;
      if (hardwareEnabled) {
        hardwareField.focus();
        hardwareField.select?.();
      }
    }
    updateHardwareStatus(hardwareEnabled ? 'Awaiting scan…' : 'Capture paused');
  });

  hardwareField?.addEventListener('keydown', (event) => {
    if (!hardwareEnabled) return;
    if (event.key === 'Enter' || event.key === 'Tab') {
      event.preventDefault();
      commitHardwareScan(hardwareField.value);
    } else if (event.key === 'Escape') {
      hardwareField.value = '';
      updateHardwareStatus('Awaiting scan…');
    }
  });

  hardwareField?.addEventListener('input', () => {
    if (!hardwareEnabled) return;
    if (hardwareField.value) {
      updateHardwareStatus(`Typing: ${hardwareField.value}`);
    } else {
      updateHardwareStatus('Awaiting scan…');
    }
  });

  hardwareField?.addEventListener('focus', () => {
    if (!hardwareEnabled) return;
    if (!hardwareField.value) updateHardwareStatus('Ready for scanner…');
  });

  hardwareCard?.addEventListener('click', () => {
    if (!hardwareEnabled) return;
    hardwareField?.focus();
  });

  hardwareClear?.addEventListener('click', () => {
    clearHardwareLog();
    if (hardwareField) hardwareField.value = '';
    hardwareKeyBuffer = '';
    hardwareScanAttempts.clear();
    if (hardwareBufferTimer) {
      clearTimeout(hardwareBufferTimer);
      hardwareBufferTimer = null;
    }
    updateHardwareStatus(hardwareEnabled ? 'Awaiting scan…' : 'Capture paused');
    hardwareField?.focus();
  });

  function flushHardwareBuffer() {
    if (!hardwareKeyBuffer) return;
    const value = hardwareKeyBuffer;
    hardwareKeyBuffer = '';
    if (hardwareBufferTimer) {
      clearTimeout(hardwareBufferTimer);
      hardwareBufferTimer = null;
    }
    commitHardwareScan(value);
  }

  document.addEventListener('keydown', (event) => {
    if (!hardwareEnabled) return;
    if (event.target === hardwareField) return;
    const active = document.activeElement;
    if (active && active !== hardwareField) {
      const tag = active.tagName?.toLowerCase?.();
      if (tag === 'input' || tag === 'textarea' || active.isContentEditable) {
        return;
      }
    }

    if (event.key === 'Enter') {
      event.preventDefault();
      if (hardwareKeyBuffer) {
        flushHardwareBuffer();
      } else if (hardwareField && hardwareField.value) {
        commitHardwareScan(hardwareField.value);
      }
      return;
    }

    if (event.key.length === 1) {
      hardwareKeyBuffer += event.key;
      if (hardwareField) {
        hardwareField.value += event.key;
        const pos = hardwareField.value.length;
        hardwareField.setSelectionRange?.(pos, pos);
      }
      updateHardwareStatus(`Typing: ${hardwareKeyBuffer}`);
      if (hardwareBufferTimer) clearTimeout(hardwareBufferTimer);
      hardwareBufferTimer = setTimeout(() => {
        flushHardwareBuffer();
      }, HARDWARE_AUTO_COMMIT_MS);
      event.preventDefault();
      return;
    }

    if (event.key === 'Escape') {
      hardwareKeyBuffer = '';
      if (hardwareBufferTimer) {
        clearTimeout(hardwareBufferTimer);
        hardwareBufferTimer = null;
      }
      updateHardwareStatus('Awaiting scan…');
      return;
    }
  }, true);

  if (hardwareField) {
    hardwareField.disabled = !hardwareEnabled;
  }

  // ======== GOLD PRICE CONFIG/STATE ========
  const PREMIUM = 30;
  const OUNCE_GRAMS = 32;
  let goldPrice = null;
  let goldUpdatedAt = null;
  let manualGoldPrice = null;
  let manualGoldUpdatedAt = null;
  let lastRenderedItem = null;

  function isManualGoldActive() {
    return manualGoldPrice !== null && Number.isFinite(manualGoldPrice);
  }

  function getActiveGoldPrice() {
    if (isManualGoldActive()) {
      return manualGoldPrice;
    }
    return goldPrice;
  }

  function getGoldTimestampLabel() {
    if (isManualGoldActive()) {
      return manualGoldUpdatedAt ? `Set: ${manualGoldUpdatedAt}` : "";
    }
    return goldUpdatedAt ? `Updated: ${goldUpdatedAt}` : "";
  }

  function updateGoldPriceStatus() {
    if (!goldPriceStatus) return;
    if (isManualGoldActive()) {
      const parts = [`Using manual price ${manualGoldPrice.toFixed(2)}`];
      if (manualGoldUpdatedAt) parts.push(`set ${manualGoldUpdatedAt}`);
      goldPriceStatus.textContent = parts.join(' • ');
    } else if (goldPrice && Number.isFinite(goldPrice)) {
      const parts = [`Using live price ${goldPrice.toFixed(2)}`];
      if (goldUpdatedAt) parts.push(`updated ${goldUpdatedAt}`);
      goldPriceStatus.textContent = parts.join(' • ');
    } else {
      goldPriceStatus.textContent = 'Waiting for live price…';
    }
  }

  function setManualGoldPrice(value, { toastMessage = 'Manual gold price applied.', toastType = 'success' } = {}) {
    manualGoldPrice = value;
    manualGoldUpdatedAt = new Date().toLocaleString();
    updateGoldPriceStatus();
    if (toastMessage) {
      showToast(toastMessage, toastType);
    }
    if (lastRenderedItem) {
      renderItem(lastRenderedItem);
    }
  }

  async function fetchGoldPrice() {
    try {
      const res = await fetch(GOLD_API, { cache: "no-store" });
      const data = await res.json();
      goldPrice = Number(data.price);
      goldUpdatedAt = data.updatedAtReadable || data.updatedAt || "";
      console.log("Gold price loaded:", goldPrice, goldUpdatedAt);
      updateGoldPriceStatus();
      if (!isManualGoldActive() && lastRenderedItem) {
        renderItem(lastRenderedItem);
      }
    } catch (e) {
      console.warn("Gold price fetch failed:", e);
      goldPrice = null;
      updateGoldPriceStatus();
      if (!isManualGoldActive() && lastRenderedItem) {
        renderItem(lastRenderedItem);
      }
    }
  }
  updateGoldPriceStatus();
  fetchGoldPrice();
  setInterval(fetchGoldPrice, 5 * 60 * 1000);

  function computeItemPrice(weightStr, karatStr, feesStr) {
    const w = Number(String(weightStr ?? "").replace(",", ".")) || 0;
    const fees = Number(feesStr ?? 0) || 0;
    const k = parseInt(String(karatStr ?? "").replace(/[^\d]/g, ""), 10) || 0;

    const basePrice = getActiveGoldPrice();
    if (!basePrice || !Number.isFinite(basePrice) || !w || !k) return null;

    let purity;
    if (k === 18) purity = 750 / 995;
    else if (k === 21) purity = 875 / 995;
    else purity = (k / 24);

    const effectivePremium = isManualGoldActive() ? 0 : PREMIUM;
    const perGram = ((basePrice + effectivePremium) * OUNCE_GRAMS * purity) / 1000 + fees;
    const total = perGram * w;

    return {
      perGram,
      total,
      purity
    };
  }

async function login(password) {
  try {
    console.log('Sending login request...');
    const response = await fetch(AUTH_ENDPOINT, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ password })
    });

    const result = await response.json();
    console.log('Login response:', result);
    return result;
  } catch (error) {
    console.error('Login fetch error:', error);
    return { success: false, error: 'Network error' };
  }
}

async function fetchInventory() {
  try {
    console.log('Fetching inventory...');
    const response = await fetch(INVENTORY_ENDPOINT, {
      credentials: 'include' // This ensures cookies are sent
    });

    if (!response.ok) {
      if (response.status === 401) {
        showToast('Authentication required', 'error');
        throw new Error('Authentication failed');
      }
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data = await response.json();
    console.log('Inventory data received');
    return data;
  } catch (error) {
    console.error('Inventory fetch error:', error);
    throw error;
  }
}

async function recordSale(saleData) {
  try {
    const response = await fetch(SALES_ENDPOINT, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'include',
      body: JSON.stringify(saleData)
    });

    const text = await response.text();
    let payload = {};

    if (text) {
      try {
        payload = JSON.parse(text);
      } catch (err) {
        console.warn('Failed to parse sale response JSON:', err);
        payload = { raw: text };
      }
    }

    if (!response.ok || payload?.success === false) {
      const message = payload?.error || payload?.message || `Sale request failed (${response.status})`;
      return {
        success: false,
        status: response.status,
        error: message,
        details: payload
      };
    }

    return {
      success: true,
      status: response.status,
      data: payload,
      message: payload?.message
    };
  } catch (error) {
    console.error('Sale request error:', error);
    return {
      success: false,
      error: 'Network error. Please try again.',
      details: error
    };
  }
}

// Add this debug function
async function testSaleAPI() {
  const testData = {
    sku: '100001',
    employee: 'Test Employee',
    price: '1000',
    notes: 'Test sale',
    token: 'ghandourjuwelrytOasASDWaaa124w'
  };

  console.log('Testing sale API with:', testData);

  try {
    const result = await recordSale(testData);
    console.log('Test API response:', result);
    return result;
  } catch (error) {
    console.error('Test API error:', error);
    return { error: error.message };
  }
}


 
  // ========= SHEET STATE / HELPERS =========
  let sheetRows = [];
  let skuIndex = new Map();
  let skuKeyName = "sku";
  let categoryKeyName = null;

  function normalizeRowKeys(row) {
    const out = {};
    let laborFeeRaw;
    let profitFeeRaw;

    for (const k of Object.keys(row)) {
      const value = row[k];
      const keyLower = k.toLowerCase();

      // Keep original key but also create normalized versions for easier access
      out[k] = value;
      out[keyLower.trim()] = value;

      // Create specific normalized keys for known field variations
      if (keyLower.includes('sku')) out['sku'] = value;
      if (keyLower.includes('timestamp')) out['timestamp'] = value;
      if (keyLower.includes('type')) out['type'] = value;
      if (keyLower.includes('status') || keyLower.includes('حالة')) out['availability'] = value;
      if (keyLower.includes('piece type') || keyLower.includes('نوع القطعة')) out['name'] = value;
      if (keyLower.includes('weight') || keyLower.includes('وزن')) out['weight'] = value;
      if (keyLower.includes('karat') || keyLower.includes('carat') || keyLower.includes('عيار')) out['karat'] = value;
      if (keyLower.includes('making fee') || keyLower.includes('أجور')) out['fees'] = value;
      if (keyLower.includes('اجور بالغرام')) laborFeeRaw = value;
      if (keyLower.includes('ربح لكل غرام')) profitFeeRaw = value;
      if (keyLower.includes('description') || keyLower.includes('وصف')) out['description'] = value;
      if (keyLower.includes('photo') || keyLower.includes('video')) out['photo'] = value;
      if (keyLower.includes('أسم البائع')) out['soldby'] = value;
      if (keyLower.includes('تاريخ المبيع')) out['solddate'] = value;
      if (
        keyLower.includes('مبلغ البيع') ||
        keyLower.includes('sold price') ||
        keyLower.includes('sell price') ||
        keyLower.includes('sale price') ||
        keyLower.includes('sold amount') ||
        keyLower.includes('sale amount')
      ) {
        out['soldprice'] = value;
      }
      if (keyLower.includes('ملاحظات')) out['notes'] = value;
    }

    const hasLaborFee = typeof laborFeeRaw !== 'undefined' && String(laborFeeRaw ?? '').trim() !== '';
    const hasProfitFee = typeof profitFeeRaw !== 'undefined' && String(profitFeeRaw ?? '').trim() !== '';

    if (hasLaborFee || hasProfitFee) {
      const parseFeeComponent = (raw) => {
        const normalized = String(raw ?? '').trim();
        if (!normalized) return 0;
        const numeric = Number(normalized.replace(/[^0-9.,-]/g, '').replace(',', '.'));
        return Number.isFinite(numeric) ? numeric : 0;
      };

      const laborFee = parseFeeComponent(laborFeeRaw);
      const profitFee = parseFeeComponent(profitFeeRaw);
      const totalFees = laborFee + profitFee;

      if (Number.isFinite(totalFees)) {
        const formattedTotal = totalFees
          .toFixed(4)
          .replace(/\.0+$/, '')
          .replace(/(\.\d*?)0+$/, '$1');
        out['fees'] = formattedTotal;
      }
    }

    return out;
  }
  function normalizeSku(value = "") {
    return String(value ?? "")
      .replace(/\u0660/g, "0").replace(/\u0661/g, "1").replace(/\u0662/g, "2")
      .replace(/\u0663/g, "3").replace(/\u0664/g, "4").replace(/\u0665/g, "5")
      .replace(/\u0666/g, "6").replace(/\u0667/g, "7").replace(/\u0668/g, "8")
      .replace(/\u0669/g, "9")
      .replace(/[^\w]/g, "")
      .toLowerCase();
  }

  function normalizeCategoryValue(value = "") {
    return String(value ?? "").trim().toLowerCase();
  }

  function detectCategoryKey(rows = []) {
    if (!rows.length) return null;
    const keys = new Set();
    for (const row of rows) {
      for (const key of Object.keys(row)) {
        if (!key) continue;
        keys.add(key.trim().toLowerCase());
      }
    }
    for (const candidate of CATEGORY_COLUMN_CANDIDATES) {
      if (keys.has(candidate)) {
        return candidate;
      }
    }
    return null;
  }

  function resetCategoryResults() {
    if (categoryResultsEl) {
      categoryResultsEl.hidden = true;
      categoryResultsEl.innerHTML = '';
    }
    if (categoryHint) {
      categoryHint.hidden = false;
    }
  }

  function renderCategoryItems(rows, categoryLabel) {
    if (!categoryResultsEl) return;
    categoryResultsEl.innerHTML = '';

    const heading = document.createElement('div');
    heading.className = 'category-results-title';
    const count = rows.length;
    heading.textContent = `${categoryLabel} • ${count} item${count === 1 ? '' : 's'}`;
    categoryResultsEl.appendChild(heading);

    if (!rows.length) {
      const empty = document.createElement('p');
      empty.className = 'search-empty';
      empty.textContent = 'No pieces in this category yet.';
      categoryResultsEl.appendChild(empty);
    } else {
      const normalizedCategory = normalizeCategoryValue(categoryLabel);

      // Create a grid container for the results
      const gridContainer = document.createElement('div');
      gridContainer.className = 'category-results-grid';

      rows.forEach(row => {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'search-result with-image';

        const skuValue = row[skuKeyName] ?? row['sku'] ?? '';
        const rowName = row['name'] ?? '';
        const rowCategory = categoryKeyName ? String(row[categoryKeyName] ?? '') : '';
        const description = row['description'] ?? '';
        const weight = row['weight'] ?? '';
        const karat = row['karat'] ?? row['carat'] ?? '';
        const photoRaw = row['photo'] ?? row['Photo/Video'] ?? '';

        const rowCategoryNormalized = normalizeCategoryValue(rowCategory);
        const rowNameNormalized = normalizeCategoryValue(rowName);
        const titleText = (rowCategoryNormalized === normalizedCategory && rowNameNormalized === normalizedCategory && description)
          ? description
          : (rowName || description || skuValue || 'Unnamed item');

        // Create result content container
        const contentDiv = document.createElement('div');
        contentDiv.className = 'search-result-content';

        // Create text info section
        const textSection = document.createElement('div');
        textSection.className = 'search-result-text';

        const title = document.createElement('span');
        title.className = 'search-result-title';
        title.textContent = titleText;
        textSection.appendChild(title);

        const metaParts = [];
        if (skuValue) metaParts.push(skuValue);
        if (weight) metaParts.push(`${weight} g`);
        if (karat) metaParts.push(String(karat));
        if (description && titleText !== description) metaParts.push(description);

        if (metaParts.length) {
          const meta = document.createElement('span');
          meta.className = 'search-result-meta';
          meta.textContent = metaParts.join(' • ');
          textSection.appendChild(meta);
        }

        contentDiv.appendChild(textSection);

        // Create image section if photo exists
        if (photoRaw && photoRaw.trim() !== '') {
          const imageSection = document.createElement('div');
          imageSection.className = 'search-result-image loading';

          const driveId = getDriveId(photoRaw);
          const primaryUrl = driveId
            ? `https://drive.google.com/uc?export=view&id=${driveId}`
            : photoRaw;

          const candidateUrls = driveId
            ? [
                primaryUrl,
                `https://lh3.googleusercontent.com/d/${driveId}=s600`,
                `https://drive.google.com/thumbnail?id=${driveId}&sz=s600`
              ]
            : [primaryUrl];

          const img = document.createElement('img');
          img.alt = '';
          img.loading = 'lazy';
          img.crossOrigin = 'anonymous';

          const urls = [...candidateUrls];
          const showPlaceholder = () => {
            imageSection.classList.remove('loading');
            imageSection.classList.add('no-image');
            imageSection.innerHTML = '<span>No Image</span>';
          };

          const tryNextImage = () => {
            const nextUrl = urls.shift();
            if (!nextUrl) {
              showPlaceholder();
              return;
            }
            loadImageWithTimeout(img, nextUrl, 5000)
              .then(() => {
                imageSection.classList.remove('loading');
              })
              .catch(() => {
                if (driveId) {
                  setTimeout(tryNextImage, 100);
                } else {
                  showPlaceholder();
                }
              });
          };

          imageSection.appendChild(img);
          contentDiv.appendChild(imageSection);
          tryNextImage();
        } else {
          // Show placeholder when no photo
          const imageSection = document.createElement('div');
          imageSection.className = 'search-result-image no-image';
          imageSection.innerHTML = '<span>No Image</span>';
          contentDiv.appendChild(imageSection);
        }

        button.appendChild(contentDiv);
        button.addEventListener('click', () => {
          renderItem(row);
          addToScanHistory(skuValue, rowName || skuValue || categoryLabel);
        });

        gridContainer.appendChild(button);
      });

      categoryResultsEl.appendChild(gridContainer);
    }

    categoryResultsEl.hidden = false;
    if (categoryHint) {
      categoryHint.hidden = true;
    }
  }

  function populateCategoryOptions() {
    if (!categorySection) return;
    const categoryChips = document.getElementById('categoryChips');
    const categoryPrev = document.getElementById('categoryPrev');
    const categoryNext = document.getElementById('categoryNext');

    resetCategoryResults();

    if (!categoryChips) return;
    categoryChips.innerHTML = '';
    categorySection.hidden = true;
    categoryKeyName = null;

    if (!sheetRows.length) return;

    categoryKeyName = detectCategoryKey(sheetRows);
    if (!categoryKeyName) return;

    const unique = new Map();
    for (const row of sheetRows) {
      const raw = row[categoryKeyName];
      const label = String(raw ?? '').trim();
      if (!label) continue;
      const normalized = normalizeCategoryValue(label);
      if (!unique.has(normalized)) {
        unique.set(normalized, label);
      }
    }

    if (!unique.size) return;

    categorySection.hidden = false;

    // Create "All" chip
    const allChip = document.createElement('button');
    allChip.type = 'button';
    allChip.className = 'category-chip active';
    allChip.textContent = 'All Collections';
    allChip.setAttribute('role', 'tab');
    allChip.setAttribute('aria-selected', 'true');
    allChip.dataset.category = '';
    allChip.addEventListener('click', () => handleCategorySelect(''));
    categoryChips.appendChild(allChip);

    // Create category chips
    for (const [, label] of unique) {
      const chip = document.createElement('button');
      chip.type = 'button';
      chip.className = 'category-chip';
      chip.textContent = label;
      chip.setAttribute('role', 'tab');
      chip.setAttribute('aria-selected', 'false');
      chip.dataset.category = label;
      chip.addEventListener('click', () => handleCategorySelect(label));
      categoryChips.appendChild(chip);
    }

    // Navigation controls
    if (categoryPrev && categoryNext) {
      const scrollContainer = categoryChips.parentElement;

      const updateNavButtons = () => {
        const scrollLeft = scrollContainer.scrollLeft;
        const scrollWidth = scrollContainer.scrollWidth;
        const clientWidth = scrollContainer.clientWidth;

        categoryPrev.disabled = scrollLeft === 0;
        categoryNext.disabled = scrollLeft + clientWidth >= scrollWidth - 10;
      };

      categoryPrev.addEventListener('click', () => {
        scrollContainer.scrollBy({ left: -200, behavior: 'smooth' });
      });

      categoryNext.addEventListener('click', () => {
        scrollContainer.scrollBy({ left: 200, behavior: 'smooth' });
      });

      scrollContainer.addEventListener('scroll', updateNavButtons);
      window.addEventListener('resize', updateNavButtons);
      setTimeout(updateNavButtons, 100);
    }
  }

  function handleCategorySelect(selectedValue) {
    const categoryChips = document.getElementById('categoryChips');
    if (categoryChips) {
      // Update active state
      categoryChips.querySelectorAll('.category-chip').forEach(chip => {
        const isActive = chip.dataset.category === selectedValue;
        chip.classList.toggle('active', isActive);
        chip.setAttribute('aria-selected', isActive.toString());
      });
    }

    if (!selectedValue) {
      resetCategoryResults();
      return;
    }

    if (!sheetRows.length) {
      showToast('Inventory still loading…', 'info');
      return;
    }

    if (!categoryKeyName) {
      showToast('Category column not available in the sheet.', 'error');
      return;
    }

    const normalized = normalizeCategoryValue(selectedValue);
    const matches = sheetRows.filter(row => normalizeCategoryValue(row[categoryKeyName]) === normalized);
    renderCategoryItems(matches, selectedValue);
  }

  // Extract a Google Drive file ID from multiple URL shapes
  function getDriveId(url = "") {
    const s = String(url).trim();
    if (!s) return null;

    const patterns = [
      /[?&]id=([A-Za-z0-9_-]+)/, // ...open?id=FILE_ID
      /\/file\/d\/([A-Za-z0-9_-]+)/, // .../file/d/FILE_ID/...
      /\/uc\?export=(?:download|view)&id=([A-Za-z0-9_-]+)/, // .../uc?export=...&id=FILE_ID
      /\/d\/([A-Za-z0-9_-]+)/, // .../d/FILE_ID/...
      /\/view\?usp=sharing&id=([A-Za-z0-9_-]+)/, // .../view?usp=sharing&id=FILE_ID
      /drive\.google\.com\/file\/d\/([A-Za-z0-9_-]+)/ // drive.google.com/file/d/FILE_ID
    ];

    for (const pattern of patterns) {
      const match = s.match(pattern);
      if (match && match[1]) {
        return match[1];
      }
    }

    if (/\.(jpg|jpeg|png|gif|webp)(\?.*)?$/i.test(s)) {
      return null;
    }

    return null;
  }

  function driveEmbedHTML(rawUrl) {
    if (!rawUrl || rawUrl.trim() === '') {
      return { html: '', id: null };
    }

    const id = getDriveId(rawUrl);
    if (!id) {
      // not a Drive link – just try to render as a normal image
      return {
        html: `<img id="itemPhoto" src="${rawUrl}" alt="Item photo" crossorigin="anonymous" onerror="this.style.display='none'">`,
        id: null
      };
    }

    // Use the direct image URL for Google Drive
    const imgSrc = `https://drive.google.com/uc?export=view&id=${id}`;
    const iframeSrc = `https://drive.google.com/file/d/${id}/preview`;

    return {
      html: `<img id="itemPhoto" src="${imgSrc}" alt="Item photo" crossorigin="anonymous" onerror="this.style.display='none'">`,
      id,
      iframeSrc
    };
  }
  function readInventoryCache() {
    try {
      const raw = localStorage.getItem(CACHE_KEY);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (!parsed || !Array.isArray(parsed.rows)) return null;
      const timestamp = Number(parsed.timestamp) || 0;
      return {
        rows: parsed.rows,
        timestamp,
        fresh: timestamp ? (Date.now() - timestamp) < CACHE_TTL : false
      };
    } catch (err) {
      console.warn('Inventory cache parse failed:', err);
      return null;
    }
  }

  function writeInventoryCache(rows) {
    try {
      localStorage.setItem(CACHE_KEY, JSON.stringify({ rows, timestamp: Date.now() }));
    } catch (err) {
      console.warn('Inventory cache write failed:', err);
    }
  }

  function processSheetData(rows = []) {
    sheetRows = rows.map(normalizeRowKeys);
    skuIndex.clear();
    const sample = sheetRows[0] || {};
    // Find the actual key used for sku (case/space safe)
    skuKeyName = Object.keys(sample).find(k => k.trim().toLowerCase() === "sku") || "sku";
    for (const r of sheetRows) {
      const raw = r[skuKeyName];
      const key = normalizeSku(raw);
      if (key) skuIndex.set(key, r);
    }
    console.log(`Loaded ${sheetRows.length} rows. Indexed ${skuIndex.size} SKUs.`);
    populateCategoryOptions();
    if (searchInput && searchInput.value.trim().length >= 2) {
      handleSearch(searchInput.value);
    } else {
      clearSearchResults();
    }
    renderScanHistory();
  }

 async function loadSheet() {
  try {
    const data = await fetchInventory();
    processSheetData(data);
  } catch (error) {
    showToast('Authentication required', 'error');
    // Redirect to login or show auth overlay
  }
}

  function readScanHistory() {
    try {
      const raw = localStorage.getItem(SCAN_HISTORY_KEY);
      if (!raw) return [];
      const parsed = JSON.parse(raw);
      return Array.isArray(parsed) ? parsed : [];
    } catch (err) {
      console.warn('Scan history parse failed:', err);
      return [];
    }
  }

  function persistScanHistory(entries) {
    try {
      localStorage.setItem(SCAN_HISTORY_KEY, JSON.stringify(entries));
    } catch (err) {
      console.warn('Scan history write failed:', err);
    }
  }

  function addToScanHistory(sku, itemName) {
    const safeSku = String(sku ?? '').trim();
    if (!safeSku) return;
    const history = readScanHistory().filter(entry => entry?.sku !== safeSku);
    history.unshift({
      sku: safeSku,
      itemName: String(itemName ?? ''),
      timestamp: new Date().toISOString()
    });
    persistScanHistory(history.slice(0, MAX_HISTORY));
    renderScanHistory();
  }

  function renderScanHistory() {
    if (!historyCard || !historyList) return;
    const history = readScanHistory();
    historyList.innerHTML = '';
    if (!history.length) {
      historyCard.hidden = true;
      return;
    }
    historyCard.hidden = false;
    history.slice(0, HISTORY_DISPLAY_LIMIT).forEach(entry => {
      const li = document.createElement('li');
      const button = document.createElement('button');
      button.type = 'button';
      button.className = 'history-item';

      const title = document.createElement('span');
      title.className = 'history-item-primary';
      title.textContent = entry.itemName || `SKU ${entry.sku}`;

      const meta = document.createElement('span');
      meta.className = 'history-item-meta';
      let timestampText = '';
      if (entry.timestamp) {
        const date = new Date(entry.timestamp);
        if (!Number.isNaN(date.valueOf())) {
          timestampText = date.toLocaleString();
        }
      }
      const metaParts = [entry.sku, timestampText].filter(Boolean);
      meta.textContent = metaParts.join(' • ');

      button.appendChild(title);
      if (metaParts.length) button.appendChild(meta);
      button.addEventListener('click', () => {
        if (!sheetRows.length) {
          showToast('Inventory still loading…', 'info');
          return;
        }
        const row = skuIndex.get(normalizeSku(entry.sku));
        if (row) {
          renderItem(row);
        } else {
          showToast('Item not found in current inventory cache.', 'error');
        }
      });

      li.appendChild(button);
      historyList.appendChild(li);
    });
  }

  function clearSearchResults() {
    if (!searchResultsEl) return;
    searchResultsEl.hidden = true;
    searchResultsEl.innerHTML = '';
  }

  function displaySearchResults(results, query) {
    if (!searchResultsEl) return;
    searchResultsEl.innerHTML = '';
    const limited = results.slice(0, 12);

    if (!limited.length) {
      const empty = document.createElement('p');
      empty.className = 'search-empty';
      empty.textContent = `No matches for "${query}".`;
      searchResultsEl.appendChild(empty);
    } else {
      // Create grid container for search results too
      const gridContainer = document.createElement('div');
      gridContainer.className = 'category-results-grid'; // Reuse the same grid style

      limited.forEach(row => {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'search-result with-image';

        const skuValue = row[skuKeyName] ?? row['sku'] ?? '';
        const rowName = row['name'] ?? '';
        const description = row['description'] ?? '';
        const weight = row['weight'] ?? '';
        const karat = row['karat'] ?? row['carat'] ?? '';
        const photoRaw = row['photo'] ?? row['Photo/Video'] ?? '';

        const contentDiv = document.createElement('div');
        contentDiv.className = 'search-result-content';

        const textSection = document.createElement('div');
        textSection.className = 'search-result-text';

        const title = document.createElement('span');
        title.className = 'search-result-title';
        title.textContent = rowName || skuValue || 'Unnamed item';
        textSection.appendChild(title);

        const metaParts = [skuValue];
        if (weight) metaParts.push(`${weight} g`);
        if (karat) metaParts.push(String(karat));
        if (description) metaParts.push(description);

        if (metaParts.length) {
          const meta = document.createElement('span');
          meta.className = 'search-result-meta';
          meta.textContent = metaParts.join(' • ');
          textSection.appendChild(meta);
        }

        contentDiv.appendChild(textSection);

        // Add image if available
        if (photoRaw && photoRaw.trim() !== '') {
          const imageSection = document.createElement('div');
          imageSection.className = 'search-result-image loading';

          const driveId = getDriveId(photoRaw);
          const primaryUrl = driveId
            ? `https://drive.google.com/uc?export=view&id=${driveId}`
            : photoRaw;

          const candidateUrls = driveId
            ? [
                primaryUrl,
                `https://lh3.googleusercontent.com/d/${driveId}=s600`,
                `https://drive.google.com/thumbnail?id=${driveId}&sz=s600`
              ]
            : [primaryUrl];

          const img = document.createElement('img');
          img.alt = '';
          img.loading = 'lazy';
          img.crossOrigin = 'anonymous';

          const urls = [...candidateUrls];
          const showPlaceholder = () => {
            imageSection.classList.remove('loading');
            imageSection.classList.add('no-image');
            imageSection.innerHTML = '<span>No Image</span>';
          };

          const tryNextImage = () => {
            const nextUrl = urls.shift();
            if (!nextUrl) {
              showPlaceholder();
              return;
            }
            loadImageWithTimeout(img, nextUrl, 5000)
              .then(() => {
                imageSection.classList.remove('loading');
              })
              .catch(() => {
                if (driveId) {
                  setTimeout(tryNextImage, 100);
                } else {
                  showPlaceholder();
                }
              });
          };

          imageSection.appendChild(img);
          contentDiv.appendChild(imageSection);
          tryNextImage();
        } else {
          // Show placeholder when no photo
          const imageSection = document.createElement('div');
          imageSection.className = 'search-result-image no-image';
          imageSection.innerHTML = '<span>No Image</span>';
          contentDiv.appendChild(imageSection);
        }

        button.appendChild(contentDiv);
        button.addEventListener('click', () => {
          renderItem(row);
          addToScanHistory(skuValue, rowName || '');
          clearSearchResults();
          if (searchInput) searchInput.value = '';
        });

        gridContainer.appendChild(button);
      });

      searchResultsEl.appendChild(gridContainer);
    }
    searchResultsEl.hidden = false;
  }

  let searchLoadingNotified = false;

  function handleSearch(rawValue) {
    const query = String(rawValue ?? '').toLowerCase().trim();
    if (!query) {
      clearSearchResults();
      return;
    }
    if (query.length < 2) {
      clearSearchResults();
      return;
    }
    if (!sheetRows.length) {
      if (!searchLoadingNotified) {
        showToast('Inventory still loading…', 'info');
        searchLoadingNotified = true;
      }
      return;
    }
    searchLoadingNotified = false;
    const lowerQuery = query.toLowerCase();
    const results = sheetRows.filter(row => {
      return Object.values(row).some(value => {
        return String(value ?? '').toLowerCase().includes(lowerQuery);
      });
    });
    displaySearchResults(results, rawValue);
  }

  if (searchInput) {
    const onSearchInput = debounce((value) => handleSearch(value), 300);
    searchInput.addEventListener('input', (event) => {
      onSearchInput(event.target.value);
    });
  }

  clearHistoryBtn?.addEventListener('click', () => {
    localStorage.removeItem(SCAN_HISTORY_KEY);
    renderScanHistory();
    showToast('Scan history cleared', 'info');
  });

  renderScanHistory();
  function renderItem(row) {
    lastRenderedItem = row;

    // Your existing field mapping code...
    const sku = row['sku'] ?? row['SKU'] ?? "";
    const name = row['name'] ?? row['Piece Type | نوع القطعة'] ?? "";
    const weight = row['weight'] ?? row['Weight | الوزن'] ?? "";
    const karat = row['karat'] ?? row['Karat | العيار'] ?? "";
    const description = row['description'] ?? row['Description | الوصف'] ?? "";
    const timestamp = row['timestamp'] ?? row['Timestamp'] ?? "";
    const fees = row['fees'] ?? row['Making Fee | أجور + ربح'] ?? "";
    const itemType = row['type'] ?? row['Type'] ?? "";

    // Availability & sale detail columns
    const availabilityRaw = row['availability'] ?? row['status|الحالة'] ?? "Available";
    const availability = String(availabilityRaw).trim();
    const soldByVal = row['soldby'] ?? row['أسم البائع'] ?? "";
    const soldDateVal = row['solddate'] ?? row['تاريخ المبيع'] ?? row['sale date'] ?? "";
    const soldPriceVal = row['soldprice'] ?? row['مبلغ البيع'] ?? row['sale price'] ?? row['sell price'] ?? "";
    const notesVal = row['notes'] ?? row['ملاحظات'] ?? "";
    const isSold = /^no|sold|مباع|غير متوفر/i.test(availability);

    const photoRaw = row['photo'] ?? row['Photo/Video'] ?? "";
    const media = driveEmbedHTML(photoRaw);

    const priceInfo = computeItemPrice(weight, karat, fees);
    const activePrice = getActiveGoldPrice();
    const sourceLabel = isManualGoldActive() ? "Manual" : "Live";
    const timestampLabel = getGoldTimestampLabel();

    const priceBlock = priceInfo
      ? `<div class="item-card-price">
         <strong>Estimated Price:</strong> ${priceInfo.total.toFixed(2)}
         <div class="muted">
           Per-gram: ${priceInfo.perGram.toFixed(2)} • ${sourceLabel} XAU: ${activePrice && Number.isFinite(activePrice) ? activePrice.toFixed(2) : "—"}
           ${timestampLabel ? ` • ${timestampLabel}` : ""}
         </div>
       </div>`
      : "";

    const mediaSection = media.html ? `<div class="item-card-media">${media.html}</div>` : "";
    const mediaLink = !media.html && photoRaw
      ? `<a class="item-card-link" href="${photoRaw}" target="_blank" rel="noopener">Open photo/video</a>`
      : "";

    // Build "Sell" button (hide if already sold)
    const sellBtnHTML = !isSold
      ? `<button id="sellBtn" type="button" style="margin-top:10px">Sell this item</button>`
      : `<span class="chip">Sold</span>`;

    if (itemPlaceholder) itemPlaceholder.style.display = "none";
    itemCard.style.display = "grid";
    itemCard.innerHTML = `
  <div class="item-card-grid">
    <div class="item-card-copy">
      ${sku ? `<span class="item-card-chip">SKU ${sku}</span>` : ""}
      <h3>${name || "Item"}</h3>

      <div class="item-card-meta">
        ${itemType ? `<div><strong>Type:</strong> ${itemType}</div>` : ""}
        ${timestamp ? `<div><strong>Timestamp:</strong> ${timestamp}</div>` : ""}
        ${weight ? `<div><strong>Weight:</strong> ${weight} g</div>` : ""}
        ${karat ? `<div><strong>Karat:</strong> ${karat}</div>` : ""}
        ${fees ? `<div><strong>Fees:</strong> ${fees}</div>` : ""}

        <div><strong>Status:</strong> ${isSold ? "Sold" : "Available"}</div>
        ${isSold && soldByVal ? `<div><strong>Sold by:</strong> ${soldByVal}</div>` : ""}
        ${isSold && soldDateVal ? `<div><strong>Sold date:</strong> ${soldDateVal}</div>` : ""}
        ${isSold && soldPriceVal ? `<div><strong>Sold price:</strong> ${soldPriceVal}</div>` : ""}
        ${isSold && notesVal ? `<div><strong>Notes:</strong> ${notesVal}</div>` : ""}
      </div>

      ${description ? `<div class="item-card-description">${description}</div>` : ""}
      ${priceBlock}
      ${sellBtnHTML}
      ${mediaLink}
    </div>
    ${mediaSection}
  </div>
`;

    focusItemCard();

    // If the <img> fails (e.g., it's a video), swap to Drive preview iframe
    const imgEl = document.getElementById('itemPhoto');
    if (imgEl && media.id && media.iframeSrc) {
      imgEl.onerror = () => {
        const iframe = document.createElement('iframe');
        iframe.src = media.iframeSrc;
        iframe.allow = 'autoplay; clipboard-write';
        iframe.style.width = '320px';
        iframe.style.height = '240px';
        iframe.style.border = '0';
        iframe.style.borderRadius = '10px';
        iframe.style.boxShadow = '0 2px 8px rgba(0,0,0,.15)';
        iframe.style.marginTop = '8px';
        imgEl.replaceWith(iframe);
      };
    }

    function createSaleSummaryMessage(row, context = {}) {
      const fallback = context || {};
      const skuValue = (row && (row['sku'] ?? row['SKU'])) ?? fallback.sku ?? '';
      const skuLabel = skuValue ? `SKU ${skuValue}` : 'the selected piece';

      const availabilityRaw = (row && (row['availability'] ?? row['status|الحالة'])) ?? fallback.availability ?? '';
      const availability = String(availabilityRaw || '').trim();
      const isSold = availability ? /^no|sold|مباع|غير متوفر/i.test(availability) : false;
      const statusLabel = availability ? (isSold ? 'Sold' : availability) : (fallback.defaultStatus || (isSold ? 'Sold' : ''));

      const soldBy = (row && (row['soldby'] ?? row['أسم البائع'])) ?? fallback.employee ?? '';
      const soldDate = (row && (row['solddate'] ?? row['تاريخ المبيع'] ?? row['sale date'])) ?? fallback.soldDate ?? '';
      const soldPrice = (row && (row['soldprice'] ?? row['مبلغ البيع'] ?? row['sale price'] ?? row['sell price'])) ?? fallback.priceDisplay ?? '';
      const notesVal = (row && (row['notes'] ?? row['ملاحظات'])) ?? fallback.notes ?? '';

      const parts = [];
      if (statusLabel) parts.push(`Status: ${statusLabel}`);
      if (soldBy) parts.push(`Sold by: ${soldBy}`);
      if (soldDate) parts.push(`Sold on: ${soldDate}`);
      if (soldPrice) parts.push(`Price: ${soldPrice}`);
      if (notesVal) parts.push(`Notes: ${notesVal}`);

      const summary = parts.filter(Boolean).join(' • ');
      return summary ? `Sale recorded for ${skuLabel}. ${summary}` : `Sale recorded for ${skuLabel}.`;
    }

    function notifySaleRecorded(row, context = {}) {
      const message = createSaleSummaryMessage(row, context);
      showToast(message, 'success');
    }

    // UPDATED SELL BUTTON CODE - This is the critical part
    document.getElementById('sellBtn')?.addEventListener('click', async () => {
      const employeeInput = prompt("Employee name:");
      if (employeeInput === null) return;
      const employee = String(employeeInput).trim();
      if (!employee) {
        showToast('Employee name is required to record a sale.', 'error');
        return;
      }

      const priceInput = prompt("Sold price:");
      if (priceInput === null) return;
      const priceText = String(priceInput).trim();
      if (!priceText) {
        showToast('Sold price is required to record a sale.', 'error');
        return;
      }

      const compactPrice = priceText.replace(/[^0-9,.-]/g, '').replace(/\s+/g, '');
      if (!compactPrice) {
        showToast('Please enter a valid numeric price.', 'error');
        return;
      }

      let parsedPrice = NaN;
      if (compactPrice.includes('.') && compactPrice.includes(',')) {
        const noThousandDots = compactPrice.replace(/\./g, '');
        const [whole = '', fraction = ''] = noThousandDots.split(',');
        if (fraction.length && fraction.length <= 2) {
          parsedPrice = Number(`${whole}.${fraction}`);
        } else {
          parsedPrice = Number(`${whole}${fraction}`);
        }
      } else if (compactPrice.includes(',') && !compactPrice.includes('.')) {
        const [whole = '', fraction = ''] = compactPrice.split(',');
        if (fraction.length && fraction.length <= 2) {
          parsedPrice = Number(`${whole}.${fraction}`);
        } else {
          parsedPrice = Number(`${whole}${fraction}`);
        }
      } else {
        parsedPrice = Number(compactPrice.replace(/,/g, ''));
      }

      if (!Number.isFinite(parsedPrice)) {
        showToast('Please enter a valid numeric price.', 'error');
        return;
      }

      const notesInput = prompt("Notes (optional):");
      const notes = notesInput ? String(notesInput).trim() : "";

      const saleContext = {
        sku: String(sku),
        employee,
        priceDisplay: priceText,
        notes,
        defaultStatus: 'Sold'
      };

      try {
        const formatSaleTimestamp = (date = new Date()) => {
          const pad = (value) => String(value).padStart(2, '0');
          return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())} ${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}`;
        };

        const timestamp = formatSaleTimestamp();

        const result = await recordSale({
          sku: String(sku),
          availability: "No",
          employee,
          price: parsedPrice,
          notes,
          timestamp
        });

        console.log("Sale API reply:", result);

        if (result?.success) {
          await loadSheet(); // refresh Inventory JSON
          const latest = skuIndex.get(normalizeSku(String(sku)));
          if (latest) {
            renderItem(latest);
            notifySaleRecorded(latest, saleContext);
          } else {
            notifySaleRecorded(null, saleContext);
          }
        } else {
          const errorMessage = result?.error || result?.details?.error || "Could not record sale.";
          if (result?.status === 401) {
            showToast('Your session has expired. Please log in again to record sales.', 'error');
            try { sessionStorage.removeItem('authenticated'); } catch {}
            setTimeout(() => { window.location.replace('../index.html'); }, 1200);
          } else {
            showToast(errorMessage, 'error');
          }
        }
      } catch (e) {
        console.error('Sale recording failed:', e);
        showToast('Network error. Please try again.', 'error');
      }
    });
  }
  loadSheet();

  // ========= ORIGINAL SCANNER CODE (unchanged except handleDetected) =========
  let currentStream = null;
  let currentDeviceId = null;
  let devices = [];
  let zxingReader = null;
  let zxingStopFn = null;
  let lastValue = null;
  let engine = 'none';
  let nativeLoopAbort = null;  // abort controller for native loop
  let failoverTimer = null;
  let audioCtx = null;

  const AudioContextCtor = window.AudioContext || window.webkitAudioContext || null;
  const PREFERRED_CAMERA_KEY = 'preferredCameraId';

  const retryBtn = document.createElement('button');
  retryBtn.type = 'button';
  retryBtn.textContent = 'Retry';
  retryBtn.style.marginLeft = '8px';

  function rememberPreferredCamera(id) { if (!id) return; try { localStorage.setItem(PREFERRED_CAMERA_KEY, id); } catch {} }
  function readPreferredCamera() { try { return localStorage.getItem(PREFERRED_CAMERA_KEY); } catch { return null; } }
  function toggleRetry(show) { if (show) { if (!supportEl.contains(retryBtn)) supportEl.appendChild(retryBtn); retryBtn.hidden = false; retryBtn.disabled = false; } else { retryBtn.hidden = true; if (retryBtn.parentElement === supportEl) supportEl.removeChild(retryBtn); } }
  function setSupportMessage(message, { html = false, retry = false } = {}) { if (html) supportEl.innerHTML = message; else supportEl.textContent = message; toggleRetry(retry); }
  function showPermissionHint() {
    const ua = navigator.userAgent || '';
    const hints = [
      'Tap the address bar lock icon and allow camera access, then press <strong>Retry</strong>.'
    ];

    if (/Android/i.test(ua)) {
      hints.push('If you do not see a prompt, open <strong>Settings → Apps → Permissions → Camera</strong> and make sure your browser is allowed.');
      if (/(MIUI|XiaoMi|Redmi)/i.test(ua)) {
        hints.push('On Xiaomi/MIUI devices, also open the <strong>Security</strong> app → <strong>Privacy protection → Permission manager → Camera</strong> and enable access for the browser.');
      }
    } else if (/(iPhone|iPad|iPod)/i.test(ua)) {
      hints.push('On iOS, go to <strong>Settings → Safari → Camera</strong> (or the specific browser in Settings) and set it to <strong>Allow</strong>.');
    }

    const message = `
      <div class="permission-hint">
        <strong>Camera permission needed.</strong>
        <ul>${hints.map(hint => `<li>${hint}</li>`).join('')}</ul>
      </div>
    `;

    setSupportMessage(message, { html: true, retry: true });
  }

  resultEl.addEventListener('animationend', () => resultEl.classList.remove('flash'));

  const vibe = () => (navigator.vibrate && navigator.vibrate(60));
  const hasBarcodeDetector = 'BarcodeDetector' in window;

  function setEngine(name) { engine = name; engineChip.textContent = 'Engine: ' + name; }
  function setButtonsReady(ready) {
    startBtn.disabled = !ready;
    cameraSelect.disabled = !ready || !devices.length;
  }
  function showError(msg) {
    resultEl.innerHTML = `<span class="err">${sanitizeInput(msg)}</span>`;
  }

  function focusItemCard() {
    if (!itemCard) return;
    if (!itemCard.hasAttribute('tabindex')) {
      itemCard.setAttribute('tabindex', '-1');
    }
    requestAnimationFrame(() => {
      itemCard.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' });
      try {
        itemCard.focus({ preventScroll: true });
      } catch (err) {
        try { itemCard.focus(); } catch (_) {}
      }
    });
  }

  function ensureAudioCtx() { if (audioCtx || !AudioContextCtor) return; try { audioCtx = new AudioContextCtor(); } catch (e) { audioCtx = null; } }
  async function playBeep() {
    if (!AudioContextCtor) return;
    ensureAudioCtx();
    if (!audioCtx) return;
    if (audioCtx.state === 'suspended') {
      try { await audioCtx.resume(); }
      catch { return; }
    }

    const duration = 0.25;
    const t = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();

    osc.type = 'square';
    osc.frequency.setValueAtTime(1046.5, t); // bright C6 tone

    gain.gain.setValueAtTime(0.0001, t);
    gain.gain.exponentialRampToValueAtTime(0.5, t + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.0001, t + duration);

    osc.connect(gain).connect(audioCtx.destination);
    osc.start(t);
    osc.stop(t + duration + 0.05);
  }
  function flashResult() { resultEl.classList.remove('flash'); void resultEl.offsetWidth; resultEl.classList.add('flash'); }

  function showScanningFeedback() {
    const preview = document.getElementById('preview');
    if (!preview) return;
    preview.classList.add('scanning');
    setTimeout(() => preview.classList.remove('scanning'), 1000);
  }

  // *** replaced to include Google Sheet lookup ***
  function handleDetected(text, format) {
    if (!text || text === lastValue) return;
    lastValue = text;
    vibe(); playBeep(); flashResult();
    showScanningFeedback();

    // Show raw scan line for debugging
    resultEl.textContent = `Value: ${text}  |  Format: ${format || 'unknown'}`;

    // Lookup row by SKU
    const inputSku = String(text ?? "").trim();
    const sku = normalizeSku(inputSku);
    let row = skuIndex.get(sku);
    if (!row) {
      // Extra fallback: try linear search using the actual sku column
      const match = sheetRows.find(r => normalizeSku(r[skuKeyName]) === sku);
      if (match) {
        row = match;
        skuIndex.set(sku, row);
      }
    }
    if (row) {
      renderItem(row);
      addToScanHistory(row[skuKeyName] ?? inputSku, row['name'] ?? '');
    } else {
      if (itemPlaceholder) itemPlaceholder.style.display = "none";
      itemCard.style.display = "block";
      const safeSku = sanitizeInput(inputSku);
      itemCard.innerHTML = `<span class="err">No item found for SKU ${safeSku}</span>`;
      if (!sheetRows.length) {
        showToast('Inventory still loading…', 'info');
      } else {
        showToast(`No item found for SKU ${inputSku}`, 'error');
      }
      focusItemCard();
    }
  }

  manualForm?.addEventListener('submit', (event) => {
    event.preventDefault();
    const raw = manualInput?.value ?? '';
    let sku;
    try {
      sku = validateSKU(raw);
    } catch (err) {
      const message = err?.message || 'Invalid SKU';
      showError(message);
      showToast(message, 'error');
      if (manualInput) {
        try {
          manualInput.focus({ preventScroll: true });
        } catch (err) {
          manualInput.focus();
        }
        manualInput.select();
      }
      return;
    }
    lastValue = null;
    handleDetected(sku, 'manual');
    if (manualInput) {
      try {
        manualInput.focus({ preventScroll: true });
      } catch (err) {
        manualInput.focus();
      }
      manualInput.select();
    }
  });

  goldPriceForm?.addEventListener('submit', (event) => {
    event.preventDefault();
    const raw = String(goldPriceInput?.value ?? '').trim();
    const value = Number(raw.replace(',', '.'));
    if (!Number.isFinite(value) || value <= 0) {
      showToast('Enter a valid gold price.', 'error');
      goldPriceInput?.focus();
      goldPriceInput?.select?.();
      return;
    }
    setManualGoldPrice(value);
    if (goldPriceInput) {
      goldPriceInput.value = '';
    }
  });

  goldSuggestionButtons.forEach((button) => {
    button.addEventListener('click', () => {
      const delta = Number(button.dataset.goldSuggestion || '0');
      if (!Number.isFinite(delta) || delta <= 0) return;
      const base = Number.isFinite(goldPrice)
        ? goldPrice
        : Number.isFinite(manualGoldPrice)
          ? manualGoldPrice
          : NaN;
      if (!Number.isFinite(base) || base <= 0) {
        showToast('Gold price not available yet.', 'error');
        return;
      }
      const newValue = base + delta;
      const baseLabel = Number.isFinite(goldPrice) ? 'live' : 'manual';
      setManualGoldPrice(newValue, {
        toastMessage: `Applied ${baseLabel} price (${base.toFixed(2)}) + ${delta.toFixed(2)} = ${newValue.toFixed(2)}`,
      });
      if (goldPriceInput) {
        goldPriceInput.value = '';
      }
    });
  });

  goldPriceClear?.addEventListener('click', () => {
    const wasManual = isManualGoldActive();
    manualGoldPrice = null;
    manualGoldUpdatedAt = null;
    updateGoldPriceStatus();
    if (wasManual) {
      showToast('Reverted to live gold price.', 'info');
      if (lastRenderedItem) {
        renderItem(lastRenderedItem);
      }
    }
  });

  // ----- Wait for ZXing (fallback) to load
  function waitForZXing() {
    return new Promise((resolve, reject) => {
      if (window.ZXingBrowser) return resolve();
      const s = document.getElementById('zxing-script');
      if (!s) return reject(new Error('ZXing script tag not found'));
      if (s.dataset.ready === '1') return resolve();
      s.addEventListener('load', () => { s.dataset.ready = '1'; resolve(); });
      s.addEventListener('error', () => reject(new Error('Failed to load ZXing')));
    });
  }

  async function ensureHTTPS() {
    if (location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1') return true;
    showError('This page must be served over HTTPS (or localhost) for camera access. Tip: reload with https:// or move this page to a secure host.');
    return false;
  }

  // ----- Camera list
  function prepareForPermissionRequest() {
    startBtn.disabled = false;
    cameraSelect.disabled = true;
    switchBtn.disabled = true;
  }

  async function listCameras() {
    try {
      const tmp = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
      tmp.getTracks().forEach(t => t.stop());
    } catch (e) {
      if (e?.name !== 'NotAllowedError' && e?.name !== 'SecurityError') {
        console.warn('Prefetch camera request failed:', e);
      }
    }

    try {
      const all = await navigator.mediaDevices.enumerateDevices();
      devices = all.filter(d => d.kind === 'videoinput');
    } catch (e) {
      devices = [];
      if (e?.name === 'NotAllowedError' || e?.name === 'SecurityError') {
        prepareForPermissionRequest();
        setSupportMessage('Tap Start and allow camera access to begin scanning.', { html: false });
        toggleRetry(false);
        return 0;
      }
      setButtonsReady(false);
      showPermissionHint();
      throw e;
    }

    cameraSelect.innerHTML = '';
    devices.forEach((d, i) => {
      const opt = document.createElement('option');
      opt.value = d.deviceId;
      opt.textContent = d.label || (i === 0 ? 'Back Camera' : `Camera ${i+1}`);
      cameraSelect.appendChild(opt);
    });

    switchBtn.disabled = devices.length < 2;
    setButtonsReady(devices.length > 0);

    let targetId = null;
    if (currentDeviceId && devices.some(d => d.deviceId === currentDeviceId)) targetId = currentDeviceId;
    else {
      const preferred = readPreferredCamera();
      if (preferred && devices.some(d => d.deviceId === preferred)) targetId = preferred;
    }
    if (!targetId && devices.length) targetId = devices[0].deviceId;

    if (targetId) { cameraSelect.value = targetId; currentDeviceId = targetId; rememberPreferredCamera(currentDeviceId); }
    else currentDeviceId = null;

    toggleRetry(devices.length === 0);
    return devices.length;
  }

  async function openStream(deviceId) {
    const constraints = {
      audio: false,
      video: deviceId
        ? { deviceId: { exact: deviceId }, width: { ideal: 1920 }, height: { ideal: 1080 } }
        : { facingMode: { ideal: 'environment' }, width: { ideal: 1920 }, height: { ideal: 1080 } }
    };
    return await navigator.mediaDevices.getUserMedia(constraints);
  }

  function stopStream() { if (currentStream) { currentStream.getTracks().forEach(t => t.stop()); currentStream = null; } }
  function stopAll() {
    if (nativeLoopAbort) { nativeLoopAbort.aborted = true; nativeLoopAbort = null; }
    if (zxingStopFn) { try { zxingStopFn(); } catch {} zxingStopFn = null; }
    stopStream(); clearTimeout(failoverTimer);
    stopBtn.disabled = true; startBtn.disabled = false; switchBtn.disabled = devices.length < 2; torchBtn.disabled = true;
    setEngine('stopped'); setSupportMessage('Stopped.');
  }
  async function enableTorchIfSupported() {
    torchBtn.disabled = true;
    try {
      const track = currentStream?.getVideoTracks?.()[0];
      const caps = track?.getCapabilities?.();
      if (caps && 'torch' in caps) {
        torchBtn.disabled = false;
        let torchOn = false;
        torchBtn.onclick = async () => {
          torchOn = !torchOn;
          try {
            await track.applyConstraints({ advanced: [{ torch: torchOn }] });
            torchBtn.textContent = torchOn ? 'Turn torch off' : 'Toggle torch';
          } catch {}
        };
      }
    } catch {}
  }

  // ----- Native detector loop
  async function startNative() {
    let formats = ['code_128','ean_13','ean_8','upc_a','upc_e','code_39','itf','qr_code'];
    try {
      if (window.BarcodeDetector.getSupportedFormats) {
        const supported = await window.BarcodeDetector.getSupportedFormats();
        formats = formats.filter(f => supported.includes(f));
      }
    } catch {}
    const detector = new window.BarcodeDetector({ formats });
    setEngine('native');

    currentStream = await openStream(currentDeviceId);
    video.srcObject = currentStream; await video.play();
    enableTorchIfSupported();

    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });

    const processFrame = async () => {
      const w = video.videoWidth || 0, h = video.videoHeight || 0;
      if (!w || !h) return;
      const cropW = Math.floor(w * 0.9), cropH = Math.floor(h * 0.4);
      const sx = Math.floor((w - cropW) / 2), sy = Math.floor((h - cropH) / 2);
      if (canvas.width !== cropW || canvas.height !== cropH) { canvas.width = cropW; canvas.height = cropH; }
      ctx.drawImage(video, sx, sy, cropW, cropH, 0, 0, canvas.width, canvas.height);
      try {
        const codes = await detector.detect(canvas);
        if (codes && codes.length) {
          const b = codes[0];
          handleDetected(b.rawValue || '', b.format);
        }
      } catch {}
    };

    nativeLoopAbort = { aborted: false };
    const useVFC = typeof video.requestVideoFrameCallback === 'function';
    const schedule = () => {
      if (nativeLoopAbort?.aborted) return;
      const run = () => { if (nativeLoopAbort?.aborted) return; processFrame().catch(()=>{}).finally(schedule); };
      if (useVFC) video.requestVideoFrameCallback((_n,_m)=>run()); else requestAnimationFrame(()=>run());
    };
    schedule();
  }

  // ----- ZXing fallback
  async function startZXing() {
    await waitForZXing();
    setEngine('zxing');
    const { BrowserMultiFormatReader } = ZXingBrowser;
    if (!zxingReader) zxingReader = new BrowserMultiFormatReader(undefined, 350);
    const constraints = {
      audio: false,
      video: currentDeviceId
        ? { deviceId: { exact: currentDeviceId }, width: { ideal: 1920 }, height: { ideal: 1080 } }
        : { facingMode: { ideal: 'environment' }, width: { ideal: 1920 }, height: { ideal: 1080 } }
    };
    zxingStopFn = await zxingReader.decodeFromConstraints(constraints, video, (res) => {
      if (res) {
        const text = res.getText();
        const fmt = (res.getBarcodeFormat && res.getBarcodeFormat()) || 'unknown';
        handleDetected(text, fmt);
      }
    });
    currentStream = video.srcObject;
    enableTorchIfSupported();
  }

  async function startSelected() {
    lastValue = null;
    resultEl.textContent = 'Scanning…';
    startBtn.disabled = true; stopBtn.disabled = false;
    stopAll();
    try {
      if ('BarcodeDetector' in window) {
        await startNative();
        setSupportMessage('<span class="ok">Native detector running…</span>', { html: true });
        failoverTimer = setTimeout(async () => {
          if (!lastValue) {
            setSupportMessage('Switching to ZXing fallback…');
            if (nativeLoopAbort) nativeLoopAbort.aborted = true;
            stopStream();
            try { await startZXing(); } catch (e) { showError(e.message || 'Failed to start ZXing.'); }
          }
        }, 6000);
      } else {
        await startZXing();
        setSupportMessage('<span class="ok">ZXing running…</span>', { html: true });
      }
    } catch (e) {
      if (e?.name === 'NotAllowedError' || e?.name === 'SecurityError') {
        showPermissionHint();
      } else {
        showError(e?.message || 'Failed to start camera/decoder.');
      }
      startBtn.disabled = false; stopBtn.disabled = true;
    }
  }

  retryBtn.addEventListener('click', async () => {
    retryBtn.disabled = true;
    setSupportMessage('Requesting camera access…');
    try {
      const count = await listCameras();
      if (count > 0) {
        setSupportMessage(('BarcodeDetector' in window)
          ? 'Cameras found. Native + ZXing fallback ready.'
          : 'Cameras found. ZXing ready.');
      } else {
        showPermissionHint();
      }
    } catch (e) {
      showPermissionHint();
    } finally { retryBtn.disabled = false; }
  });

  startBtn.addEventListener('click', async () => { ensureAudioCtx(); await startSelected(); });
  stopBtn.addEventListener('click', stopAll);

  switchBtn.addEventListener('click', async () => {
    if (!devices.length) return;
    const idx = devices.findIndex(d => d.deviceId === currentDeviceId);
    const next = devices[(idx + 1) % devices.length];
    currentDeviceId = next.deviceId; rememberPreferredCamera(currentDeviceId);
    stopAll(); cameraSelect.value = next.deviceId; await startSelected();
  });

  cameraSelect.addEventListener('change', async () => {
    currentDeviceId = cameraSelect.value || null; rememberPreferredCamera(currentDeviceId);
    if (!currentStream) return; stopAll(); await startSelected();
  });

  (async () => {
    if (!await ensureHTTPS()) return;
    if (!navigator.mediaDevices?.getUserMedia) { setButtonsReady(false); showError('This browser does not support camera APIs.'); return; }
    const [zxingResult, cameraResult] = await Promise.allSettled([ waitForZXing(), listCameras() ]);
    if (zxingResult.status === 'rejected') console.warn('ZXing preload failed:', zxingResult.reason);
    if (cameraResult.status === 'fulfilled') {
      const count = cameraResult.value;
      if (count > 0) setSupportMessage(('BarcodeDetector' in window) ? 'Cameras found. Native + ZXing fallback ready.' : 'Cameras found. ZXing ready.');
      else showPermissionHint();
    } else { setButtonsReady(true); showPermissionHint(); }
  })();

  window.addEventListener('pagehide', stopAll);
})();
</script>
</body>
</html>
